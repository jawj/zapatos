const zapatosBundle = {"custom/PgGeometry.d.ts":"/*\n** Please edit this file as needed **\nIt's been generated by Zapatos as a custom type definition placeholder, and won't be overwritten\n*/\n\ndeclare module 'zapatos/custom' {\n  export type PgGeometry = any;  // replace with your custom type or interface as desired\n}\n","custom/index.d.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos, and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 - 2022 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\n// this empty declaration appears to fix relative imports in other custom type files\ndeclare module 'zapatos/custom' { }\n","schema.d.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos, and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 - 2022 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\ndeclare module 'zapatos/schema' {\n\n  import type * as db from 'zapatos/db';\n  import type * as c from 'zapatos/custom';\n\n  // got a type error on schemaVersionCanary below? update by running `npx zapatos`\n  export interface schemaVersionCanary extends db.SchemaVersionCanary { version: 103 }\n\n\n  /* === schema: public === */\n\n  /* --- enums --- */\n\n  export type appleEnvironment = 'PROD' | 'Sandbox';\n  export namespace every {\n    export type appleEnvironment = ['PROD', 'Sandbox'];\n  }\n\n  /* --- tables --- */\n\n  /**\n   * **appleTransactions**\n   * - Table in database\n   */\n  export namespace appleTransactions {\n    export type Table = 'appleTransactions';\n    export interface Selectable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n    environment: appleEnvironment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    originalTransactionId: string;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    accountId: number;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    latestReceiptData: string | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n    environment: appleEnvironment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    originalTransactionId: string;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    accountId: number;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    latestReceiptData: string | null;\n    }\n    export interface Whereable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n    environment?: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    originalTransactionId?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    accountId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    latestReceiptData?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n    environment: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    originalTransactionId: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    accountId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n    environment?: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.SQLFragment<any, appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment>;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    originalTransactionId?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    accountId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'appleTransactionsPrimaryKey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **arrays**\n   * - Table in database\n   */\n  export namespace arrays {\n    export type Table = 'arrays';\n    export interface Selectable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n    jsonValue: db.JSONValue | null;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n    textArray: string[] | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n    jsonValue: db.JSONValue | null;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n    textArray: string[] | null;\n    }\n    export interface Whereable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n    jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n    textArray?: string[] | db.Parameter<string[]> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string[] | db.Parameter<string[]> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n    jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n    textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n    jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment>;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n    textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = never;\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **authors**\n   * - Table in database\n   */\n  export namespace authors {\n    export type Table = 'authors';\n    export interface Selectable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n    isLiving: boolean | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n    isLiving: boolean | null;\n    }\n    export interface Whereable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n    isLiving?: boolean | db.Parameter<boolean> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, boolean | db.Parameter<boolean> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n    isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n    isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'authors_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **bankAccounts**\n   * - Table in database\n   */\n  export namespace bankAccounts {\n    export type Table = 'bankAccounts';\n    export interface Selectable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n    id: number;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    balance: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n    id: number;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    balance: number;\n    }\n    export interface Whereable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    balance?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'bankAccounts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **books**\n   * - Table in database\n   */\n  export namespace books {\n    export type Table = 'books';\n    export interface Selectable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    authorId: number;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    title: string | null;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    createdAt: Date;\n    }\n    export interface JSONSelectable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    authorId: number;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    title: string | null;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    createdAt: db.TimestampTzString;\n    }\n    export interface Whereable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    authorId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    title?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    authorId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    authorId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'books_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **doctors**\n   * - Table in database\n   */\n  export namespace doctors {\n    export type Table = 'doctors';\n    export interface Selectable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n    }\n    export interface Whereable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'doctors_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **emailAuthentication**\n   * - Table in database\n   */\n  export namespace emailAuthentication {\n    export type Table = 'emailAuthentication';\n    export interface Selectable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    email: string;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    consecutiveFailedLogins: number;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n    lastFailedLogin: Date | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    email: string;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    consecutiveFailedLogins: number;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n    lastFailedLogin: db.TimestampTzString | null;\n    }\n    export interface Whereable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    email?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    consecutiveFailedLogins?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n    lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    email: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n    lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    email?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n    consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n    lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'emailAuthentication_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **employees**\n   * - Table in database\n   */\n  export namespace employees {\n    export type Table = 'employees';\n    export interface Selectable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n    managerId: number | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n    managerId: number | null;\n    }\n    export interface Whereable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n    managerId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n    managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n    managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'employees_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **nameCounts**\n   * - Table in database\n   */\n  export namespace nameCounts {\n    export type Table = 'nameCounts';\n    export interface Selectable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    count: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    count: number;\n    }\n    export interface Whereable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    count?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    count: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    count?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'nameCounts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **photos**\n   * - Table in database\n   */\n  export namespace photos {\n    export type Table = 'photos';\n    export interface Selectable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    photoId: number;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    url: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    photoId: number;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    url: string;\n    }\n    export interface Whereable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    photoId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    url?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    photoId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    url: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    photoId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    url?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'photos_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **shifts**\n   * - Table in database\n   */\n  export namespace shifts {\n    export type Table = 'shifts';\n    export interface Selectable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n    day: Date;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    doctorId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n    day: db.DateString;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    doctorId: number;\n    }\n    export interface Whereable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n    day?: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    doctorId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n    day: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    doctorId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n    day?: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.SQLFragment<any, (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment>;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    doctorId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'shifts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **stores**\n   * - Table in database\n   */\n  export namespace stores {\n    export type Table = 'stores';\n    export interface Selectable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n    geom: c.PgGeometry;\n    }\n    export interface JSONSelectable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n    id: number;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n    geom: c.PgGeometry;\n    }\n    export interface Whereable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n    geom?: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n    geom: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n    geom?: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.SQLFragment<any, c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'stores_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **subjectPhotos**\n   * - Table in database\n   */\n  export namespace subjectPhotos {\n    export type Table = 'subjectPhotos';\n    export interface Selectable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    subjectId: number;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    photoId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    subjectId: number;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    photoId: number;\n    }\n    export interface Whereable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    subjectId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    photoId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    subjectId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    photoId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    subjectId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    photoId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'userphotosunique';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **subjects**\n   * - Table in database\n   */\n  export namespace subjects {\n    export type Table = 'subjects';\n    export interface Selectable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    subjectId: number;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    subjectId: number;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string;\n    }\n    export interface Whereable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    subjectId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    subjectId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    subjectId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'subjects_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **tags**\n   * - Table in database\n   */\n  export namespace tags {\n    export type Table = 'tags';\n    export interface Selectable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    tag: string;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    bookId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    tag: string;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    bookId: number;\n    }\n    export interface Whereable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    tag?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    bookId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    tag: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    bookId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    tag?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n    bookId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'tagsUniqueIdx';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **usedVoucherCodes**\n   * - Table in database\n   */\n  export namespace usedVoucherCodes {\n    export type Table = 'usedVoucherCodes';\n    export interface Selectable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    code: string;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    redeemedAt: Date;\n    }\n    export interface JSONSelectable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    code: string;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    redeemedAt: db.TimestampTzString;\n    }\n    export interface Whereable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    code?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    code: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n    code?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n    redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'usedVoucherCodes_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /**\n   * **users**\n   * - Table in database\n   */\n  export namespace users {\n    export type Table = 'users';\n    export interface Selectable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    id: number;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    ipOctet: number;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    friendlyName: string | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    id: number;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    ipOctet: number;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    friendlyName: string | null;\n    }\n    export interface Whereable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    ipOctet?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    friendlyName?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    ipOctet?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    friendlyName?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n    ipOctet?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n    friendlyName?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'users_ipOctet_key' | 'users_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = Table | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Whereable | Column | db.ParentColumn | db.GenericSQLExpression;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /* --- aggregate types --- */\n\n  export namespace public {  \n    export type Table = appleTransactions.Table | arrays.Table | authors.Table | bankAccounts.Table | books.Table | doctors.Table | emailAuthentication.Table | employees.Table | nameCounts.Table | photos.Table | shifts.Table | stores.Table | subjectPhotos.Table | subjects.Table | tags.Table | usedVoucherCodes.Table | users.Table;\n    export type Selectable = appleTransactions.Selectable | arrays.Selectable | authors.Selectable | bankAccounts.Selectable | books.Selectable | doctors.Selectable | emailAuthentication.Selectable | employees.Selectable | nameCounts.Selectable | photos.Selectable | shifts.Selectable | stores.Selectable | subjectPhotos.Selectable | subjects.Selectable | tags.Selectable | usedVoucherCodes.Selectable | users.Selectable;\n    export type JSONSelectable = appleTransactions.JSONSelectable | arrays.JSONSelectable | authors.JSONSelectable | bankAccounts.JSONSelectable | books.JSONSelectable | doctors.JSONSelectable | emailAuthentication.JSONSelectable | employees.JSONSelectable | nameCounts.JSONSelectable | photos.JSONSelectable | shifts.JSONSelectable | stores.JSONSelectable | subjectPhotos.JSONSelectable | subjects.JSONSelectable | tags.JSONSelectable | usedVoucherCodes.JSONSelectable | users.JSONSelectable;\n    export type Whereable = appleTransactions.Whereable | arrays.Whereable | authors.Whereable | bankAccounts.Whereable | books.Whereable | doctors.Whereable | emailAuthentication.Whereable | employees.Whereable | nameCounts.Whereable | photos.Whereable | shifts.Whereable | stores.Whereable | subjectPhotos.Whereable | subjects.Whereable | tags.Whereable | usedVoucherCodes.Whereable | users.Whereable;\n    export type Insertable = appleTransactions.Insertable | arrays.Insertable | authors.Insertable | bankAccounts.Insertable | books.Insertable | doctors.Insertable | emailAuthentication.Insertable | employees.Insertable | nameCounts.Insertable | photos.Insertable | shifts.Insertable | stores.Insertable | subjectPhotos.Insertable | subjects.Insertable | tags.Insertable | usedVoucherCodes.Insertable | users.Insertable;\n    export type Updatable = appleTransactions.Updatable | arrays.Updatable | authors.Updatable | bankAccounts.Updatable | books.Updatable | doctors.Updatable | emailAuthentication.Updatable | employees.Updatable | nameCounts.Updatable | photos.Updatable | shifts.Updatable | stores.Updatable | subjectPhotos.Updatable | subjects.Updatable | tags.Updatable | usedVoucherCodes.Updatable | users.Updatable;\n    export type UniqueIndex = appleTransactions.UniqueIndex | arrays.UniqueIndex | authors.UniqueIndex | bankAccounts.UniqueIndex | books.UniqueIndex | doctors.UniqueIndex | emailAuthentication.UniqueIndex | employees.UniqueIndex | nameCounts.UniqueIndex | photos.UniqueIndex | shifts.UniqueIndex | stores.UniqueIndex | subjectPhotos.UniqueIndex | subjects.UniqueIndex | tags.UniqueIndex | usedVoucherCodes.UniqueIndex | users.UniqueIndex;\n    export type Column = appleTransactions.Column | arrays.Column | authors.Column | bankAccounts.Column | books.Column | doctors.Column | emailAuthentication.Column | employees.Column | nameCounts.Column | photos.Column | shifts.Column | stores.Column | subjectPhotos.Column | subjects.Column | tags.Column | usedVoucherCodes.Column | users.Column;\n  \n    export type AllBaseTables = [appleTransactions.Table, arrays.Table, authors.Table, bankAccounts.Table, books.Table, doctors.Table, emailAuthentication.Table, employees.Table, nameCounts.Table, photos.Table, shifts.Table, stores.Table, subjectPhotos.Table, subjects.Table, tags.Table, usedVoucherCodes.Table, users.Table];\n    export type AllForeignTables = [];\n    export type AllViews = [];\n    export type AllMaterializedViews = [];\n    export type AllTablesAndViews = [appleTransactions.Table, arrays.Table, authors.Table, bankAccounts.Table, books.Table, doctors.Table, emailAuthentication.Table, employees.Table, nameCounts.Table, photos.Table, shifts.Table, stores.Table, subjectPhotos.Table, subjects.Table, tags.Table, usedVoucherCodes.Table, users.Table];\n  }\n\n\n\n  /* === global aggregate types === */\n\n  export type Schema = 'public';\n  export type Table = public.Table;\n  export type Selectable = public.Selectable;\n  export type JSONSelectable = public.JSONSelectable;\n  export type Whereable = public.Whereable;\n  export type Insertable = public.Insertable;\n  export type Updatable = public.Updatable;\n  export type UniqueIndex = public.UniqueIndex;\n  export type Column = public.Column;\n\n  export type AllSchemas = ['public'];\n  export type AllBaseTables = [...public.AllBaseTables];\n  export type AllForeignTables = [...public.AllForeignTables];\n  export type AllViews = [...public.AllViews];\n  export type AllMaterializedViews = [...public.AllMaterializedViews];\n  export type AllTablesAndViews = [...public.AllTablesAndViews];\n\n\n  /* === lookups === */\n\n  export type SelectableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Selectable;\n    \"arrays\": arrays.Selectable;\n    \"authors\": authors.Selectable;\n    \"bankAccounts\": bankAccounts.Selectable;\n    \"books\": books.Selectable;\n    \"doctors\": doctors.Selectable;\n    \"emailAuthentication\": emailAuthentication.Selectable;\n    \"employees\": employees.Selectable;\n    \"nameCounts\": nameCounts.Selectable;\n    \"photos\": photos.Selectable;\n    \"shifts\": shifts.Selectable;\n    \"stores\": stores.Selectable;\n    \"subjectPhotos\": subjectPhotos.Selectable;\n    \"subjects\": subjects.Selectable;\n    \"tags\": tags.Selectable;\n    \"usedVoucherCodes\": usedVoucherCodes.Selectable;\n    \"users\": users.Selectable;\n  }[T];\n\n  export type JSONSelectableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.JSONSelectable;\n    \"arrays\": arrays.JSONSelectable;\n    \"authors\": authors.JSONSelectable;\n    \"bankAccounts\": bankAccounts.JSONSelectable;\n    \"books\": books.JSONSelectable;\n    \"doctors\": doctors.JSONSelectable;\n    \"emailAuthentication\": emailAuthentication.JSONSelectable;\n    \"employees\": employees.JSONSelectable;\n    \"nameCounts\": nameCounts.JSONSelectable;\n    \"photos\": photos.JSONSelectable;\n    \"shifts\": shifts.JSONSelectable;\n    \"stores\": stores.JSONSelectable;\n    \"subjectPhotos\": subjectPhotos.JSONSelectable;\n    \"subjects\": subjects.JSONSelectable;\n    \"tags\": tags.JSONSelectable;\n    \"usedVoucherCodes\": usedVoucherCodes.JSONSelectable;\n    \"users\": users.JSONSelectable;\n  }[T];\n\n  export type WhereableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Whereable;\n    \"arrays\": arrays.Whereable;\n    \"authors\": authors.Whereable;\n    \"bankAccounts\": bankAccounts.Whereable;\n    \"books\": books.Whereable;\n    \"doctors\": doctors.Whereable;\n    \"emailAuthentication\": emailAuthentication.Whereable;\n    \"employees\": employees.Whereable;\n    \"nameCounts\": nameCounts.Whereable;\n    \"photos\": photos.Whereable;\n    \"shifts\": shifts.Whereable;\n    \"stores\": stores.Whereable;\n    \"subjectPhotos\": subjectPhotos.Whereable;\n    \"subjects\": subjects.Whereable;\n    \"tags\": tags.Whereable;\n    \"usedVoucherCodes\": usedVoucherCodes.Whereable;\n    \"users\": users.Whereable;\n  }[T];\n\n  export type InsertableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Insertable;\n    \"arrays\": arrays.Insertable;\n    \"authors\": authors.Insertable;\n    \"bankAccounts\": bankAccounts.Insertable;\n    \"books\": books.Insertable;\n    \"doctors\": doctors.Insertable;\n    \"emailAuthentication\": emailAuthentication.Insertable;\n    \"employees\": employees.Insertable;\n    \"nameCounts\": nameCounts.Insertable;\n    \"photos\": photos.Insertable;\n    \"shifts\": shifts.Insertable;\n    \"stores\": stores.Insertable;\n    \"subjectPhotos\": subjectPhotos.Insertable;\n    \"subjects\": subjects.Insertable;\n    \"tags\": tags.Insertable;\n    \"usedVoucherCodes\": usedVoucherCodes.Insertable;\n    \"users\": users.Insertable;\n  }[T];\n\n  export type UpdatableForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Updatable;\n    \"arrays\": arrays.Updatable;\n    \"authors\": authors.Updatable;\n    \"bankAccounts\": bankAccounts.Updatable;\n    \"books\": books.Updatable;\n    \"doctors\": doctors.Updatable;\n    \"emailAuthentication\": emailAuthentication.Updatable;\n    \"employees\": employees.Updatable;\n    \"nameCounts\": nameCounts.Updatable;\n    \"photos\": photos.Updatable;\n    \"shifts\": shifts.Updatable;\n    \"stores\": stores.Updatable;\n    \"subjectPhotos\": subjectPhotos.Updatable;\n    \"subjects\": subjects.Updatable;\n    \"tags\": tags.Updatable;\n    \"usedVoucherCodes\": usedVoucherCodes.Updatable;\n    \"users\": users.Updatable;\n  }[T];\n\n  export type UniqueIndexForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.UniqueIndex;\n    \"arrays\": arrays.UniqueIndex;\n    \"authors\": authors.UniqueIndex;\n    \"bankAccounts\": bankAccounts.UniqueIndex;\n    \"books\": books.UniqueIndex;\n    \"doctors\": doctors.UniqueIndex;\n    \"emailAuthentication\": emailAuthentication.UniqueIndex;\n    \"employees\": employees.UniqueIndex;\n    \"nameCounts\": nameCounts.UniqueIndex;\n    \"photos\": photos.UniqueIndex;\n    \"shifts\": shifts.UniqueIndex;\n    \"stores\": stores.UniqueIndex;\n    \"subjectPhotos\": subjectPhotos.UniqueIndex;\n    \"subjects\": subjects.UniqueIndex;\n    \"tags\": tags.UniqueIndex;\n    \"usedVoucherCodes\": usedVoucherCodes.UniqueIndex;\n    \"users\": users.UniqueIndex;\n  }[T];\n\n  export type ColumnForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.Column;\n    \"arrays\": arrays.Column;\n    \"authors\": authors.Column;\n    \"bankAccounts\": bankAccounts.Column;\n    \"books\": books.Column;\n    \"doctors\": doctors.Column;\n    \"emailAuthentication\": emailAuthentication.Column;\n    \"employees\": employees.Column;\n    \"nameCounts\": nameCounts.Column;\n    \"photos\": photos.Column;\n    \"shifts\": shifts.Column;\n    \"stores\": stores.Column;\n    \"subjectPhotos\": subjectPhotos.Column;\n    \"subjects\": subjects.Column;\n    \"tags\": tags.Column;\n    \"usedVoucherCodes\": usedVoucherCodes.Column;\n    \"users\": users.Column;\n  }[T];\n\n  export type SQLForTable<T extends Table> = {\n    \"appleTransactions\": appleTransactions.SQL;\n    \"arrays\": arrays.SQL;\n    \"authors\": authors.SQL;\n    \"bankAccounts\": bankAccounts.SQL;\n    \"books\": books.SQL;\n    \"doctors\": doctors.SQL;\n    \"emailAuthentication\": emailAuthentication.SQL;\n    \"employees\": employees.SQL;\n    \"nameCounts\": nameCounts.SQL;\n    \"photos\": photos.SQL;\n    \"shifts\": shifts.SQL;\n    \"stores\": stores.SQL;\n    \"subjectPhotos\": subjectPhotos.SQL;\n    \"subjects\": subjects.SQL;\n    \"tags\": tags.SQL;\n    \"usedVoucherCodes\": usedVoucherCodes.SQL;\n    \"users\": users.SQL;\n  }[T];\n\n}\n","node_modules/@types/zapatos/db/canary.d.ts":"/**\n * This value gets incremented whenever there's an incompatible change to the\n * generated schema format, in order to raise a type error and thereby force\n * schema regeneration.\n */\nexport interface SchemaVersionCanary {\n    version: 103;\n}\n","node_modules/@types/zapatos/db/conditions.d.ts":"import { SQLFragment } from './core';\nexport declare const isNull: SQLFragment<boolean, never>;\nexport declare const isNotNull: SQLFragment<boolean, never>;\nexport declare const isTrue: SQLFragment<boolean, never>;\nexport declare const isNotTrue: SQLFragment<boolean, never>;\nexport declare const isFalse: SQLFragment<boolean, never>;\nexport declare const isNotFalse: SQLFragment<boolean, never>;\nexport declare const isUnknown: SQLFragment<boolean, never>;\nexport declare const isNotUnknown: SQLFragment<boolean, never>;\nexport declare const isDistinctFrom: <T>(a: T) => SQLFragment<boolean, T>;\nexport declare const isNotDistinctFrom: <T>(a: T) => SQLFragment<boolean, T>;\nexport declare const eq: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const ne: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const gt: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const gte: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const lt: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const lte: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const between: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const betweenSymmetric: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const notBetween: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const notBetweenSymmetric: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const like: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notLike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const ilike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notIlike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const similarTo: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notSimilarTo: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const reMatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const reImatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notReMatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notReImatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const isIn: <T>(a: readonly T[]) => SQLFragment<any[], never> | SQLFragment<boolean | null, T>;\nexport declare const isNotIn: <T>(a: readonly T[]) => SQLFragment<any[], never> | SQLFragment<boolean | null, T>;\nexport declare const or: <T>(...conditions: SQLFragment<any, T>[]) => SQLFragment<boolean | null, T>;\nexport declare const and: <T>(...conditions: SQLFragment<any, T>[]) => SQLFragment<boolean | null, T>;\nexport declare const not: <T>(condition: SQLFragment<any, T>) => SQLFragment<boolean | null, T>;\ndeclare type PluralisingIntervalUnit = 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year' | 'decade';\ndeclare type IntervalUnit = PluralisingIntervalUnit | `${PluralisingIntervalUnit}s` | 'century' | 'centuries' | 'millennium' | 'millennia';\nexport declare const fromNow: (n: number, unit?: IntervalUnit) => SQLFragment<any[], never>;\nexport declare const after: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const before: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const now: SQLFragment<any[], never>;\nexport declare const add: <T extends number | Date>(a: T) => SQLFragment<number, T>;\nexport declare const subtract: <T extends number | Date>(a: T) => SQLFragment<number, T>;\nexport {};\n","node_modules/@types/zapatos/db/config.d.ts":"export interface SQLQuery {\n    text: string;\n    values: any[];\n    name?: string;\n}\nexport interface Config {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?(query: SQLQuery, txnId?: number): void;\n    resultListener?(result: any, txnId?: number, elapsedMs?: number): void;\n    transactionListener?(message: string, txnId?: number): void;\n}\nexport declare type NewConfig = Partial<Config>;\n/**\n * Get (a copy of) the current configuration.\n */\nexport declare const getConfig: () => {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?(query: SQLQuery, txnId?: number | undefined): void;\n    resultListener?(result: any, txnId?: number | undefined, elapsedMs?: number | undefined): void;\n    transactionListener?(message: string, txnId?: number | undefined): void;\n};\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport declare const setConfig: (newConfig: NewConfig) => {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?: ((query: SQLQuery, txnId?: number | undefined) => void) | undefined;\n    resultListener?: ((result: any, txnId?: number | undefined, elapsedMs?: number | undefined) => void) | undefined;\n    transactionListener?: ((message: string, txnId?: number | undefined) => void) | undefined;\n};\n","node_modules/@types/zapatos/db/core.d.ts":"/// <reference types=\"node\" />\nimport type * as pg from 'pg';\nimport { SQLQuery } from './config';\nimport { NoInfer } from './utils';\nimport type { Updatable, Whereable, Table, Column } from 'zapatos/schema';\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport declare const Default: unique symbol;\nexport declare type DefaultType = typeof Default;\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport declare const self: unique symbol;\nexport declare type SelfType = typeof self;\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport declare const all: unique symbol;\nexport declare type AllType = typeof all;\n/**\n * JSON types\n */\nexport declare type JSONValue = null | boolean | number | string | JSONObject | JSONArray;\nexport declare type JSONObject = {\n    [k: string]: JSONValue;\n};\nexport declare type JSONArray = JSONValue[];\n/**\n * `int8` value represented as a string\n */\nexport declare type Int8String = `${number}`;\n/**\n * Generic range value represented as a string\n */\nexport declare type RangeString<Bound extends string | number> = `${'[' | '('}${Bound},${Bound}${']' | ')'}`;\n/**\n * `tsrange`, `tstzrange` or `daterange` value represented as a string. The\n * format of the upper and lower bound `date`, `timestamp` or `timestamptz`\n * values depends on pg's `DateStyle` setting.\n */\nexport declare type DateRangeString = RangeString<string>;\n/**\n * `int4range`, `int8range` or `numrange` value represented as a string\n */\nexport declare type NumberRangeString = RangeString<number | ''>;\n/**\n * `bytea` value represented as a hex string. Note: for large objects, use\n * something like https://www.npmjs.com/package/pg-large-object instead.\n */\nexport declare type ByteArrayString = `\\\\x${string}`;\n/**\n * Make a function `STRICT` in the Postgres sense  where it's an alias for\n * `RETURNS NULL ON NULL INPUT`  with appropriate typing.\n *\n * For example, Zapatos' `toBuffer()` function is defined as:\n *\n * ```\n * export const toBuffer = strict((ba: ByteArrayString) => Buffer.from(ba.slice(2), 'hex'));\n * ```\n *\n * The generic input and output types `FnIn` and `FnOut` can be inferred from\n * `fn`, as seen above, but can also be explicitly narrowed. For example, to\n * convert specifically from `TimestampTzString` to Luxon's `DateTime`, but\n * pass through `null`s unchanged:\n *\n * ```\n * const toDateTime = db.strict<db.TimestampTzString, DateTime>(DateTime.fromISO);\n * ```\n *\n * @param fn The single-argument transformation function to be made strict.\n */\nexport declare function strict<FnIn, FnOut>(fn: (x: FnIn) => FnOut): <T extends FnIn | null>(d: T) => T extends FnIn ? Exclude<T, FnIn> | FnOut : T;\n/**\n * Convert a `bytea` hex representation to a JavaScript `Buffer`. Note: for\n * large objects, use something like\n * [pg-large-object](https://www.npmjs.com/package/pg-large-object) instead.\n *\n * @param ba The `ByteArrayString` hex representation (or `null`)\n */\nexport declare const toBuffer: <T extends `\\\\x${string}` | null>(d: T) => T extends `\\\\x${string}` ? Buffer | Exclude<T, `\\\\x${string}`> : T;\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value\n * at the appropriate position of the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to\n * this type within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If\n * `true`, the value will be JSON stringified and cast to `json` (irrespective\n * of the configuration parameters `castArrayParamsToJson` and\n * `castObjectParamsToJson`). If `false`, the value will **not** be JSON-\n * stringified or cast to `json` (again irrespective of the configuration\n * parameters `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport declare class Parameter<T = any> {\n    value: T;\n    cast?: string | boolean | undefined;\n    constructor(value: T, cast?: string | boolean | undefined);\n}\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter\n * (`$1`, `$2`, etc) and adds its wrapped value at the appropriate position of\n * the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to\n * this type within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If\n * `true`, the value will be JSON stringified and cast to `json` (irrespective\n * of the configuration parameters `castArrayParamsToJson` and\n * `castObjectParamsToJson`). If `false`, the value will **not** be JSON\n * stringified or cast to `json` (again irrespective of the configuration\n * parameters `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport declare function param<T = any>(x: T, cast?: boolean | string): Parameter<T>;\n/**\n *  **DANGEROUS** \n *\n * Compiles to the wrapped string value, as is, which may enable SQL injection\n * attacks.\n */\nexport declare class DangerousRawString {\n    value: string;\n    constructor(value: string);\n}\n/**\n *  **DANGEROUS** \n *\n * Remember [Little Bobby Tables](https://xkcd.com/327/).\n * Did you want `db.param` instead?\n * ---\n * Returns a `DangerousRawString` instance, wrapping a string.\n * `DangerousRawString` compiles to the wrapped string value, as-is, which may\n * enable SQL injection attacks.\n */\nexport declare function raw(x: string): DangerousRawString;\n/**\n * Wraps either an array or object, and compiles to a quoted, comma-separated\n * list of array values (for use in a `SELECT` query) or object keys (for use\n * in an `INSERT`, `UPDATE` or `UPSERT` query, alongside `ColumnValues`).\n */\nexport declare class ColumnNames<T> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object.\n * `ColumnNames` compiles to a quoted, comma-separated list of array values (for\n * use in a `SELECT` query) or object keys (for use in an `INSERT`, `UDPATE` or\n * `UPSERT` query alongside a `ColumnValues`).\n */\nexport declare function cols<T>(x: T): ColumnNames<T>;\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an\n * `INSERT`, `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport declare class ColumnValues<T> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to\n * a  quoted, comma-separated list of object keys for use in an INSERT, UPDATE\n * or UPSERT query alongside a `ColumnNames`.\n */\nexport declare function vals<T>(x: T): ColumnValues<T>;\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport declare class ParentColumn<T extends Column | undefined = Column | undefined> {\n    value?: T | undefined;\n    constructor(value?: T | undefined);\n}\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to\n * that column name of the table of the parent query.\n */\nexport declare function parent<T extends Column | undefined = Column | undefined>(x?: T): ParentColumn<T>;\nexport declare type GenericSQLExpression = SQLFragment<any, any> | Parameter | DefaultType | DangerousRawString | SelfType;\nexport declare type SQLExpression = Table | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable | any[]> | Whereable | Column | ParentColumn | GenericSQLExpression;\nexport declare type SQL = SQLExpression | SQLExpression[];\nexport declare type Queryable = pg.ClientBase | pg.Pool;\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type\n * argument defines what interpolated value types are allowed. The second\n * defines what type the `SQLFragment` produces, where relevant (i.e. when\n * calling `.run(...)` on it, or using it as the value of an `extras` object).\n */\nexport declare function sql<Interpolations = SQL, RunResult = pg.QueryResult['rows'], Constraint = never>(literals: TemplateStringsArray, ...expressions: NoInfer<Interpolations>[]): SQLFragment<RunResult, Constraint>;\nexport declare class SQLFragment<RunResult = pg.QueryResult['rows'], Constraint = never> {\n    protected literals: string[];\n    protected expressions: SQL[];\n    protected constraint?: Constraint;\n    /**\n     * When calling `run`, this function is applied to the object returned by `pg`\n     * to produce the result that is returned. By default, the `rows` array is\n     * returned  i.e. `(qr) => qr.rows`  but some shortcut functions alter this\n     * in order to match their declared `RunResult` type.\n     */\n    runResultTransform: (qr: pg.QueryResult) => any;\n    parentTable?: string;\n    preparedName?: string;\n    noop: boolean;\n    noopResult: any;\n    constructor(literals: string[], expressions: SQL[]);\n    /**\n     * Instruct Postgres to treat this as a prepared statement: see\n     * https://node-postgres.com/features/queries#prepared-statements\n     * @param name A name for the prepared query. If not specified, it takes the\n     * value '_zapatos_prepared_N', where N is an increasing sequence number.\n     */\n    prepared: (name?: string) => this;\n    /**\n     * Compile and run this query using the provided database connection. What's\n     * returned is piped via `runResultTransform` before being returned.\n     * @param queryable A database client or pool\n     * @param force If true, force this query to hit the DB even if it's marked as a no-op\n     */\n    run: (queryable: Queryable, force?: boolean) => Promise<RunResult>;\n    /**\n     * Compile this query, returning a `{ text: string, values: any[] }` object\n     * that could be passed to the `pg` query function. Arguments are generally\n     * only passed when the function calls itself recursively.\n     */\n    compile: (result?: SQLQuery, parentTable?: string | undefined, currentColumn?: string | undefined) => SQLQuery;\n    compileExpression: (expression: SQL, result?: SQLQuery, parentTable?: string | undefined, currentColumn?: string | undefined) => void;\n}\n","node_modules/@types/zapatos/db/date.d.ts":"/**\n * An ISO8601-formatted date string, such as `\"2021-05-25\"`.\n */\nexport declare type DateString = `${number}-${number}-${number}`;\n/**\n * An ISO8601-formatted time string, such as `\"14:41\"` or `\"14:41:10.249\"`.\n */\nexport declare type TimeString = `${number}:${number}${'' | `:${number}`}`;\n/**\n * A timezone suffix string, such as `\"Z\"`, `\"-02\"`, or `\"+01:00\"`.\n */\nexport declare type TzSuffix = 'Z' | `${'+' | '-'}${number}${'' | `:${number}`}`;\n/**\n * A time and timezone string, such as `\"14:41:10+02\"`. **Postgres docs advise\n * against use of this type except in legacy contexts.**\n */\nexport declare type TimeTzString = `${TimeString}${TzSuffix}`;\n/**\n * An ISO8601-formatted date and time string **with no timezone**, such as\n * `\"2021-05-25T14:41.10.249097\"`.\n */\nexport declare type TimestampString = `${DateString}T${TimeString}`;\n/**\n * An ISO8601-formatted date, time and (numeric) timezone string, such as\n * `\"2021-05-25T14:41.10.249097+01:00\"`.\n */\nexport declare type TimestampTzString = `${TimestampString}${TzSuffix}`;\ndeclare type TzLocalOrUTC = 'UTC' | 'local';\ninterface ToDate {\n    <D extends null | TimestampTzString>(d: D, tzInterpretation?: undefined): D extends null ? null : Date;\n    <D extends null | TimestampString | DateString>(d: D, tzInterpretation: TzLocalOrUTC): D extends null ? null : Date;\n}\n/**\n * Convert a `TimestampTzString`, `TimestampString` or `DateString` to a\n * JavaScript `Date`. For `TimestampString` and `DateString`, you must specify\n * whether the input is to be interpreted in the JavaScript environment's local\n * time or as UTC.\n *\n * Nullability is preserved (e.g. `TimestampTzString | null` input gives\n * `Date | null` output).\n *\n * _Note:_ Postgres date-time types default to microsecond precision, but must be\n * truncated to the millisecond precision of a JavaScript `Date` here.\n *\n * @param d A `TimestampTzString`, `TimestampString` or `DateString` (or\n * `null`) for conversion.\n * @param tzInterpretation For `TimestampString` or `DateString` input only,\n * `\"UTC\"` if the input is to be interpreted as UTC or `\"local\"` if it is to be\n * interpreted in the JavaScript environment's local time\n */\nexport declare const toDate: ToDate;\ninterface ToString {\n    <D extends Date | null, T extends 'timestamptz' | `${'timestamp' | 'date'}:${TzLocalOrUTC}`>(d: D, stringTypeTz: T): D extends null ? null : {\n        'timestamptz': TimestampTzString;\n        'timestamp:UTC': TimestampString;\n        'timestamp:local': TimestampString;\n        'date:UTC': DateString;\n        'date:local': DateString;\n    }[T];\n}\n/**\n * Convert a JavaScript `Date` to a `TimestampTzString`, `TimestampString` or\n * `DateString`.\n *\n * For `TimestampString` and `DateString`, you must specify whether the input\n * is to be expressed in the JavaScript environment's local time or as UTC.\n *\n * Nullability is preserved (e.g. `Date | null` maps to something extending\n * `string | null`).\n *\n * @param d A `Date` (or `null`) for conversion.\n * @param stringTypeTz The pg type corresponding to the desired string format\n * and (except for `timestamptz`) whether to express in UTC or local time. For\n * example: `\"timestamptz\"`, `\"timestamp:local\"` or `\"date:UTC\"`.\n */\nexport declare const toString: ToString;\nexport {};\n","node_modules/@types/zapatos/db/index.d.ts":"export * from './canary';\nexport * from './config';\nexport * from './core';\nexport * from './date';\nexport * from './pgErrors';\nexport * from './shortcuts';\nexport * from './transaction';\nexport * as conditions from './conditions';\n","node_modules/@types/zapatos/db/pgErrors.d.ts":"interface Error {\n    code?: string;\n}\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport declare function isDatabaseError(err: Error, ...types: (keyof typeof pgErrors)[]): boolean;\ndeclare const pgErrors: {\n    SuccessfulCompletion: string;\n    Warning: string;\n    NoData: string;\n    SqlStatementNotYetComplete: string;\n    ConnectionException: string;\n    TriggeredActionException: string;\n    FeatureNotSupported: string;\n    InvalidTransactionInitiation: string;\n    LocatorException: string;\n    InvalidGrantor: string;\n    InvalidRoleSpecification: string;\n    DiagnosticsException: string;\n    CaseNotFound: string;\n    CardinalityViolation: string;\n    DataException: string;\n    IntegrityConstraintViolation: string;\n    InvalidCursorState: string;\n    InvalidTransactionState: string;\n    InvalidSqlStatementName: string;\n    TriggeredDataChangeViolation: string;\n    InvalidAuthorizationSpecification: string;\n    DependentPrivilegeDescriptorsStillExist: string;\n    InvalidTransactionTermination: string;\n    SqlRoutineException: string;\n    InvalidCursorName: string;\n    ExternalRoutineException: string;\n    ExternalRoutineInvocationException: string;\n    SavepointException: string;\n    InvalidCatalogName: string;\n    InvalidSchemaName: string;\n    TransactionRollback: string;\n    SyntaxErrorOrAccessRuleViolation: string;\n    WithCheckOptionViolation: string;\n    InsufficientResources: string;\n    DiskFull: string;\n    OutOfMemory: string;\n    TooManyConnections: string;\n    ConfigurationLimitExceeded: string;\n    ProgramLimitExceeded: string;\n    ObjectNotInPrerequisiteState: string;\n    OperatorIntervention: string;\n    SystemError: string;\n    SnapshotTooOld: string;\n    ConfigFileError: string;\n    FdwError: string;\n    PlpgsqlError: string;\n    InternalError: string;\n    SuccessfulCompletion_SuccessfulCompletion: string;\n    Warning_Warning: string;\n    Warning_NullValueEliminatedInSetFunction: string;\n    Warning_StringDataRightTruncation: string;\n    Warning_PrivilegeNotRevoked: string;\n    Warning_PrivilegeNotGranted: string;\n    Warning_ImplicitZeroBitPadding: string;\n    Warning_DynamicResultSetsReturned: string;\n    Warning_DeprecatedFeature: string;\n    NoData_NoData: string;\n    NoData_NoAdditionalDynamicResultSetsReturned: string;\n    SqlStatementNotYetComplete_SqlStatementNotYetComplete: string;\n    ConnectionException_ConnectionException: string;\n    ConnectionException_SqlclientUnableToEstablishSqlconnection: string;\n    ConnectionException_ConnectionDoesNotExist: string;\n    ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: string;\n    ConnectionException_ConnectionFailure: string;\n    ConnectionException_TransactionResolutionUnknown: string;\n    ConnectionException_ProtocolViolation: string;\n    TriggeredActionException_TriggeredActionException: string;\n    FeatureNotSupported_FeatureNotSupported: string;\n    InvalidTransactionInitiation_InvalidTransactionInitiation: string;\n    LocatorException_LocatorException: string;\n    LocatorException_InvalidLocatorSpecification: string;\n    InvalidGrantor_InvalidGrantor: string;\n    InvalidGrantor_InvalidGrantOperation: string;\n    InvalidRoleSpecification_InvalidRoleSpecification: string;\n    DiagnosticsException_DiagnosticsException: string;\n    DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: string;\n    CaseNotFound_CaseNotFound: string;\n    CardinalityViolation_CardinalityViolation: string;\n    DataException_DataException: string;\n    DataException_StringDataRightTruncation: string;\n    DataException_NullValueNoIndicatorParameter: string;\n    DataException_NumericValueOutOfRange: string;\n    DataException_NullValueNotAllowed: string;\n    DataException_ErrorInAssignment: string;\n    DataException_InvalidDatetimeFormat: string;\n    DataException_DatetimeFieldOverflow: string;\n    DataException_InvalidTimeZoneDisplacementValue: string;\n    DataException_EscapeCharacterConflict: string;\n    DataException_InvalidUseOfEscapeCharacter: string;\n    DataException_InvalidEscapeOctet: string;\n    DataException_ZeroLengthCharacterString: string;\n    DataException_MostSpecificTypeMismatch: string;\n    DataException_SequenceGeneratorLimitExceeded: string;\n    DataException_NotAnXmlDocument: string;\n    DataException_InvalidXmlDocument: string;\n    DataException_InvalidXmlContent: string;\n    DataException_InvalidXmlComment: string;\n    DataException_InvalidXmlProcessingInstruction: string;\n    DataException_InvalidIndicatorParameterValue: string;\n    DataException_SubstringError: string;\n    DataException_DivisionByZero: string;\n    DataException_InvalidPrecedingOrFollowingSize: string;\n    DataException_InvalidArgumentForNtileFunction: string;\n    DataException_IntervalFieldOverflow: string;\n    DataException_InvalidArgumentForNthValueFunction: string;\n    DataException_InvalidCharacterValueForCast: string;\n    DataException_InvalidEscapeCharacter: string;\n    DataException_InvalidRegularExpression: string;\n    DataException_InvalidArgumentForLogarithm: string;\n    DataException_InvalidArgumentForPowerFunction: string;\n    DataException_InvalidArgumentForWidthBucketFunction: string;\n    DataException_InvalidRowCountInLimitClause: string;\n    DataException_InvalidRowCountInResultOffsetClause: string;\n    DataException_CharacterNotInRepertoire: string;\n    DataException_IndicatorOverflow: string;\n    DataException_InvalidParameterValue: string;\n    DataException_UnterminatedCString: string;\n    DataException_InvalidEscapeSequence: string;\n    DataException_StringDataLengthMismatch: string;\n    DataException_TrimError: string;\n    DataException_ArraySubscriptError: string;\n    DataException_InvalidTablesampleRepeat: string;\n    DataException_InvalidTablesampleArgument: string;\n    DataException_FloatingPointException: string;\n    DataException_InvalidTextRepresentation: string;\n    DataException_InvalidBinaryRepresentation: string;\n    DataException_BadCopyFileFormat: string;\n    DataException_UntranslatableCharacter: string;\n    DataException_NonstandardUseOfEscapeCharacter: string;\n    IntegrityConstraintViolation_IntegrityConstraintViolation: string;\n    IntegrityConstraintViolation_RestrictViolation: string;\n    IntegrityConstraintViolation_NotNullViolation: string;\n    IntegrityConstraintViolation_ForeignKeyViolation: string;\n    IntegrityConstraintViolation_UniqueViolation: string;\n    IntegrityConstraintViolation_CheckViolation: string;\n    IntegrityConstraintViolation_ExclusionViolation: string;\n    InvalidCursorState_InvalidCursorState: string;\n    InvalidTransactionState_InvalidTransactionState: string;\n    InvalidTransactionState_ActiveSqlTransaction: string;\n    InvalidTransactionState_BranchTransactionAlreadyActive: string;\n    InvalidTransactionState_InappropriateAccessModeForBranchTransaction: string;\n    InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: string;\n    InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: string;\n    InvalidTransactionState_ReadOnlySqlTransaction: string;\n    InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: string;\n    InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: string;\n    InvalidTransactionState_NoActiveSqlTransaction: string;\n    InvalidTransactionState_InFailedSqlTransaction: string;\n    InvalidTransactionState_IdleInTransactionSessionTimeout: string;\n    InvalidSqlStatementName_InvalidSqlStatementName: string;\n    TriggeredDataChangeViolation_TriggeredDataChangeViolation: string;\n    InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: string;\n    InvalidAuthorizationSpecification_InvalidPassword: string;\n    DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: string;\n    DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: string;\n    InvalidTransactionTermination_InvalidTransactionTermination: string;\n    SqlRoutineException_SqlRoutineException: string;\n    SqlRoutineException_ModifyingSqlDataNotPermitted: string;\n    SqlRoutineException_ProhibitedSqlStatementAttempted: string;\n    SqlRoutineException_ReadingSqlDataNotPermitted: string;\n    SqlRoutineException_FunctionExecutedNoReturnStatement: string;\n    InvalidCursorName_InvalidCursorName: string;\n    ExternalRoutineException_ExternalRoutineException: string;\n    ExternalRoutineException_ContainingSqlNotPermitted: string;\n    ExternalRoutineException_ModifyingSqlDataNotPermitted: string;\n    ExternalRoutineException_ProhibitedSqlStatementAttempted: string;\n    ExternalRoutineException_ReadingSqlDataNotPermitted: string;\n    ExternalRoutineInvocationException_ExternalRoutineInvocationException: string;\n    ExternalRoutineInvocationException_InvalidSqlstateReturned: string;\n    ExternalRoutineInvocationException_NullValueNotAllowed: string;\n    ExternalRoutineInvocationException_TriggerProtocolViolated: string;\n    ExternalRoutineInvocationException_SrfProtocolViolated: string;\n    ExternalRoutineInvocationException_EventTriggerProtocolViolated: string;\n    SavepointException_SavepointException: string;\n    SavepointException_InvalidSavepointSpecification: string;\n    InvalidCatalogName_InvalidCatalogName: string;\n    InvalidSchemaName_InvalidSchemaName: string;\n    TransactionRollback_TransactionRollback: string;\n    TransactionRollback_SerializationFailure: string;\n    TransactionRollback_TransactionIntegrityConstraintViolation: string;\n    TransactionRollback_StatementCompletionUnknown: string;\n    TransactionRollback_DeadlockDetected: string;\n    SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: string;\n    SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: string;\n    SyntaxErrorOrAccessRuleViolation_SyntaxError: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidName: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_NameTooLong: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateColumn: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedColumn: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedObject: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateObject: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateAlias: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateFunction: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: string;\n    SyntaxErrorOrAccessRuleViolation_GroupingError: string;\n    SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: string;\n    SyntaxErrorOrAccessRuleViolation_WrongObjectType: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: string;\n    SyntaxErrorOrAccessRuleViolation_CannotCoerce: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedFunction: string;\n    SyntaxErrorOrAccessRuleViolation_GeneratedAlways: string;\n    SyntaxErrorOrAccessRuleViolation_ReservedName: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedTable: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedParameter: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateCursor: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateSchema: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateTable: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidRecursion: string;\n    SyntaxErrorOrAccessRuleViolation_WindowingError: string;\n    SyntaxErrorOrAccessRuleViolation_CollationMismatch: string;\n    SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: string;\n    WithCheckOptionViolation_WithCheckOptionViolation: string;\n    InsufficientResources_InsufficientResources: string;\n    InsufficientResources_DiskFull: string;\n    InsufficientResources_OutOfMemory: string;\n    InsufficientResources_TooManyConnections: string;\n    InsufficientResources_ConfigurationLimitExceeded: string;\n    ProgramLimitExceeded_ProgramLimitExceeded: string;\n    ProgramLimitExceeded_StatementTooComplex: string;\n    ProgramLimitExceeded_TooManyColumns: string;\n    ProgramLimitExceeded_TooManyArguments: string;\n    ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: string;\n    ObjectNotInPrerequisiteState_ObjectInUse: string;\n    ObjectNotInPrerequisiteState_CantChangeRuntimeParam: string;\n    ObjectNotInPrerequisiteState_LockNotAvailable: string;\n    OperatorIntervention_OperatorIntervention: string;\n    OperatorIntervention_QueryCanceled: string;\n    OperatorIntervention_AdminShutdown: string;\n    OperatorIntervention_CrashShutdown: string;\n    OperatorIntervention_CannotConnectNow: string;\n    OperatorIntervention_DatabaseDropped: string;\n    SystemError_SystemError: string;\n    SystemError_IoError: string;\n    SystemError_UndefinedFile: string;\n    SystemError_DuplicateFile: string;\n    SnapshotTooOld_SnapshotTooOld: string;\n    ConfigFileError_ConfigFileError: string;\n    ConfigFileError_LockFileExists: string;\n    FdwError_FdwError: string;\n    FdwError_FdwOutOfMemory: string;\n    FdwError_FdwDynamicParameterValueNeeded: string;\n    FdwError_FdwInvalidDataType: string;\n    FdwError_FdwColumnNameNotFound: string;\n    FdwError_FdwInvalidDataTypeDescriptors: string;\n    FdwError_FdwInvalidColumnName: string;\n    FdwError_FdwInvalidColumnNumber: string;\n    FdwError_FdwInvalidUseOfNullPointer: string;\n    FdwError_FdwInvalidStringFormat: string;\n    FdwError_FdwInvalidHandle: string;\n    FdwError_FdwInvalidOptionIndex: string;\n    FdwError_FdwInvalidOptionName: string;\n    FdwError_FdwOptionNameNotFound: string;\n    FdwError_FdwReplyHandle: string;\n    FdwError_FdwUnableToCreateExecution: string;\n    FdwError_FdwUnableToCreateReply: string;\n    FdwError_FdwUnableToEstablishConnection: string;\n    FdwError_FdwNoSchemas: string;\n    FdwError_FdwSchemaNotFound: string;\n    FdwError_FdwTableNotFound: string;\n    FdwError_FdwFunctionSequenceError: string;\n    FdwError_FdwTooManyHandles: string;\n    FdwError_FdwInconsistentDescriptorInformation: string;\n    FdwError_FdwInvalidAttributeValue: string;\n    FdwError_FdwInvalidStringLengthOrBufferLength: string;\n    FdwError_FdwInvalidDescriptorFieldIdentifier: string;\n    PlpgsqlError_PlpgsqlError: string;\n    PlpgsqlError_RaiseException: string;\n    PlpgsqlError_NoDataFound: string;\n    PlpgsqlError_TooManyRows: string;\n    PlpgsqlError_AssertFailure: string;\n    InternalError_InternalError: string;\n    InternalError_DataCorrupted: string;\n    InternalError_IndexCorrupted: string;\n};\nexport {};\n","node_modules/@types/zapatos/db/shortcuts.d.ts":"import type { JSONSelectableForTable, WhereableForTable, InsertableForTable, UpdatableForTable, ColumnForTable, UniqueIndexForTable, SQLForTable, Table } from 'zapatos/schema';\nimport { AllType, SQLFragment } from './core';\nexport declare type JSONOnlyColsForTable<T extends Table, C extends any[]> = Pick<JSONSelectableForTable<T>, C[number]>;\nexport interface SQLFragmentMap {\n    [k: string]: SQLFragment<any>;\n}\nexport interface SQLFragmentOrColumnMap<T extends Table> {\n    [k: string]: SQLFragment<any> | ColumnForTable<T>;\n}\nexport declare type RunResultForSQLFragment<T extends SQLFragment<any, any>> = T extends SQLFragment<infer RunResult, any> ? RunResult : never;\nexport declare type LateralResult<L extends SQLFragmentMap> = {\n    [K in keyof L]: RunResultForSQLFragment<L[K]>;\n};\nexport declare type ExtrasResult<T extends Table, E extends SQLFragmentOrColumnMap<T>> = {\n    [K in keyof E]: E[K] extends SQLFragment<any> ? RunResultForSQLFragment<E[K]> : E[K] extends keyof JSONSelectableForTable<T> ? JSONSelectableForTable<T>[E[K]] : never;\n};\ndeclare type ExtrasOption<T extends Table> = SQLFragmentOrColumnMap<T> | undefined;\ndeclare type ColumnsOption<T extends Table> = ColumnForTable<T>[] | undefined;\ndeclare type LimitedLateralOption = SQLFragmentMap | undefined;\ndeclare type FullLateralOption = LimitedLateralOption | SQLFragment<any>;\ndeclare type LateralOption<C extends ColumnsOption<Table>, E extends ExtrasOption<Table>> = undefined extends C ? undefined extends E ? FullLateralOption : LimitedLateralOption : LimitedLateralOption;\nexport interface ReturningOptionsForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>> {\n    returning?: C;\n    extras?: E;\n}\ndeclare type ReturningTypeForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>> = (undefined extends C ? JSONSelectableForTable<T> : C extends ColumnForTable<T>[] ? JSONOnlyColsForTable<T, C> : never) & (undefined extends E ? {} : E extends SQLFragmentOrColumnMap<T> ? ExtrasResult<T, E> : never);\ninterface InsertSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: InsertableForTable<T>, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>>;\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: InsertableForTable<T>[], options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport declare const insert: InsertSignatures;\n/**\n * Wraps a unique index of the target table for use as the arbiter constraint\n * of an `upsert` shortcut query.\n */\nexport declare class Constraint<T extends Table> {\n    value: UniqueIndexForTable<T>;\n    constructor(value: UniqueIndexForTable<T>);\n}\n/**\n * Returns a `Constraint` instance, wrapping a unique index of the target table\n * for use as the arbiter constraint of an `upsert` shortcut query.\n */\nexport declare function constraint<T extends Table>(x: UniqueIndexForTable<T>): Constraint<T>;\nexport interface UpsertAction {\n    $action: 'INSERT' | 'UPDATE';\n}\ndeclare type UpsertReportAction = 'suppress';\ndeclare type UpsertReturnableForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, RA extends UpsertReportAction | undefined> = ReturningTypeForTable<T, C, E> & (undefined extends RA ? UpsertAction : {});\ndeclare type UpsertConflictTargetForTable<T extends Table> = Constraint<T> | ColumnForTable<T> | ColumnForTable<T>[];\ndeclare type UpdateColumns<T extends Table> = ColumnForTable<T> | ColumnForTable<T>[];\ninterface UpsertOptions<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined> extends ReturningOptionsForTable<T, C, E> {\n    updateValues?: UpdatableForTable<T>;\n    updateColumns?: UC;\n    noNullUpdateColumns?: ColumnForTable<T> | ColumnForTable<T>[];\n    reportAction?: RA;\n}\ninterface UpsertSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined>(table: T, values: InsertableForTable<T>, conflictTarget: UpsertConflictTargetForTable<T>, options?: UpsertOptions<T, C, E, UC, RA>): SQLFragment<UpsertReturnableForTable<T, C, E, RA> | (UC extends never[] ? undefined : never)>;\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined>(table: T, values: InsertableForTable<T>[], conflictTarget: UpsertConflictTargetForTable<T>, options?: UpsertOptions<T, C, E, UC, RA>): SQLFragment<UpsertReturnableForTable<T, C, E, RA>[]>;\n}\nexport declare const doNothing: never[];\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted\n * or updated\n * @param conflictTarget A `UNIQUE`-indexed column (or array thereof) or a\n * `UNIQUE` index (wrapped in `db.constraint(...)`) that determines whether we\n * get an `UPDATE` (when there's a matching existing value) or an `INSERT`\n * (when there isn't)\n * @param options Optionally, an object with any of the keys `updateColumns`,\n * `noNullUpdateColumns` and `updateValues` (see documentation).\n */\nexport declare const upsert: UpsertSignatures;\ninterface UpdateSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: UpdatableForTable<T>, where: WhereableForTable<T> | SQLFragment, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport declare const update: UpdateSignatures;\nexport interface DeleteSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, where: WhereableForTable<T> | SQLFragment, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `DELETE` query `SQLFragment` (plain 'delete' is a reserved word)\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport declare const deletes: DeleteSignatures;\ndeclare type TruncateIdentityOpts = 'CONTINUE IDENTITY' | 'RESTART IDENTITY';\ndeclare type TruncateForeignKeyOpts = 'RESTRICT' | 'CASCADE';\ninterface TruncateSignatures {\n    (table: Table | Table[]): SQLFragment<undefined>;\n    (table: Table | Table[], optId: TruncateIdentityOpts): SQLFragment<undefined>;\n    (table: Table | Table[], optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n    (table: Table | Table[], optId: TruncateIdentityOpts, optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n}\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or\n * 'RESTRICT'/'CASCADE'\n */\nexport declare const truncate: TruncateSignatures;\ninterface OrderSpecForTable<T extends Table> {\n    by: SQLForTable<T>;\n    direction: 'ASC' | 'DESC';\n    nulls?: 'FIRST' | 'LAST';\n}\nexport interface SelectLockingOptions {\n    for: 'UPDATE' | 'NO KEY UPDATE' | 'SHARE' | 'KEY SHARE';\n    of?: Table | Table[];\n    wait?: 'NOWAIT' | 'SKIP LOCKED';\n}\nexport interface SelectOptionsForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>> {\n    distinct?: boolean | ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n    order?: OrderSpecForTable<T> | OrderSpecForTable<T>[];\n    limit?: number;\n    offset?: number;\n    withTies?: boolean;\n    columns?: C;\n    extras?: E;\n    groupBy?: ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n    having?: WhereableForTable<T> | SQLFragment<any>;\n    lateral?: L;\n    alias?: string;\n    lock?: SelectLockingOptions | SelectLockingOptions[];\n}\ndeclare type SelectReturnTypeForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>> = (undefined extends L ? ReturningTypeForTable<T, C, E> : L extends SQLFragmentMap ? ReturningTypeForTable<T, C, E> & LateralResult<L> : L extends SQLFragment<any> ? RunResultForSQLFragment<L> : never);\nexport declare enum SelectResultMode {\n    Many = 0,\n    One = 1,\n    ExactlyOne = 2,\n    Numeric = 3\n}\nexport declare type FullSelectReturnTypeForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, M extends SelectResultMode> = {\n    [SelectResultMode.Many]: SelectReturnTypeForTable<T, C, L, E>[];\n    [SelectResultMode.ExactlyOne]: SelectReturnTypeForTable<T, C, L, E>;\n    [SelectResultMode.One]: SelectReturnTypeForTable<T, C, L, E> | undefined;\n    [SelectResultMode.Numeric]: number;\n}[M];\nexport interface SelectSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, M extends SelectResultMode = SelectResultMode.Many>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>, mode?: M, aggregate?: string): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, M>>;\n}\nexport declare class NotExactlyOneError extends Error {\n    query: SQLFragment;\n    constructor(query: SQLFragment, ...params: any[]);\n}\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other\n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. Keys (all optional) are:\n * * `columns`  an array of column names: only these columns will be returned\n * * `order`  an array of `OrderSpec` objects, such as\n * `{ by: 'column', direction: 'ASC' }`\n * * `limit` and `offset` numbers: apply this limit and offset to the query\n * * `lateral` either an object mapping keys to nested `select`/`selectOne`/\n * `count` queries to be `LATERAL JOIN`ed, or a single `select`/`selectOne`/\n * `count` query whose result will be passed through directly as the result of\n * the containing query\n * * `alias`  table alias (string): required if using `lateral` to join a table\n * to itself\n * * `extras` an object mapping key(s) to `SQLFragment`s, so that derived\n * quantities can be included in the JSON result\n * @param mode (Used internally by `selectOne` and `count`)\n */\nexport declare const select: SelectSignatures;\nexport interface SelectOneSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.One>>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or\n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with\n * other `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport declare const selectOne: SelectOneSignatures;\nexport interface SelectExactlyOneSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.ExactlyOne>>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a single result or\n * throws an error. A `LIMIT 1` clause is added automatically. This can be\n * nested with other `select`/`selectOne`/`count` queries using the `lateral`\n * option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport declare const selectExactlyOne: SelectExactlyOneSignatures;\nexport interface NumericAggregateSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>): SQLFragment<number>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be\n * nested in other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted,\n * or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const count: NumericAggregateSignatures;\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a sum. This can be\n * nested in other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to aggregate from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be\n * aggregated, or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const sum: NumericAggregateSignatures;\n/**\n * Generate a `SELECT` query `SQLFragment` that returns an arithmetic mean via\n * the `avg` aggregate function. This can be nested in other `select`/\n * `selectOne` queries using their `lateral` option.\n * @param table The table to aggregate from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be\n * aggregated, or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const avg: NumericAggregateSignatures;\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a minimum via the `min`\n * aggregate function. This can be nested in other `select`/`selectOne` queries\n * using their `lateral` option.\n * @param table The table to aggregate from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be\n * aggregated, or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const min: NumericAggregateSignatures;\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a maximum via the `max`\n * aggregate function. This can be nested in other `select`/`selectOne` queries\n * using their `lateral` option.\n * @param table The table to aggregate from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be\n * aggregated, or `all`\n * @param options Options object. Useful keys may be: `columns`, `alias`.\n */\nexport declare const max: NumericAggregateSignatures;\nexport {};\n","node_modules/@types/zapatos/db/transaction.d.ts":"import * as pg from 'pg';\nimport type { Queryable } from './core';\nexport declare enum IsolationLevel {\n    Serializable = \"SERIALIZABLE\",\n    RepeatableRead = \"REPEATABLE READ\",\n    ReadCommitted = \"READ COMMITTED\",\n    SerializableRO = \"SERIALIZABLE, READ ONLY\",\n    RepeatableReadRO = \"REPEATABLE READ, READ ONLY\",\n    ReadCommittedRO = \"READ COMMITTED, READ ONLY\",\n    SerializableRODeferrable = \"SERIALIZABLE, READ ONLY, DEFERRABLE\"\n}\nexport declare type IsolationSatisfying<T extends IsolationLevel> = {\n    [IsolationLevel.Serializable]: IsolationLevel.Serializable;\n    [IsolationLevel.RepeatableRead]: IsolationSatisfying<IsolationLevel.Serializable> | IsolationLevel.RepeatableRead;\n    [IsolationLevel.ReadCommitted]: IsolationSatisfying<IsolationLevel.RepeatableRead> | IsolationLevel.ReadCommitted;\n    [IsolationLevel.SerializableRO]: IsolationSatisfying<IsolationLevel.Serializable> | IsolationLevel.SerializableRO;\n    [IsolationLevel.RepeatableReadRO]: IsolationSatisfying<IsolationLevel.SerializableRO> | IsolationSatisfying<IsolationLevel.RepeatableRead> | IsolationLevel.RepeatableReadRO;\n    [IsolationLevel.ReadCommittedRO]: IsolationSatisfying<IsolationLevel.RepeatableReadRO> | IsolationSatisfying<IsolationLevel.ReadCommitted> | IsolationLevel.ReadCommittedRO;\n    [IsolationLevel.SerializableRODeferrable]: IsolationSatisfying<IsolationLevel.SerializableRO> | IsolationLevel.SerializableRODeferrable;\n}[T];\nexport interface TxnClient<T extends IsolationLevel> extends pg.PoolClient {\n    _zapatos?: {\n        isolationLevel: T;\n        txnId: number;\n    };\n}\nexport declare type TxnClientForSerializable = TxnClient<IsolationSatisfying<IsolationLevel.Serializable>>;\nexport declare type TxnClientForRepeatableRead = TxnClient<IsolationSatisfying<IsolationLevel.RepeatableRead>>;\nexport declare type TxnClientForReadCommitted = TxnClient<IsolationSatisfying<IsolationLevel.ReadCommitted>>;\nexport declare type TxnClientForSerializableRO = TxnClient<IsolationSatisfying<IsolationLevel.SerializableRO>>;\nexport declare type TxnClientForRepeatableReadRO = TxnClient<IsolationSatisfying<IsolationLevel.RepeatableReadRO>>;\nexport declare type TxnClientForReadCommittedRO = TxnClient<IsolationSatisfying<IsolationLevel.ReadCommittedRO>>;\nexport declare type TxnClientForSerializableRODeferrable = TxnClient<IsolationSatisfying<IsolationLevel.SerializableRODeferrable>>;\n/**\n * Provide a database client to the callback, whose queries are then wrapped in\n * a database transaction. The transaction is committed, retried, or rolled back\n * as appropriate.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param isolationLevel The desired isolation level (e.g.\n * `IsolationLevel.Serializable`)\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function transaction<T, M extends IsolationLevel>(txnClientOrQueryable: Queryable | TxnClient<IsolationSatisfying<M>>, isolationLevel: M, callback: (client: TxnClient<IsolationSatisfying<M>>) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `Serializable`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializable<T>(txnClientOrQueryable: Queryable | TxnClientForSerializable, callback: (client: TxnClientForSerializable) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `RepeatableRead`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function repeatableRead<T>(txnClientOrQueryable: Queryable | TxnClientForRepeatableRead, callback: (client: TxnClientForRepeatableRead) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `ReadCommitted`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function readCommitted<T>(txnClientOrQueryable: Queryable | TxnClientForReadCommitted, callback: (client: TxnClientForReadCommitted) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `SerializableRO`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializableRO<T>(txnClientOrQueryable: Queryable | TxnClientForSerializableRO, callback: (client: TxnClientForSerializableRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `RepeatableReadRO`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function repeatableReadRO<T>(txnClientOrQueryable: Queryable | TxnClientForRepeatableReadRO, callback: (client: TxnClientForRepeatableReadRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `ReadCommittedRO`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function readCommittedRO<T>(txnClientOrQueryable: Queryable | TxnClientForReadCommittedRO, callback: (client: TxnClientForReadCommittedRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `SerializableRODeferrable`.\n * @param txnClientOrQueryable The `pg.Pool` from which to check out a client,\n * a plain client, or an existing transaction client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializableRODeferrable<T>(txnClientOrQueryable: Queryable | TxnClientForSerializableRODeferrable, callback: (client: TxnClientForSerializableRODeferrable) => Promise<T>): Promise<T>;\n","node_modules/@types/zapatos/db/utils.d.ts":"export declare type NoInfer<T> = [T][T extends any ? 0 : never];\n/**\n * Basic zero-padding for small, positive integers\n * @param n The integer to pad\n * @param pad The minimum desired output string length: 2, 3 or 4\n */\nexport declare const pad: (n: number, pad?: 2 | 3 | 4) => string;\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport declare const wait: (delayMs: number) => Promise<unknown>;\n/**\n * Map an input array to an output array, interspersing a constant separator value\n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport declare const mapWithSeparator: <TIn, TSep, TOut>(arr: TIn[], separator: TSep, cb: (x: TIn, i: number, a: TIn[]) => TOut) => (TSep | TOut)[];\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets a default value.\n *\n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: defaultValue }, { x: defaultValue, y: 2}]`\n * @param objs The array of objects\n * @param defaultValue The default value to assign to missing keys for each object\n */\nexport declare const completeKeysWithDefaultValue: <T extends object>(objs: T[], defaultValue: any) => T[];\n/**\n * Test that a value is a Plain Old JavaScript Object (such as one created by an object\n * literal, e.g. `{x: 1, y: 2}`)\n * @param x The value to test\n */\nexport declare const isPOJO: (x: any) => boolean;\n","node_modules/@types/zapatos/generate/cli.d.ts":"#!/usr/bin/env node\nexport {};\n","node_modules/@types/zapatos/generate/config.d.ts":"import type * as pg from 'pg';\nexport interface RequiredConfig {\n    db: pg.ClientConfig;\n}\nexport interface OptionalConfig {\n    outDir: string;\n    outExt: string;\n    schemas: SchemaRules;\n    debugListener: boolean | ((s: string) => void);\n    progressListener: boolean | ((s: string) => void);\n    warningListener: boolean | ((s: string) => void);\n    customTypesTransform: 'PgMy_type' | 'my_type' | 'PgMyType' | ((s: string) => string);\n    columnOptions: ColumnOptions;\n    schemaJSDoc: boolean;\n    unprefixedSchema: string | null;\n}\ninterface SchemaRules {\n    [schema: string]: {\n        include: '*' | string[];\n        exclude: '*' | string[];\n    };\n}\ninterface ColumnOptions {\n    [k: string]: {\n        [k: string]: {\n            insert?: 'auto' | 'excluded' | 'optional';\n            update?: 'auto' | 'excluded';\n        };\n    };\n}\nexport declare type Config = RequiredConfig & Partial<OptionalConfig>;\nexport declare type CompleteConfig = RequiredConfig & OptionalConfig;\nexport declare const moduleRoot: () => string;\nexport declare const finaliseConfig: (config: Config) => CompleteConfig;\nexport {};\n","node_modules/@types/zapatos/generate/enums.d.ts":"import * as pg from 'pg';\nexport declare type EnumData = {\n    [k: string]: string[];\n};\nexport declare const enumDataForSchema: (schemaName: string, queryFn: (q: pg.QueryConfig) => Promise<pg.QueryResult<any>>) => Promise<EnumData>;\nexport declare const enumTypesForEnumData: (enums: EnumData) => string;\n","node_modules/@types/zapatos/generate/header.d.ts":"export declare const header: () => string;\n","node_modules/@types/zapatos/generate/index.d.ts":"export * from './config';\nexport * from './enums';\nexport * from './pgTypes';\nexport * from './tables';\nexport * from './tsOutput';\nexport * from './write';\n","node_modules/@types/zapatos/generate/legacy.d.ts":"import { CompleteConfig } from \"./config\";\nexport declare function srcWarning(config: CompleteConfig): void;\n","node_modules/@types/zapatos/generate/pgTypes.d.ts":"import type { EnumData } from './enums';\ndeclare type TypeContext = 'JSONSelectable' | 'Selectable' | 'Insertable' | 'Updatable' | 'Whereable';\nexport declare const tsTypeForPgType: (pgType: string, enums: EnumData, context: TypeContext) => string;\nexport {};\n","node_modules/@types/zapatos/generate/tables.d.ts":"import * as pg from 'pg';\nimport type { EnumData } from './enums';\nimport type { CustomTypes } from './tsOutput';\nimport { CompleteConfig } from './config';\nexport interface Relation {\n    schema: string;\n    name: string;\n    type: 'table' | 'view' | 'fdw' | 'mview';\n    insertable: boolean;\n}\nexport declare const relationsInSchema: (schemaName: string, queryFn: (q: pg.QueryConfig) => Promise<pg.QueryResult<any>>) => Promise<Relation[]>;\nexport declare const definitionForRelationInSchema: (rel: Relation, schemaName: string, enums: EnumData, customTypes: CustomTypes, config: CompleteConfig, queryFn: (q: pg.QueryConfig) => Promise<pg.QueryResult<any>>) => Promise<string>;\nexport declare const crossTableTypesForTables: (tables: Relation[]) => string;\nexport declare const crossSchemaTypesForAllTables: (allTables: Relation[], unprefixedSchema: string | null) => string;\nexport declare const crossSchemaTypesForSchemas: (schemas: string[]) => string;\n","node_modules/@types/zapatos/generate/tsOutput.d.ts":"import type { CompleteConfig } from './config';\nexport interface CustomTypes {\n    [name: string]: string;\n}\nexport declare const tsForConfig: (config: CompleteConfig, debug: (s: string) => void) => Promise<{\n    ts: string;\n    customTypeSourceFiles: {\n        [k: string]: string;\n    };\n}>;\n","node_modules/@types/zapatos/generate/write.d.ts":"import { Config } from './config';\n/**\n * Generate a schema and supporting files and folders given a configuration.\n * @param suppliedConfig An object approximately matching `zapatosconfig.json`.\n */\nexport declare const generate: (suppliedConfig: Config) => Promise<void>;\n","node_modules/@types/zapatos/typings/zapatos/schema.d.ts":"export interface Updatable {\n    [k: string]: any;\n}\nexport interface Whereable {\n    [k: string]: any;\n}\nexport interface Insertable {\n    [k: string]: any;\n}\nexport declare type Table = string;\nexport declare type Column = string;\nexport declare type JSONSelectableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type SelectableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type WhereableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type InsertableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type UpdatableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type ColumnForTable<T extends Table> = string;\nexport declare type UniqueIndexForTable<T extends Table> = string;\nexport declare type SQLForTable<T extends Table> = any;\n","node_modules/@types/pg/index.d.ts":"// Type definitions for pg 8.6\n// Project: https://github.com/brianc/node-postgres\n// Definitions by: Phips Peter <https://github.com/pspeter3>, Ravi van Rooijen <https://github.com/HoldYourWaffle>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n/// <reference types=\"node\" />\n\nimport events = require('events');\nimport stream = require('stream');\nimport pgTypes = require('pg-types');\nimport { NoticeMessage } from 'pg-protocol/dist/messages';\n\nimport { ConnectionOptions } from 'tls';\n\nexport interface ClientConfig {\n    user?: string | undefined;\n    database?: string | undefined;\n    password?: string | (() => string | Promise<string>) | undefined;\n    port?: number | undefined;\n    host?: string | undefined;\n    connectionString?: string | undefined;\n    keepAlive?: boolean | undefined;\n    stream?: stream.Duplex | undefined;\n    statement_timeout?: false | number | undefined;\n    parseInputDatesAsUTC?: boolean | undefined;\n    ssl?: boolean | ConnectionOptions | undefined;\n    query_timeout?: number | undefined;\n    keepAliveInitialDelayMillis?: number | undefined;\n    idle_in_transaction_session_timeout?: number | undefined;\n    application_name?: string | undefined;\n    connectionTimeoutMillis?: number | undefined;\n    types?: CustomTypesConfig | undefined;\n    options?: string | undefined;\n}\n\nexport type ConnectionConfig = ClientConfig;\n\nexport interface Defaults extends ClientConfig {\n    poolSize?: number | undefined;\n    poolIdleTimeout?: number | undefined;\n    reapIntervalMillis?: number | undefined;\n    binary?: boolean | undefined;\n    parseInt8?: boolean | undefined;\n}\n\nexport interface PoolConfig extends ClientConfig {\n    // properties from module 'node-pool'\n    max?: number | undefined;\n    min?: number | undefined;\n    idleTimeoutMillis?: number | undefined;\n    log?: ((...messages: any[]) => void) | undefined;\n    Promise?: PromiseConstructorLike | undefined;\n    allowExitOnIdle?: boolean | undefined;\n    maxUses?: number | undefined;\n}\n\nexport interface QueryConfig<I extends any[] = any[]> {\n    name?: string | undefined;\n    text: string;\n    values?: I | undefined;\n    types?: CustomTypesConfig | undefined;\n}\n\nexport interface CustomTypesConfig {\n    getTypeParser: typeof pgTypes.getTypeParser;\n}\n\nexport interface Submittable {\n    submit: (connection: Connection) => void;\n}\n\nexport interface QueryArrayConfig<I extends any[] = any[]> extends QueryConfig<I> {\n    rowMode: 'array';\n}\n\nexport interface FieldDef {\n    name: string;\n    tableID: number;\n    columnID: number;\n    dataTypeID: number;\n    dataTypeSize: number;\n    dataTypeModifier: number;\n    format: string;\n}\n\nexport interface QueryResultBase {\n    command: string;\n    rowCount: number;\n    oid: number;\n    fields: FieldDef[];\n}\n\nexport interface QueryResultRow {\n    [column: string]: any;\n}\n\nexport interface QueryResult<R extends QueryResultRow = any> extends QueryResultBase {\n    rows: R[];\n}\n\nexport interface QueryArrayResult<R extends any[] = any[]> extends QueryResultBase {\n    rows: R[];\n}\n\nexport interface Notification {\n    processId: number;\n    channel: string;\n    payload?: string | undefined;\n}\n\nexport interface ResultBuilder<R extends QueryResultRow = any> extends QueryResult<R> {\n    addRow(row: R): void;\n}\n\nexport interface QueryParse {\n    name: string;\n    text: string;\n    types: string[];\n}\n\nexport interface BindConfig {\n    portal?: string | undefined;\n    statement?: string | undefined;\n    binary?: string | undefined;\n    values?: Array<Buffer | null | undefined | string> | undefined;\n}\n\nexport interface ExecuteConfig {\n    portal?: string | undefined;\n    rows?: string | undefined;\n}\n\nexport interface MessageConfig {\n    type: string;\n    name?: string | undefined;\n}\n\nexport class Connection extends events.EventEmitter {\n    readonly stream: stream.Duplex;\n\n    constructor(config?: ConnectionConfig);\n\n    bind(config: BindConfig | null, more: boolean): void;\n    execute(config: ExecuteConfig | null, more: boolean): void;\n    parse(query: QueryParse, more: boolean): void;\n\n    query(text: string): void;\n\n    describe(msg: MessageConfig, more: boolean): void;\n    close(msg: MessageConfig, more: boolean): void;\n\n    flush(): void;\n    sync(): void;\n    end(): void;\n}\n\n/**\n * {@link https://node-postgres.com/api/pool}\n */\nexport class Pool extends events.EventEmitter {\n    /**\n     * Every field of the config object is entirely optional.\n     * The config passed to the pool is also passed to every client\n     * instance within the pool when the pool creates that client.\n     */\n    constructor(config?: PoolConfig);\n\n    readonly totalCount: number;\n    readonly idleCount: number;\n    readonly waitingCount: number;\n\n    connect(): Promise<PoolClient>;\n    connect(callback: (err: Error, client: PoolClient, done: (release?: any) => void) => void): void;\n\n    end(): Promise<void>;\n    end(callback: () => void): void;\n\n    query<T extends Submittable>(queryStream: T): T;\n    // tslint:disable:no-unnecessary-generics\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        values?: I,\n    ): Promise<QueryArrayResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryConfig: QueryConfig<I>,\n    ): Promise<QueryResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: I,\n    ): Promise<QueryResult<R>>;\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        callback: (err: Error, result: QueryArrayResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryText: string,\n        values: I,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    // tslint:enable:no-unnecessary-generics\n\n    on(event: 'error', listener: (err: Error, client: PoolClient) => void): this;\n    on(event: 'connect' | 'acquire' | 'remove', listener: (client: PoolClient) => void): this;\n}\n\nexport class ClientBase extends events.EventEmitter {\n    constructor(config?: string | ClientConfig);\n\n    connect(): Promise<void>;\n    connect(callback: (err: Error) => void): void;\n\n    query<T extends Submittable>(queryStream: T): T;\n    // tslint:disable:no-unnecessary-generics\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        values?: I,\n    ): Promise<QueryArrayResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryConfig: QueryConfig<I>,\n    ): Promise<QueryResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: I,\n    ): Promise<QueryResult<R>>;\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        callback: (err: Error, result: QueryArrayResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryText: string,\n        values: any[],\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    // tslint:enable:no-unnecessary-generics\n\n    copyFrom(queryText: string): stream.Writable;\n    copyTo(queryText: string): stream.Readable;\n\n    pauseDrain(): void;\n    resumeDrain(): void;\n\n    escapeIdentifier(str: string): string;\n    escapeLiteral(str: string): string;\n\n    on(event: 'drain', listener: () => void): this;\n    on(event: 'error', listener: (err: Error) => void): this;\n    on(event: 'notice', listener: (notice: NoticeMessage) => void): this;\n    on(event: 'notification', listener: (message: Notification) => void): this;\n    // tslint:disable-next-line unified-signatures\n    on(event: 'end', listener: () => void): this;\n}\n\nexport class Client extends ClientBase {\n    user?: string | undefined;\n    database?: string | undefined;\n    port: number;\n    host: string;\n    password?: string | undefined;\n    ssl: boolean;\n\n    constructor(config?: string | ClientConfig);\n\n    end(): Promise<void>;\n    end(callback: (err: Error) => void): void;\n}\n\nexport interface PoolClient extends ClientBase {\n    release(err?: Error | boolean): void;\n}\n\nexport class Query<R extends QueryResultRow = any, I extends any[] = any> extends events.EventEmitter\n    implements Submittable {\n    constructor(queryTextOrConfig?: string | QueryConfig<I>, values?: I);\n    submit: (connection: Connection) => void;\n    on(event: 'row', listener: (row: R, result?: ResultBuilder<R>) => void): this;\n    on(event: 'error', listener: (err: Error) => void): this;\n    on(event: 'end', listener: (result: ResultBuilder<R>) => void): this;\n}\n\nexport class Events extends events.EventEmitter {\n    on(event: 'error', listener: (err: Error, client: Client) => void): this;\n}\n\nexport const types: typeof pgTypes;\n\nexport const defaults: Defaults & ClientConfig;\n\nimport * as Pg from '.';\n\nexport const native: typeof Pg | null;\n\nexport { DatabaseError } from 'pg-protocol';\n","node_modules/@types/pg/lib/type-overrides.d.ts":"import { CustomTypesConfig } from '..';\n\ntype TypeParser<TOid = number, TReturn = any> = (oid: TOid) => TReturn;\ntype TypeFormat = 'text' | 'binary';\n\nexport = TypeOverrides;\ndeclare class TypeOverrides implements CustomTypesConfig {\n    constructor(types?: CustomTypesConfig);\n    setTypeParser(oid: number, format: TypeFormat, fn: TypeParser): void;\n    setTypeParser(oid: number, fn: TypeParser): void;\n    getTypeParser(oid: number, format?: TypeFormat): TypeParser;\n}\n","node_modules/@types/luxon/index.d.ts":"// Type definitions for luxon 2.3\n// Project: https://github.com/moment/luxon#readme\n// Definitions by: Colby DeHart <https://github.com/colbydehart>\n//                 Hyeonseok Yang <https://github.com/FourwingsY>\n//                 Jonathan Siebern <https://github.com/jsiebern>\n//                 Matt R. Wilson <https://github.com/mastermatt>\n//                 Pietro Vismara <https://github.com/pietrovismara>\n//                 Janeene Beeforth <https://github.com/dawnmist>\n//                 Jason Yu <https://github.com/ycmjason>\n//                 Aitor Prez Rodal <https://github.com/Aitor1995>\n//                 Piotr Baejewicz <https://github.com/peterblazejewicz>\n//                 Carson Full <https://github.com/carsonf>\n//                 Hugo Silva <https://github.com/hugofpsilva>\n//                 Martin Badin <https://github.com/martin-badin>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\nexport * from './src/luxon';\n\nexport as namespace luxon;\n","node_modules/@types/luxon/src/datetime.d.ts":"import {\n    CalendarSystem,\n    DateTimeFormatOptions,\n    NumberingSystem,\n    StringUnitLength,\n    ToISOFormat,\n    ToISOTimeDurationOptions,\n    ZoneOptions,\n} from '../index';\nimport { Zone } from './zone';\nimport { Duration, DurationLike, DurationUnits } from './duration';\nimport { Interval } from './interval';\n\nexport type DateTimeUnit = 'year' | 'quarter' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';\nexport type ToRelativeUnit = 'years' | 'quarters' | 'months' | 'weeks' | 'days' | 'hours' | 'minutes' | 'seconds';\n\nexport type MonthNumbers = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\nexport type WeekdayNumbers = 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\nexport type DayNumbers =\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20\n    | 21\n    | 22\n    | 23\n    | 24\n    | 25\n    | 26\n    | 27\n    | 28\n    | 29\n    | 30\n    | 31;\n\nexport type SecondNumbers =\n    | 0\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20\n    | 21\n    | 22\n    | 23\n    | 24\n    | 25\n    | 26\n    | 27\n    | 28\n    | 29\n    | 30\n    | 31\n    | 32\n    | 33\n    | 34\n    | 35\n    | 36\n    | 37\n    | 38\n    | 39\n    | 40\n    | 41\n    | 42\n    | 43\n    | 44\n    | 45\n    | 46\n    | 47\n    | 48\n    | 49\n    | 50\n    | 51\n    | 52\n    | 53\n    | 54\n    | 55\n    | 56\n    | 57\n    | 58\n    | 59;\n\nexport type MinuteNumbers = SecondNumbers;\n\nexport type HourNumbers =\n    | 0\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20\n    | 21\n    | 22\n    | 23;\n\nexport type WeekNumbers =\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20\n    | 21\n    | 22\n    | 23\n    | 24\n    | 25\n    | 26\n    | 27\n    | 28\n    | 29\n    | 30\n    | 31\n    | 32\n    | 33\n    | 34\n    | 35\n    | 36\n    | 37\n    | 38\n    | 39\n    | 40\n    | 41\n    | 42\n    | 43\n    | 44\n    | 45\n    | 46\n    | 47\n    | 48\n    | 49\n    | 50\n    | 51\n    | 52\n    | 53;\n\nexport type QuarterNumbers = 1 | 2 | 3 | 4;\n\nexport type PossibleDaysInMonth = 28 | 29 | 30 | 31;\nexport type PossibleDaysInYear = 365 | 366;\nexport type PossibleWeeksInYear = 52 | 53;\n\nexport interface ToObjectOutput extends DateTimeJSOptions {\n    year: number;\n    month: number;\n    day: number;\n    hour: number;\n    minute: number;\n    second: number;\n    millisecond: number;\n}\n\nexport interface ToRelativeOptions extends Omit<ToRelativeCalendarOptions, 'unit'> {\n    /**\n     * @default long\n     */\n    style?: StringUnitLength | undefined;\n    /** @default true */\n    round?: boolean | undefined;\n    /**\n     * Padding in milliseconds. This allows you to round up the result if it fits inside the threshold.\n     * Don't use in combination with {round: false} because the decimal output will include the padding.\n     * @default 0\n     */\n    padding?: number | undefined;\n    /**\n     * A single unit or an array of units. If an array is supplied, the method will pick the best one\n     * to use from the array. If omitted, the method will pick the unit from a default set.\n     */\n    unit?: ToRelativeUnit | ToRelativeUnit[] | undefined;\n}\n\nexport interface ToRelativeCalendarOptions {\n    /**\n     * The DateTime to use as the basis to which this time is compared\n     * @default now\n     */\n    base?: DateTime | undefined;\n    /**\n     * Override the locale of this DateTime\n     */\n    locale?: string | undefined;\n    /** If omitted, the method will pick the unit. */\n    unit?: ToRelativeUnit | undefined;\n    /**\n     * Override the numberingSystem of this DateTime.\n     * The Intl system may choose not to honor this.\n     */\n    numberingSystem?: NumberingSystem | undefined;\n}\n\nexport interface ToSQLOptions {\n    /**\n     * Include the offset, such as 'Z' or '-04:00'\n     * @default true\n     */\n    includeOffset?: boolean | undefined;\n    /**\n     * Include the zone, such as 'America/New_York'. Overrides includeOffset.\n     * @default false\n     */\n    includeZone?: boolean | undefined;\n}\n\nexport interface ToISODateOptions {\n    /**\n     * Choose between the basic and extended format\n     * @default 'extended'\n     */\n    format?: ToISOFormat | undefined;\n}\n\nexport interface ToISOTimeOptions extends ToISOTimeDurationOptions {\n    /**\n     * Include the offset, such as 'Z' or '-04:00'\n     * @default true\n     */\n    includeOffset?: boolean | undefined;\n}\n\n/** @deprecated alias for backwards compatibility */\nexport type ISOTimeOptions = ToISOTimeOptions;\n\nexport interface LocaleOptions {\n    /**\n     * @default system's locale\n     */\n    locale?: string | undefined;\n    outputCalendar?: CalendarSystem | undefined;\n    numberingSystem?: NumberingSystem | undefined;\n}\n\nexport type ResolvedLocaleOptions = Required<LocaleOptions>;\n\nexport interface DateTimeOptions extends LocaleOptions {\n    /**\n     * Use this zone if no offset is specified in the input string itself. Will also convert the time to this zone.\n     * @default local\n     */\n    zone?: string | Zone | undefined;\n    /**\n     * Override the zone with a fixed-offset zone specified in the string itself, if it specifies one.\n     * @default false\n     */\n    setZone?: boolean | undefined;\n}\n\nexport type DateTimeJSOptions = Omit<DateTimeOptions, 'setZone'>;\n\nexport interface DateObjectUnits {\n    // a year, such as 1987\n    year?: number | undefined;\n    // a month, 1-12\n    month?: number | undefined;\n    // a day of the month, 1-31, depending on the month\n    day?: number | undefined;\n    // day of the year, 1-365 or 366\n    ordinal?: number | undefined;\n    // an ISO week year\n    weekYear?: number | undefined;\n    // an ISO week number, between 1 and 52 or 53, depending on the year\n    weekNumber?: number | undefined;\n    // an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n    weekday?: number | undefined;\n    // hour of the day, 0-23\n    hour?: number | undefined;\n    // minute of the hour, 0-59\n    minute?: number | undefined;\n    // second of the minute, 0-59\n    second?: number | undefined;\n    // millisecond of the second, 0-999\n    millisecond?: number | undefined;\n}\n\nexport type ConversionAccuracy = 'casual' | 'longterm';\n\n/**\n * @deprecated You should use Intl.DateTimeFormatOptions' fields and values instead.\n */\nexport type DateTimeFormatPresetValue = 'numeric' | 'short' | 'long';\n/**\n * @deprecated Use Intl.DateTimeFormatOptions instead.\n */\nexport type DateTimeFormatPreset = Intl.DateTimeFormatOptions;\n\nexport interface DiffOptions {\n    conversionAccuracy?: ConversionAccuracy | undefined;\n}\n\nexport interface ExplainedFormat {\n    input: string;\n    tokens: Array<{ literal: boolean; val: string }>;\n    regex?: RegExp | undefined;\n    rawMatches?: RegExpMatchArray | null | undefined;\n    matches?: { [k: string]: any } | undefined;\n    result?: { [k: string]: any } | null | undefined;\n    zone?: Zone | null | undefined;\n    invalidReason?: string | undefined;\n}\n\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods.\n * It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}.\n * To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}.\n * To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year},\n * {@link DateTime#month}, {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.\n * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale},\n * {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO},\n * {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat},\n * {@link DateTime#toMillis} and {@link DateTime#toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics\n * like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */\nexport class DateTime {\n    /**\n     * Create a DateTime for the current instant, in the system's time zone.\n     *\n     * Use Settings to override these default values if needed.\n     * @example\n     * DateTime.now().toISO() //~> now in the ISO format\n     */\n    static now(): DateTime;\n\n    /**\n     * Create a local DateTime\n     *\n     * @param year - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\n     * @param month - The month, 1-indexed\n     * @param day - The day of the month, 1-indexed\n     * @param hour - The hour of the day, in 24-hour time\n     * @param minute - The minute of the hour, meaning a number between 0 and 59\n     * @param second - The second of the minute, meaning a number between 0 and 59\n     * @param millisecond - The millisecond of the second, meaning a number between 0 and 999\n     *\n     * @example\n     * DateTime.local()                                  //~> now\n     * @example\n     * DateTime.local({ zone: \"America/New_York\" })      //~> now, in US east coast time\n     * @example\n     * DateTime.local(2017)                              //~> 2017-01-01T00:00:00\n     * @example\n     * DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00\n     * @example\n     * DateTime.local(2017, 3, 12, { locale: \"fr\")       //~> 2017-03-12T00:00:00, with a French locale\n     * @example\n     * DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00\n     * @example\n     * DateTime.local(2017, 3, 12, 5, { zone: \"utc\" })   //~> 2017-03-12T05:00:00, in UTC\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765\n     */\n    static local(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        second: number,\n        millisecond: number,\n        opts?: DateTimeJSOptions,\n    ): DateTime;\n    static local(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        second: number,\n        opts?: DateTimeJSOptions,\n    ): DateTime;\n    static local(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        opts?: DateTimeJSOptions,\n    ): DateTime;\n    static local(year: number, month: number, day: number, hour: number, opts?: DateTimeJSOptions): DateTime;\n    static local(year: number, month: number, day: number, opts?: DateTimeJSOptions): DateTime;\n    static local(year: number, month: number, opts?: DateTimeJSOptions): DateTime;\n    static local(year: number, opts?: DateTimeJSOptions): DateTime;\n    static local(opts?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime in UTC\n     *\n     * @param year - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\n     * @param month - The month, 1-indexed\n     * @param day - The day of the month\n     * @param hour - The hour of the day, in 24-hour time\n     * @param minute - The minute of the hour, meaning a number between 0 and 59\n     * @param second - The second of the minute, meaning a number between 0 and 59\n     * @param millisecond - The millisecond of the second, meaning a number between 0 and 999\n     * @param options - configuration options for the DateTime\n     * @param options.locale - a locale to set on the resulting DateTime instance\n     * @param options.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param options.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.utc()                                            //~> now\n     * @example\n     * DateTime.utc(2017)                                        //~> 2017-01-01T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3)                                     //~> 2017-03-01T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12)                                 //~> 2017-03-12T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5)                              //~> 2017-03-12T05:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45)                          //~> 2017-03-12T05:45:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45, { locale: \"fr\" } )       //~> 2017-03-12T05:45:00Z with a French locale\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45, 10)                      //~> 2017-03-12T05:45:10Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: \"fr\") //~> 2017-03-12T05:45:10.765Z with a French locale\n     */\n    static utc(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        second: number,\n        millisecond: number,\n        options?: LocaleOptions,\n    ): DateTime;\n    static utc(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        second: number,\n        options?: LocaleOptions,\n    ): DateTime;\n    static utc(\n        year: number,\n        month: number,\n        day: number,\n        hour: number,\n        minute: number,\n        options?: LocaleOptions,\n    ): DateTime;\n    static utc(year: number, month: number, day: number, hour: number, options?: LocaleOptions): DateTime;\n    static utc(year: number, month: number, day: number, options?: LocaleOptions): DateTime;\n    static utc(year: number, month: number, options?: LocaleOptions): DateTime;\n    static utc(year: number, options?: LocaleOptions): DateTime;\n    static utc(options?: LocaleOptions): DateTime;\n\n    /**\n     * Create a DateTime from a JavaScript Date object. Uses the default zone.\n     *\n     * @param date - a JavaScript Date object\n     * @param options - configuration options for the DateTime\n     * @param options.zone - the zone to place the DateTime into\n     */\n    static fromJSDate(date: Date, options?: { zone?: string | Zone }): DateTime;\n\n    /**\n     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n     *\n     * @param milliseconds - a number of milliseconds since 1970 UTC\n     * @param options - configuration options for the DateTime\n     * @param options.zone - the zone to place the DateTime into. Defaults to 'local'.\n     * @param options.locale - a locale to set on the resulting DateTime instance\n     * @param options.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param options.numberingSystem - the numbering system to set on the resulting DateTime instance\n     */\n    static fromMillis(milliseconds: number, options?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n     *\n     * @param seconds - a number of seconds since 1970 UTC\n     * @param options - configuration options for the DateTime\n     * @param options.zone - the zone to place the DateTime into. Defaults to 'local'.\n     * @param options.locale - a locale to set on the resulting DateTime instance\n     * @param options.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param options.numberingSystem - the numbering system to set on the resulting DateTime instance\n     */\n    static fromSeconds(seconds: number, options?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n     *\n     * @param obj - the object to create the DateTime from\n     * @param obj.year - a year, such as 1987\n     * @param obj.month - a month, 1-12\n     * @param obj.day - a day of the month, 1-31, depending on the month\n     * @param obj.ordinal - day of the year, 1-365 or 366\n     * @param obj.weekYear - an ISO week year\n     * @param obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\n     * @param obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n     * @param obj.hour - hour of the day, 0-23\n     * @param obj.minute - minute of the hour, 0-59\n     * @param obj.second - second of the minute, 0-59\n     * @param obj.millisecond - millisecond of the second, 0-999\n     * @param opts - options for creating this DateTime\n     * @param opts.zone - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone(). Defaults to 'local'.\n     * @param opts.locale - a locale to set on the resulting DateTime instance. Defaults to 'system's locale'.\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n     * @example\n     * DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { }zone: 'America/New_York' })\n     * @example\n     * DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n     */\n    static fromObject(obj: DateObjectUnits, opts?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime from an ISO 8601 string\n     *\n     * @param text - the ISO string\n     * @param opts - options to affect the creation\n     * @param opts.zone - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone. Defaults to 'local'.\n     * @param opts.setZone - override the zone with a fixed-offset zone specified in the string itself, if it specifies one. Defaults to false.\n     * @param opts.locale - a locale to set on the resulting DateTime instance. Defaults to 'system's locale'.\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123')\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n     * @example\n     * DateTime.fromISO('2016-W05-4')\n     */\n    static fromISO(text: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from an RFC 2822 string\n     *\n     * @param text - the RFC 2822 string\n     * @param opts - options to affect the creation\n     * @param opts.zone - convert the time to this zone. Since the offset is always specified in the string itself,\n     * this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in. Defaults to 'local'\n     * @param opts.setZone - override the zone with a fixed-offset zone specified in the string itself, if it specifies one. Defaults to false.\n     * @param opts.locale - a locale to set on the resulting DateTime instance. Defaults to 'system's locale'.\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n     * @example\n     * DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n     * @example\n     * DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n     */\n    static fromRFC2822(text: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from an HTTP header date\n     *\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n     *\n     * @param text - the HTTP header date\n     * @param opts - options to affect the creation\n     * @param opts.zone - convert the time to this zone. Since HTTP dates are always in UTC,\n     * this has no effect on the interpretation of string,merely the zone the resulting DateTime is expressed in. Defaults to 'local'.\n     * @param opts.setZone - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC,\n     * so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods. Defaults to false.\n     * @param opts.locale - a locale to set on the resulting DateTime instance. Defaults to 'system's locale'.\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     * @param opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n     * @example\n     * DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n     * @example\n     * DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n     */\n    static fromHTTP(text: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from an input string and format string.\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations,\n     * see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).\n     *\n     * @param text - the string to parse\n     * @param fmt - the format the string is expected to be in (see the link below for the formats)\n     * @param opts - options to affect the creation\n     * @param opts.zone - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone. Defaults to 'local'.\n     * @param opts.setZone - override the zone with a zone specified in the string itself, if it specifies one. Defaults to false.\n     * @param opts.locale - a locale string to use when parsing. Will also set the DateTime to this locale. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     */\n    static fromFormat(text: string, fmt: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * @deprecated use fromFormat instead\n     */\n    static fromString(text: string, format: string, options?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from a SQL date, time, or datetime\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale\n     *\n     * @param text - the string to parse\n     * @param opts - options to affect the creation\n     * @param opts.zone - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone. Defaults to 'local'.\n     * @param opts.setZone - override the zone with a zone specified in the string itself, if it specifies one. Defaults to false.\n     * @param opts.locale - a locale string to use when parsing. Will also set the DateTime to this locale. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n     * @param opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n     *\n     * @example\n     * DateTime.fromSQL('2017-05-15')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n     * @example\n     * DateTime.fromSQL('09:12:34.342')\n     */\n    static fromSQL(text: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Create an invalid DateTime.\n     *\n     * @param reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent\n     * @param explanation - longer explanation, may include parameters and other useful debugging information. Defaults to null.\n     */\n    static invalid(reason: string, explanation?: string): DateTime;\n\n    /**\n     * Check if an object is a DateTime. Works across context boundaries\n     *\n     * @param o\n     */\n    static isDateTime(o: unknown): o is DateTime;\n\n    // INFO\n\n    /**\n     * Get the value of unit.\n     *\n     * @param unit - a unit such as 'minute' or 'day'\n     *\n     * @example\n     * DateTime.local(2017, 7, 4).get('month'); //=> 7\n     * @example\n     * DateTime.local(2017, 7, 4).get('day'); //=> 4\n     */\n    get(unit: keyof DateTime): number;\n\n    /**\n     * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n     * * The DateTime was created by an operation on another invalid date\n     */\n    get isValid(): boolean;\n\n    /**\n     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n     */\n    get invalidReason(): string | null;\n\n    /**\n     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n     */\n    get invalidExplanation(): string | null;\n\n    /**\n     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\n     */\n    get locale(): string;\n\n    /**\n     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\n     */\n    get numberingSystem(): string;\n\n    /**\n     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\n     */\n    get outputCalendar(): string;\n\n    /**\n     * Get the time zone associated with this DateTime.\n     */\n    get zone(): Zone;\n\n    /**\n     * Get the name of the time zone.\n     */\n    get zoneName(): string;\n\n    /**\n     * Get the year\n     *\n     * @example DateTime.local(2017, 5, 25).year //=> 2017\n     */\n    get year(): number;\n\n    /**\n     * Get the quarter\n     *\n     * @example DateTime.local(2017, 5, 25).quarter //=> 2\n     */\n    get quarter(): QuarterNumbers;\n\n    /**\n     * Get the month (1-12).\n     *\n     * @example DateTime.local(2017, 5, 25).month //=> 5\n     */\n    get month(): MonthNumbers;\n\n    /**\n     * Get the day of the month (1-30ish).\n     *\n     * @example DateTime.local(2017, 5, 25).day //=> 25\n     */\n    get day(): DayNumbers;\n\n    /**\n     * Get the hour of the day (0-23).\n     *\n     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\n     */\n    get hour(): HourNumbers;\n\n    /**\n     * Get the minute of the hour (0-59).\n     *\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n     */\n    get minute(): MinuteNumbers;\n\n    /**\n     * Get the second of the minute (0-59).\n     *\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n     */\n    get second(): SecondNumbers;\n\n    /**\n     * Get the millisecond of the second (0-999).\n     *\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n     */\n    get millisecond(): number;\n\n    /**\n     * Get the week year\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     *\n     * @example\n     * DateTime.local(2014, 12, 31).weekYear //=> 2015\n     */\n    get weekYear(): number;\n\n    /**\n     * Get the week number of the week year (1-52ish).\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     *\n     * @example\n     * DateTime.local(2017, 5, 25).weekNumber //=> 21\n     */\n    get weekNumber(): WeekNumbers;\n\n    /**\n     * Get the day of the week.\n     * 1 is Monday and 7 is Sunday\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     *\n     * @example\n     * DateTime.local(2014, 11, 31).weekday //=> 4\n     */\n    get weekday(): WeekdayNumbers;\n\n    /**\n     * Get the ordinal (meaning the day of the year)\n     *\n     * @example\n     * DateTime.local(2017, 5, 25).ordinal //=> 145\n     */\n    get ordinal(): number;\n\n    /**\n     * Get the human readable short month name, such as 'Oct'.\n     * Defaults to the system's locale if no locale has been specified\n     *\n     * @example\n     * DateTime.local(2017, 10, 30).monthShort //=> Oct\n     */\n    get monthShort(): string;\n\n    /**\n     * Get the human readable long month name, such as 'October'.\n     * Defaults to the system's locale if no locale has been specified\n     *\n     * @example\n     * DateTime.local(2017, 10, 30).monthLong //=> October\n     */\n    get monthLong(): string;\n\n    /**\n     * Get the human readable short weekday, such as 'Mon'.\n     * Defaults to the system's locale if no locale has been specified\n     *\n     * @example\n     * DateTime.local(2017, 10, 30).weekdayShort //=> Mon\n     */\n    get weekdayShort(): string;\n\n    /**\n     * Get the human readable long weekday, such as 'Monday'.\n     * Defaults to the system's locale if no locale has been specified\n     *\n     * @example\n     * DateTime.local(2017, 10, 30).weekdayLong //=> Monday\n     */\n    get weekdayLong(): string;\n\n    /**\n     * Get the UTC offset of this DateTime in minutes\n     *\n     * @example\n     * DateTime.now().offset //=> -240\n     * @example\n     * DateTime.utc().offset //=> 0\n     */\n    get offset(): number;\n\n    /**\n     * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\n     * Defaults to the system's locale if no locale has been specified\n     */\n    get offsetNameShort(): string;\n\n    /**\n     * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\n     * Defaults to the system's locale if no locale has been specified\n     */\n    get offsetNameLong(): string;\n\n    /**\n     * Get whether this zone's offset ever changes, as in a DST.\n     */\n    get isOffsetFixed(): boolean;\n\n    /**\n     * Get whether the DateTime is in a DST.\n     */\n    get isInDST(): boolean;\n\n    /**\n     * Returns true if this DateTime is in a leap year, false otherwise\n     *\n     * @example\n     * DateTime.local(2016).isInLeapYear //=> true\n     * @example\n     * DateTime.local(2013).isInLeapYear //=> false\n     */\n    get isInLeapYear(): boolean;\n\n    /**\n     * Returns the number of days in this DateTime's month\n     *\n     * @example\n     * DateTime.local(2016, 2).daysInMonth //=> 29\n     * @example\n     * DateTime.local(2016, 3).daysInMonth //=> 31\n     */\n    get daysInMonth(): PossibleDaysInMonth;\n\n    /**\n     * Returns the number of days in this DateTime's year\n     *\n     * @example\n     * DateTime.local(2016).daysInYear //=> 366\n     * @example\n     * DateTime.local(2013).daysInYear //=> 365\n     */\n    get daysInYear(): PossibleDaysInYear;\n\n    /**\n     * Returns the number of weeks in this DateTime's year\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     *\n     * @example\n     * DateTime.local(2004).weeksInWeekYear //=> 53\n     * @example\n     * DateTime.local(2013).weeksInWeekYear //=> 52\n     */\n    get weeksInWeekYear(): PossibleWeeksInYear;\n\n    /**\n     * Returns the resolved Intl options for this DateTime.\n     * This is useful in understanding the behavior of formatting methods\n     *\n     * @param opts - the same options as toLocaleString\n     */\n    resolvedLocaleOptions(opts?: LocaleOptions | DateTimeFormatOptions): ResolvedLocaleOptions;\n\n    // TRANSFORM\n\n    /**\n     * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n     *\n     * Equivalent to {@link DateTime.setZone}('utc')\n     *\n     * @param offset - optionally, an offset from UTC in minutes. Defaults to 0.\n     * @param opts - options to pass to `setZone()`. Defaults to {}.\n     */\n    toUTC(offset?: number, opts?: ZoneOptions): DateTime;\n\n    /**\n     * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n     *\n     * Equivalent to `setZone('local')`\n     */\n    toLocal(): DateTime;\n\n    /**\n     * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n     *\n     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations,\n     * as with {@link DateTime.plus}. You may wish to use {@link DateTime.toLocal} and {@link DateTime.toUTC} which provide simple convenience wrappers for commonly used zones.\n     *\n     * @param zone - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'.\n     * You may also supply an instance of a {@link DateTime.Zone} class. Defaults to 'local'.\n     * @param opts - options\n     * @param opts.keepLocalTime - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this. Defaults to false.\n     */\n    setZone(zone?: string | Zone, opts?: ZoneOptions): DateTime;\n\n    /**\n     * \"Set\" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.\n     *\n     * @param properties - the properties to set\n     *\n     * @example\n     * DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })\n     */\n    reconfigure(properties: LocaleOptions): DateTime;\n\n    /**\n     * \"Set\" the locale. Returns a newly-constructed DateTime.\n     * Just a convenient alias for reconfigure({ locale })\n     *\n     * @example\n     * DateTime.local(2017, 5, 25).setLocale('en-GB')\n     */\n    setLocale(locale: string): DateTime;\n\n    /**\n     * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\n     * You can only set units with this method; for \"setting\" metadata, see {@link DateTime.reconfigure} and {@link DateTime.setZone}.\n     *\n     * @param values - a mapping of units to numbers\n     *\n     * @example\n     * dt.set({ year: 2017 })\n     * @example\n     * dt.set({ hour: 8, minute: 30 })\n     * @example\n     * dt.set({ weekday: 5 })\n     * @example\n     * dt.set({ year: 2005, ordinal: 234 })\n     */\n    set(values: DateObjectUnits): DateTime;\n\n    /**\n     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar,\n     * accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\n     *\n     * @param duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     *\n     * @example\n     * DateTime.now().plus(123) //~> in 123 milliseconds\n     * @example\n     * DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes\n     * @example\n     * DateTime.now().plus({ days: 1 }) //~> this time tomorrow\n     * @example\n     * DateTime.now().plus({ days: -1 }) //~> this time yesterday\n     * @example\n     * DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\n     * @example\n     * DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\n     */\n    plus(duration: DurationLike): DateTime;\n\n    /**\n     * See {@link DateTime.plus}\n     *\n     * @param duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     */\n    minus(duration: DurationLike): DateTime;\n\n    /**\n     * \"Set\" this DateTime to the beginning of a unit of time.\n     *\n     * @param unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n     *\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\n     */\n    startOf(unit: DateTimeUnit): DateTime;\n\n    /**\n     * \"Set\" this DateTime to the end (meaning the last millisecond) of a unit of time\n     *\n     * @param unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.\n     *\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\n     */\n    endOf(unit: DateTimeUnit): DateTime;\n\n    // OUTPUT\n\n    /**\n     * Returns a string representation of this DateTime formatted according to the specified format string.\n     * **You may not want this.** See {@link DateTime.toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations,\n     * see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n     *\n     * @param fmt - the format string\n     * @param opts - opts to override the configuration options on this DateTime\n     *\n     * @example\n     * DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\n     * @example\n     * DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\n     * @example\n     * DateTime.now().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\n     * @example\n     * DateTime.now().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\n     */\n    toFormat(fmt: string, opts?: LocaleOptions): string;\n\n    /**\n     * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon,\n     * such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE` of the DateTime in the assigned locale.\n     * Defaults to the system's locale if no locale has been specified\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     *\n     * @param formatOpts - Intl.DateTimeFormat constructor options and configuration options\n     * @param opts - opts to override the configuration options on this DateTime\n     *\n     * @example\n     * DateTime.now().toLocaleString(); //=> 4/20/2017\n     * @example\n     * DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\n     * @example\n     * DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\n     * @example\n     * DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\n     * @example\n     * DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\n     * @example\n     * DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'\n     */\n    toLocaleString(formatOpts?: DateTimeFormatOptions, opts?: LocaleOptions): string;\n\n    /**\n     * Returns an array of format \"parts\", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.\n     * Defaults to the system's locale if no locale has been specified\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\n     *\n     * @param opts - Intl.DateTimeFormat constructor options, same as `toLocaleString`.\n     *\n     * @example\n     * DateTime.now().toLocaleParts(); //=> [\n     *                                 //=>   { type: 'day', value: '25' },\n     *                                 //=>   { type: 'literal', value: '/' },\n     *                                 //=>   { type: 'month', value: '05' },\n     *                                 //=>   { type: 'literal', value: '/' },\n     *                                 //=>   { type: 'year', value: '1982' }\n     *                                 //=> ]\n     */\n    toLocaleParts(opts?: DateTimeFormatOptions): Intl.DateTimeFormatPart[];\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime\n     *\n     * @param opts - options\n     * @param opts.suppressMilliseconds - exclude milliseconds from the format if they're 0. Defaults to false.\n     * @param opts.suppressSeconds - exclude seconds from the format if they're 0. Defaults to false.\n     * @param opts.includeOffset - include the offset, such as 'Z' or '-04:00'. Defaults to true.\n     * @param opts.format - choose between the basic and extended format. Defaults to 'extended'.\n     *\n     * @example\n     * DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\n     * @example\n     * DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'\n     * @example\n     * DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\n     * @example\n     * DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'\n     */\n    toISO(opts?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's date component\n     *\n     * @param opts - options\n     * @param opts.format - choose between the basic and extended format. Defaults to 'extended'.\n     *\n     * @example\n     * DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\n     * @example\n     * DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'\n     */\n    toISODate(opts?: ToISODateOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's week date\n     *\n     * @example\n     * DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\n     */\n    toISOWeekDate(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's time component\n     *\n     * @param opts - options\n     * @param opts.suppressMilliseconds - exclude milliseconds from the format if they're 0. Defaults to false.\n     * @param opts.suppressSeconds - exclude seconds from the format if they're 0. Defaults to false.\n     * @param opts.includeOffset - include the offset, such as 'Z' or '-04:00'. Defaults to true.\n     * @param opts.includePrefix - include the `T` prefix. Defaults to false.\n     * @param opts.format - choose between the basic and extended format. Defaults to 'extended'.\n     *\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'\n     */\n    toISOTime(ops?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC\n     *\n     * @example\n     * DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\n     * @example\n     * DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\n     */\n    toRFC2822(): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in HTTP headers.\n     * Specifically, the string conforms to RFC 1123.\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n     *\n     * @example\n     * DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\n     * @example\n     * DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\n     */\n    toHTTP(): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL Date\n     *\n     * @example\n     * DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\n     */\n    toSQLDate(): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL Time\n     *\n     * @param opts - options\n     * @param opts.includeZone - include the zone, such as 'America/New_York'. Overrides includeOffset. Defaults to false.\n     * @param opts.includeOffset - include the offset, such as 'Z' or '-04:00'. Defaults to true.\n     *\n     * @example\n     * DateTime.utc().toSQL() //=> '05:15:16.345'\n     * @example\n     * DateTime.now().toSQL() //=> '05:15:16.345 -04:00'\n     * @example\n     * DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'\n     * @example\n     * DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\n     */\n    toSQLTime(opts?: ToSQLOptions): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL DateTime\n     *\n     * @param opts - options\n     * @param opts.includeZone - include the zone, such as 'America/New_York'. Overrides includeOffset. Defaults to false.\n     * @param opts.includeOffset - include the offset, such as 'Z' or '-04:00'. Defaults to true.\n     *\n     * @example\n     * DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\n     */\n    toSQL(opts?: ToSQLOptions): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for debugging\n     */\n    toString(): string;\n\n    /**\n     * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime.toMillis}\n     */\n    valueOf(): number;\n\n    /**\n     * Returns the epoch milliseconds of this DateTime.\n     */\n    toMillis(): number;\n\n    /**\n     * Returns the epoch seconds of this DateTime.\n     */\n    toSeconds(): number;\n\n    /**\n     * Returns the epoch seconds (as a whole number) of this DateTime.\n     */\n    toUnixInteger(): number;\n\n    /**\n     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\n     */\n    toJSON(): string;\n\n    /**\n     * Returns a BSON serializable equivalent to this DateTime.\n     */\n    toBSON(): Date;\n\n    /**\n     * Returns a JavaScript object with this DateTime's year, month, day, and so on.\n     *\n     * @param opts - options for generating the object\n     * @param opts.includeConfig - include configuration attributes in the output. Defaults to false.\n     *\n     * @example\n     * DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\n     */\n    toObject(opts?: {\n        /**\n         * Include configuration attributes in the output\n         * @defaultValue false\n         */\n        includeConfig?: boolean | undefined;\n    }): ToObjectOutput;\n\n    /**\n     * Returns a JavaScript Date equivalent to this DateTime.\n     */\n    toJSDate(): Date;\n\n    // COMPARE\n\n    /**\n     * Return the difference between two DateTimes as a Duration.\n     *\n     * @param otherDateTime - the DateTime to compare this one to\n     * @param unit- the unit or array of units (such as 'hours' or 'days') to include in the duration. Defaults to ['milliseconds'].\n     * @param opts - options that affect the creation of the Duration\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     *\n     * @example\n     * var i1 = DateTime.fromISO('1982-05-25T09:45'),\n     *     i2 = DateTime.fromISO('1983-10-14T10:30');\n     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\n     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\n     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\n     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\n     */\n    diff(otherDateTime: DateTime, unit?: DurationUnits, opts?: DiffOptions): Duration;\n\n    /**\n     * Return the difference between this DateTime and right now.\n     * See {@link DateTime.diff}\n     *\n     * @param unit - the unit or units units (such as 'hours' or 'days') to include in the duration. Defaults to ['milliseconds'].\n     * @param opts - options that affect the creation of the Duration\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     */\n    diffNow(unit?: DurationUnits, opts?: DiffOptions): Duration;\n\n    /**\n     * Return an Interval spanning between this DateTime and another DateTime\n     *\n     * @param otherDateTime - the other end point of the Interval\n     */\n    until(otherDateTime: DateTime): Interval;\n\n    /**\n     * Return whether this DateTime is in the same unit of time as another DateTime.\n     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime.setZone} to convert one of the dates if needed.\n     *\n     * @param otherDateTime - the other DateTime\n     * @param unit - the unit of time to check sameness on\n     *\n     * @example\n     * DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day\n     */\n    hasSame(otherDateTime: DateTime, unit: DateTimeUnit): boolean;\n\n    /**\n     * Equality check\n     * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.\n     * To compare just the millisecond values, use `+dt1 === +dt2`.\n     *\n     * @param other - the other DateTime\n     */\n    equals(other: DateTime): boolean;\n\n    /**\n     * Returns a string representation of a this time relative to now, such as \"in two days\". Can only internationalize if your\n     * platform supports Intl.RelativeTimeFormat. Rounds down by default.\n     *\n     * @param options - options that affect the output\n     * @param options.base - the DateTime to use as the basis to which this time is compared. Defaults to now.\n     * @param options.style - the style of units, must be \"long\", \"short\", or \"narrow\". Defaults to long.\n     * @param options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit.\n     * Use an array or one of \"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", or \"seconds\"\n     * @param options.round - whether to round the numbers in the output. Defaults to true.\n     * @param options.padding - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false}\n     * because the decimal output will include the padding. Defaults to 0.\n     * @param options.locale - override the locale of this DateTime\n     * @param options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n     *\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\n     * @example\n     * DateTime.now().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 da\"\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\n     * @example\n     * DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\n     */\n    toRelative(options?: ToRelativeOptions): string | null;\n\n    /**\n     * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\".\n     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.\n     *\n     * @param options - options that affect the output\n     * @param options.base - the DateTime to use as the basis to which this time is compared. Defaults to now.\n     * @param options.locale - override the locale of this DateTime\n     * @param options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of \"years\", \"quarters\", \"months\", \"weeks\", or \"days\"\n     * @param options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this\n     *\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\n     * @example\n     * DateTime.now().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"\"maana\"\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\n     */\n    toRelativeCalendar(options?: ToRelativeCalendarOptions): string | null;\n\n    /**\n     * Return the min of several date times\n     *\n     * @param dateTimes - the DateTimes from which to choose the minimum\n     */\n    static min(...dateTimes: DateTime[]): DateTime;\n\n    /**\n     * Return the max of several date times\n     *\n     * @param dateTimes - the DateTimes from which to choose the maximum\n     */\n    static max(...dateTimes: DateTime[]): DateTime;\n\n    // MISC\n\n    /**\n     * Explain how a string would be parsed by fromFormat()\n     *\n     * @param text - the string to parse\n     * @param fmt - the format the string is expected to be in (see description)\n     * @param options - options taken by fromFormat()\n     */\n    static fromFormatExplain(text: string, fmt: string, options?: DateTimeOptions): ExplainedFormat;\n\n    /**\n     * @deprecated use fromFormatExplain instead\n     */\n    static fromStringExplain(text: string, fmt: string, options?: DateTimeOptions): ExplainedFormat;\n\n    // FORMAT PRESETS\n\n    /**\n     * {@link DateTime.toLocaleString} format like 10/14/1983\n     */\n    static get DATE_SHORT(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Oct 14, 1983'\n     */\n    static get DATE_MED(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Fri, Oct 14, 1983'\n     */\n    static get DATE_MED_WITH_WEEKDAY(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'October 14, 1983'\n     */\n    static get DATE_FULL(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Tuesday, October 14, 1983'\n     */\n    static get DATE_HUGE(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\n     */\n    static get TIME_SIMPLE(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\n     */\n    static get TIME_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\n     */\n    static get TIME_WITH_SHORT_OFFSET(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static get TIME_WITH_LONG_OFFSET(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30', always 24-hour.\n     */\n    static get TIME_24_SIMPLE(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23', always 24-hour.\n     */\n    static get TIME_24_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 EDT', always 24-hour.\n     */\n    static get TIME_24_WITH_SHORT_OFFSET(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\n     */\n    static get TIME_24_WITH_LONG_OFFSET(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_SHORT(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_SHORT_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_MED(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_MED_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_MED_WITH_WEEKDAY(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_FULL(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_FULL_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_HUGE(): Intl.DateTimeFormatOptions;\n\n    /**\n     * {@link DateTime.toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static get DATETIME_HUGE_WITH_SECONDS(): Intl.DateTimeFormatOptions;\n}\n","node_modules/@types/luxon/src/duration.d.ts":"import { NumberingSystem } from './misc';\nimport { ConversionAccuracy } from './datetime';\n\nexport interface DurationOptions {\n    locale?: string | undefined;\n    numberingSystem?: NumberingSystem | undefined;\n    conversionAccuracy?: ConversionAccuracy | undefined;\n}\n\nexport interface DurationObjectUnits {\n    years?: number | undefined;\n    quarters?: number | undefined;\n    months?: number | undefined;\n    weeks?: number | undefined;\n    days?: number | undefined;\n    hours?: number | undefined;\n    minutes?: number | undefined;\n    seconds?: number | undefined;\n    milliseconds?: number | undefined;\n}\n\nexport interface DurationLikeObject extends DurationObjectUnits {\n    year?: number | undefined;\n    quarter?: number | undefined;\n    month?: number | undefined;\n    week?: number | undefined;\n    day?: number | undefined;\n    hour?: number | undefined;\n    minute?: number | undefined;\n    second?: number | undefined;\n    millisecond?: number | undefined;\n}\n\nexport type DurationUnit = keyof DurationLikeObject;\nexport type DurationUnits = DurationUnit | DurationUnit[];\n\nexport type ToISOFormat = 'basic' | 'extended';\n\nexport interface ToISOTimeDurationOptions {\n    /**\n     * Include the `T` prefix\n     * @default false\n     */\n    includePrefix?: boolean | undefined;\n    /**\n     * Exclude milliseconds from the format if they're 0\n     * @default false\n     */\n    suppressMilliseconds?: boolean | undefined;\n    /**\n     * Exclude seconds from the format if they're 0\n     * @default false\n     */\n    suppressSeconds?: boolean | undefined;\n    /**\n     * Choose between the basic and extended format\n     * @default 'extended'\n     */\n    format?: ToISOFormat | undefined;\n}\n\nexport interface ToHumanDurationOptions extends Intl.NumberFormatOptions {\n    listStyle?: 'long' | 'short' | 'narrow' | undefined;\n}\n\n/**\n * Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n *\n * @deprecated Use DurationLike instead.\n */\nexport type DurationInput = Duration | number | DurationLikeObject;\n\n/**\n * Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n */\nexport type DurationLike = Duration | DurationLikeObject | number;\n\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\".\n * Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them.\n * They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n * * **Unit values** See the {@link Duration#years}, {@link Duration.months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes},\n * * {@link Duration#seconds}, {@link Duration#milliseconds} accessors.\n * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure},\n * * {@link Duration#shiftTo}, and {@link Duration#negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\nexport class Duration {\n    /**\n     * Create Duration from a number of milliseconds.\n     *\n     * @param count - of milliseconds\n     * @param opts - options for parsing\n     * @param opts.locale - the locale to use\n     * @param opts.numberingSystem - the numbering system to use\n     * @param opts.conversionAccuracy - the conversion system to use\n     */\n    static fromMillis(count: number, opts?: DurationOptions): Duration;\n\n    /**\n     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n     * If this object is empty then a zero milliseconds duration is returned.\n     *\n     * @param obj - the object to create the DateTime from\n     * @param obj.years\n     * @param obj.quarters\n     * @param obj.months\n     * @param obj.weeks\n     * @param obj.days\n     * @param obj.hours\n     * @param obj.minutes\n     * @param obj.seconds\n     * @param obj.milliseconds\n     * @param opts - options for creating this Duration. Defaults to {}.\n     * @param opts.locale - the locale to use. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     */\n    static fromObject(obj: DurationLikeObject, opts?: DurationOptions): Duration;\n\n    /**\n     * Create a Duration from DurationLike.\n     *\n     * @param durationLike\n     * Either a Luxon Duration, a number of milliseconds, or the object argument to Duration.fromObject()\n     */\n    static fromDurationLike(durationLike: DurationLike): Duration;\n\n    /**\n     * Create a Duration from an ISO 8601 duration string.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n     *\n     * @param text - text to parse\n     * @param opts - options for parsing\n     * @param opts.locale - the locale to use. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     *\n     * @example\n     * Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n     * @example\n     * Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n     * @example\n     * Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n     */\n    static fromISO(text: string, opts?: DurationOptions): Duration;\n\n    /**\n     * Create a Duration from an ISO 8601 time string.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n     *\n     * @param text - text to parse\n     * @param opts - options for parsing\n     * @param opts.locale - the locale to use. Defaults to 'en-US'.\n     * @param opts.numberingSystem - the numbering system to use\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     *\n     * @example\n     * Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n     * @example\n     * Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     */\n    static fromISOTime(text: string, opts?: DurationOptions): Duration;\n\n    /**\n     * Create an invalid Duration.\n     *\n     * @param reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n     * @param explanation - longer explanation, may include parameters and other useful debugging information. Defaults to null.\n     */\n    static invalid(reason: string, explanation?: string): Duration;\n\n    /**\n     * Check if an object is a Duration. Works across context boundaries\n     *\n     * @param o\n     */\n    static isDuration(o: unknown): o is Duration;\n\n    /**\n     * Get  the locale of a Duration, such 'en-GB'\n     */\n    get locale(): string;\n\n    /**\n     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n     */\n    get numberingSystem(): string;\n\n    /**\n     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:\n     * * `S` for milliseconds\n     * * `s` for seconds\n     * * `m` for minutes\n     * * `h` for hours\n     * * `d` for days\n     * * `M` for months\n     * * `y` for years\n     * Notes:\n     * * Add padding by repeating the token, e.g. \"yy\" pads the years to two digits, \"hhhh\" pads the hours out to four digits\n     * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.\n     *\n     * @param fmt - the format string\n     * @param opts - options\n     * @param opts.floor - floor numerical values. Defaults to true.\n     *\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n     */\n    toFormat(fmt: string, opts?: { floor?: boolean | undefined }): string;\n\n    /**\n     * Returns a string representation of a Duration with all units included\n     * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant. See {@link Intl.NumberFormat}.\n     * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.\n     * @example\n     * ```js\n     * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })\n     * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'\n     * dur.toHuman({ listStyle: \"long\" }) //=> '1 day, 5 hours, and 6 minutes'\n     * dur.toHuman({ unitDisplay: \"short\" }) //=> '1 day, 5 hr, 6 min'\n     * ```\n     */\n    toHuman(opts?: ToHumanDurationOptions): string;\n\n    /**\n     * Returns a JavaScript object with this Duration's values.\n     *\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n     */\n    toObject(): DurationObjectUnits;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Duration.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n     *\n     * @example\n     * Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n     * @example\n     * Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n     * @example\n     * Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n     * @example\n     * Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n     * @example\n     * Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n     */\n    toISO(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n     *\n     * @param opts - options\n     * @param opts.suppressMilliseconds - exclude milliseconds from the format if they're 0. Defaults to false.\n     * @param opts.suppressSeconds - exclude seconds from the format if they're 0. Defaults to false.\n     * @param opts.includePrefix - include the `T` prefix. Defaults to false.\n     * @param opts.format - choose between the basic and extended format. Defaults to 'extended'.\n     *\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n     */\n    toISOTime(opts?: ToISOTimeDurationOptions): string;\n\n    /**\n     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n     */\n    toJSON(): string;\n\n    /**\n     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n     */\n    toString(): string;\n\n    /**\n     * Returns an milliseconds value of this Duration.\n     */\n    toMillis(): number;\n\n    /**\n     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n     */\n    valueOf(): number;\n\n    /**\n     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n     *\n     * @param duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     */\n    plus(duration: DurationLike): Duration;\n\n    /**\n     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n     *\n     * @param duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n     */\n    minus(duration: DurationLike): Duration;\n\n    /**\n     * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n     *\n     * @example\n     * Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit(x => x * 2) //=> { hours: 2, minutes: 60 }\n     * @example\n     * Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit((x, u) => u === \"hour\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n     */\n    mapUnits(fn: (x: number, u?: DurationUnit) => number): Duration;\n\n    /**\n     * Get the value of unit.\n     *\n     * @param unit - a unit such as 'minute' or 'day'\n     *\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).get('years') //=> 2\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).get('months') //=> 0\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).get('days') //=> 3\n     */\n    get(unit: DurationUnit): number;\n\n    /**\n     * \"Set\" the values of specified units. Return a newly-constructed Duration.\n     *\n     * @param values - a mapping of units to numbers\n     *\n     * @example\n     * dur.set({ years: 2017 })\n     * @example\n     * dur.set({ hours: 8, minutes: 30 })\n     */\n    set(values: DurationLikeObject): Duration;\n\n    /**\n     * \"Set\" the locale and/or numberingSystem.  Returns a newly-constructed Duration.\n     *\n     * @example\n     * dur.reconfigure({ locale: 'en-GB' })\n     */\n    reconfigure(opts?: DurationOptions): Duration;\n\n    /**\n     * Return the length of the duration in the specified unit.\n     *\n     * @param unit - a unit such as 'minutes' or 'days'\n     *\n     * @example\n     * Duration.fromObject({years: 1}).as('days') //=> 365\n     * @example\n     * Duration.fromObject({years: 1}).as('months') //=> 12\n     * @example\n     * Duration.fromObject({hours: 60}).as('days') //=> 2.5\n     */\n    as(unit: DurationUnit): number;\n\n    /**\n     * Reduce this Duration to its canonical representation in its current units.\n     *\n     * @example\n     * Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n     * @example\n     * Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n     */\n    normalize(): Duration;\n\n    /**\n     * Convert this Duration into its representation in a different set of units.\n     *\n     * @example\n     * Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n     */\n    shiftTo(...units: DurationUnit[]): Duration;\n\n    /**\n     * Return the negative of this Duration.\n     *\n     * @example\n     * Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n     */\n    negate(): Duration;\n\n    /**\n     * Get the years.\n     */\n    get years(): number;\n\n    /**\n     * Get the quarters.\n     */\n    get quarters(): number;\n\n    /**\n     * Get the months.\n     */\n    get months(): number;\n\n    /**\n     * Get the weeks\n     */\n    get weeks(): number;\n\n    /**\n     * Get the days.\n     */\n    get days(): number;\n\n    /**\n     * Get the hours.\n     */\n    get hours(): number;\n\n    /**\n     * Get the minutes.\n     */\n    get minutes(): number;\n\n    /**\n     * Get the seconds.\n     */\n    get seconds(): number;\n\n    /**\n     * Get the milliseconds.\n     */\n    get milliseconds(): number;\n\n    /**\n     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n     * on invalid DateTimes or Intervals.\n     */\n    get isValid(): boolean;\n\n    /**\n     * Returns an error code if this Duration became invalid, or null if the Duration is valid\n     */\n    get invalidReason(): string;\n\n    /**\n     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n     */\n    get invalidExplanation(): string;\n\n    /**\n     * Equality check\n     * Two Durations are equal iff they have the same units and the same values for each unit.\n     *\n     * @param other\n     */\n    equals(other: Duration): boolean;\n}\n","node_modules/@types/luxon/src/info.d.ts":"import { CalendarSystem, NumberingSystem, StringUnitLength, UnitLength } from './misc';\nimport { Zone } from './zone';\n\nexport interface InfoOptions {\n    locale?: string | undefined;\n}\n\nexport interface InfoUnitOptions extends InfoOptions {\n    numberingSystem?: NumberingSystem | undefined;\n}\n\n/** @deprecated */\nexport type UnitOptions = InfoUnitOptions;\n\nexport interface InfoCalendarOptions extends InfoUnitOptions {\n    outputCalendar?: CalendarSystem | undefined;\n}\n\n/**\n * The set of available features in this environment. Some features of Luxon are not available in all environments.\n */\nexport interface Features {\n    /**\n     * Whether this environment supports relative time formatting\n     */\n    relative: boolean;\n}\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any\n * supported locale, and for discovering which of Luxon features are available in the current environment.\n */\nexport namespace Info {\n    /**\n     * Return whether the specified zone contains a DST.\n     *\n     * @param zone - Zone to check. Defaults to the environment's local zone. Defaults to 'local'.\n     */\n    function hasDST(zone?: string | Zone): boolean;\n\n    /**\n     * Return whether the specified zone is a valid IANA specifier.\n     *\n     * @param zone - Zone to check\n     */\n    function isValidIANAZone(zone: string): boolean;\n\n    /**\n     * Converts the input into a {@link Zone} instance.\n     *\n     * * If `input` is already a Zone instance, it is returned unchanged.\n     * * If `input` is a string containing a valid time zone name, a Zone instance\n     *   with that name is returned.\n     * * If `input` is a string that doesn't refer to a known time zone, a Zone\n     *   instance with {@link Zone.isValid} == false is returned.\n     * * If `input is a number, a Zone instance with the specified fixed offset\n     *   in minutes is returned.\n     * * If `input` is `null` or `undefined`, the default zone is returned.\n     *\n     * @param input - the value to be converted\n     */\n    function normalizeZone(input?: string | Zone | number): Zone;\n\n    /**\n     * Return an array of standalone month names.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     *\n     * @param length - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\". Defaults to 'long'.\n     * @param opts - options\n     * @param opts.locale - the locale code\n     * @param opts.numberingSystem - the numbering system. Defaults to null.\n     * @param opts.locObj - an existing locale object to use. Defaults to null.\n     * @param opts.outputCalendar - the calendar. Defaults to 'gregory'.\n     *\n     * @example\n     * Info.months()[0] //=> 'January'\n     * @example\n     * Info.months('short')[0] //=> 'Jan'\n     * @example\n     * Info.months('numeric')[0] //=> '1'\n     * @example\n     * Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n     * @example\n     * Info.months('numeric', { locale: 'ar' })[0] //=> ''\n     * @example\n     * Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'\n     */\n    function months(length?: UnitLength, opts?: InfoCalendarOptions): string[];\n\n    /**\n     * Return an array of format month names.\n     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n     * changes the string.\n     * See {@link Info#months}\n     *\n     * @param length - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\". Defaults to 'long'.\n     * @param opts - options\n     * @param opts.locale - the locale code\n     * @param opts.numberingSystem - the numbering system. Defaults to null.\n     * @param opts.locObj - an existing locale object to use. Defaults to null.\n     * @param opts.outputCalendar - the calendar. Defaults to 'gregory'.\n     */\n    function monthsFormat(length?: UnitLength, options?: InfoCalendarOptions): string[];\n\n    /**\n     * Return an array of standalone week names.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     *\n     * @param length - the length of the weekday representation, such as \"narrow\", \"short\", \"long\". Defaults to 'long'.\n     * @param opts - options\n     * @param opts.locale - the locale code\n     * @param opts.numberingSystem - the numbering system. Defaults to null.\n     * @param opts.locObj - an existing locale object to use. Defaults to null.\n     *\n     * @example\n     * Info.weekdays()[0] //=> 'Monday'\n     * @example\n     * Info.weekdays('short')[0] //=> 'Mon'\n     * @example\n     * Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n     * @example\n     * Info.weekdays('short', { locale: 'ar' })[0] //=> ''\n     */\n    function weekdays(length?: StringUnitLength, options?: InfoUnitOptions): string[];\n\n    /**\n     * Return an array of format week names.\n     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n     * changes the string.\n     * See {@link Info#weekdays}\n     *\n     * @param length - the length of the month representation, such as \"narrow\", \"short\", \"long\". Defaults to 'long'.\n     * @param opts - options\n     * @param opts.locale - the locale code. Defaults to null.\n     * @param opts.numberingSystem - the numbering system. Defaults to null.\n     * @param opts.locObj - an existing locale object to use. Defaults to null.\n     */\n    function weekdaysFormat(length?: StringUnitLength, options?: InfoUnitOptions): string[];\n\n    /**\n     * Return an array of meridiems.\n     *\n     * @param opts - options\n     * @param opts.locale - the locale code\n     *\n     * @example\n     * Info.meridiems() //=> [ 'AM', 'PM' ]\n     * @example\n     * Info.meridiems({ locale: 'my' }) //=> [ '', '' ]\n     */\n    function meridiems(options?: InfoOptions): string[];\n\n    /**\n     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n     *\n     * @param length - the length of the era representation, such as \"short\" or \"long\". Defaults to 'short'.\n     * @param opts - options\n     * @param opts.locale - the locale code\n     *\n     * @example\n     * Info.eras() //=> [ 'BC', 'AD' ]\n     * @example\n     * Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n     * @example\n     * Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]\n     */\n    function eras(length?: StringUnitLength, options?: InfoOptions): string[];\n\n    /**\n     * Return the set of available features in this environment.\n     * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\n     * Keys:\n     * * `relative`: whether this environment supports relative time formatting\n     *\n     * @example\n     * Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }\n     */\n    function features(): Features;\n}\n","node_modules/@types/luxon/src/interval.d.ts":"import { DateTime, DateObjectUnits, DateTimeOptions, DiffOptions, ToISOTimeOptions } from './datetime';\nimport { Duration, DurationLike, DurationUnit } from './duration';\n\nexport interface IntervalObject {\n    start?: DateTime | undefined;\n    end?: DateTime | undefined;\n}\n\nexport type DateInput = DateTime | DateObjectUnits | Date;\n\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for\n * creating, parsing, interrogating, comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link Interval.fromDateTimes}, {@link Interval.after}, {@link Interval.before}, or {@link Interval.fromISO}.\n * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame},\n * * {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually},\n * * {@link Interval#merge}, {@link Interval#xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.\n * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}\n * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime},\n * * {@link Interval#toFormat}, and {@link Interval#toDuration}.\n */\nexport class Interval {\n    /**\n     * Create an invalid Interval.\n     *\n     * @param reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n     * @param explanation - longer explanation, may include parameters and other useful debugging information. Defaults to null.\n     */\n    static invalid(reason: string, explanation?: string): Interval;\n\n    /**\n     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n     *\n     * @param start\n     * @param end\n     */\n    static fromDateTimes(start: DateInput, end: DateInput): Interval;\n\n    /**\n     * Create an Interval from a start DateTime and a Duration to extend to.\n     *\n     * @param start\n     * @param duration - the length of the Interval.\n     */\n    static after(start: DateInput, duration: DurationLike): Interval;\n\n    /**\n     * Create an Interval from an end DateTime and a Duration to extend backwards to.\n     *\n     * @param end\n     * @param duration - the length of the Interval.\n     */\n    static before(end: DateInput, duration: DurationLike): Interval;\n\n    /**\n     * Create an Interval from an ISO 8601 string.\n     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     *\n     * @param text - the ISO string to parse\n     * @param opts - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}\n     */\n    static fromISO(text: string, opts?: DateTimeOptions): Interval;\n\n    /**\n     * Check if an object is an Interval. Works across context boundaries\n     *\n     * @param o\n     */\n    static isInterval(o: unknown): o is Interval;\n\n    /**\n     * Returns the start of the Interval\n     */\n    get start(): DateTime;\n\n    /**\n     * Returns the end of the Interval\n     */\n    get end(): DateTime;\n\n    /**\n     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n     */\n    get isValid(): boolean;\n\n    /**\n     * Returns an error code if this Interval is invalid, or null if the Interval is valid\n     */\n    get invalidReason(): string;\n\n    /**\n     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n     */\n    get invalidExplanation(): string;\n\n    /**\n     * Returns the length of the Interval in the specified unit.\n     *\n     * @param unit - the unit (such as 'hours' or 'days') to return the length in.\n     */\n    length(unit?: DurationUnit): number;\n\n    /**\n     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n     * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n     *\n     * @param unit - the unit of time to count. Defaults to 'milliseconds'.\n     */\n    count(unit?: DurationUnit): number;\n\n    /**\n     * Returns whether this Interval's start and end are both in the same unit of time\n     *\n     * @param unit - the unit of time to check sameness on\n     */\n    hasSame(unit: DurationUnit): boolean;\n\n    /**\n     * Return whether this Interval has the same start and end DateTimes.\n     */\n    isEmpty(): boolean;\n\n    /**\n     * Return whether this Interval's start is after the specified DateTime.\n     *\n     * @param dateTime\n     */\n    isAfter(dateTime: DateTime): boolean;\n\n    /**\n     * Return whether this Interval's end is before the specified DateTime.\n     *\n     * @param dateTime\n     */\n    isBefore(dateTime: DateTime): boolean;\n\n    /**\n     * Return whether this Interval contains the specified DateTime.\n     *\n     * @param dateTime\n     */\n    contains(dateTime: DateTime): boolean;\n\n    /**\n     * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n     *\n     * @param values - the values to set\n     * @param values.start - the starting DateTime\n     * @param values.end - the ending DateTime\n     */\n    set(values?: IntervalObject): Interval;\n\n    /**\n     * Split this Interval at each of the specified DateTimes\n     *\n     * @param dateTimes - the unit of time to count.\n     */\n    splitAt(...dateTimes: DateTime[]): Interval[];\n\n    /**\n     * Split this Interval into smaller Intervals, each of the specified length.\n     * Left over time is grouped into a smaller interval\n     *\n     * @param duration - The length of each resulting interval.\n     */\n    splitBy(duration: DurationLike): Interval[];\n\n    /**\n     * Split this Interval into the specified number of smaller intervals.\n     *\n     * @param numberOfParts - The number of Intervals to divide the Interval into.\n     */\n    divideEqually(numberOfParts: number): Interval[];\n\n    /**\n     * Return whether this Interval overlaps with the specified Interval\n     *\n     * @param other\n     */\n    overlaps(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval's end is adjacent to the specified Interval's start.\n     *\n     * @param other\n     */\n    abutsStart(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval's start is adjacent to the specified Interval's end.\n     *\n     * @param other\n     */\n    abutsEnd(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval engulfs the start and end of the specified Interval.\n     *\n     * @param other\n     */\n    engulfs(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval has the same start and end as the specified Interval.\n     *\n     * @param other\n     */\n    equals(other: Interval): boolean;\n\n    /**\n     * Return an Interval representing the intersection of this Interval and the specified Interval.\n     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n     * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n     *\n     * @param other\n     */\n    intersection(other: Interval): Interval | null;\n\n    /**\n     * Return an Interval representing the union of this Interval and the specified Interval.\n     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n     *\n     * @param other\n     */\n    union(other: Interval): Interval;\n\n    /**\n     * Merge an array of Intervals into a equivalent minimal set of Intervals.\n     * Combines overlapping and adjacent Intervals.\n     *\n     * @param intervals\n     */\n    static merge(intervals: Interval[]): Interval[];\n\n    /**\n     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n     *\n     *  @param intervals\n     */\n    static xor(intervals: Interval[]): Interval[];\n\n    /**\n     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n     *\n     * @param intervals\n     */\n    difference(...intervals: Interval[]): Interval[];\n\n    /**\n     * Returns a string representation of this Interval appropriate for debugging.\n     */\n    toString(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Interval.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     *\n     * @param opts - The same options as {@link DateTime#toISO}\n     */\n    toISO(opts?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of date of this Interval.\n     * The time components are ignored.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     */\n    toISODate(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of time of this Interval.\n     * The date components are ignored.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     *\n     * @param opts - The same options as {@link DateTime.toISO}\n     */\n    toISOTime(opts?: ToISOTimeOptions): string;\n\n    /**\n     * Returns a string representation of this Interval formatted according to the specified format string.\n     *\n     * @param dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.\n     * @param opts - options\n     * @param opts.separator - a separator to place between the start and end representations. Defaults to ' - '.\n     */\n    toFormat(\n        dateFormat: string,\n        opts?: {\n            separator?: string | undefined;\n        },\n    ): string;\n\n    /**\n     * Return a Duration representing the time spanned by this interval.\n     *\n     * @param unit - the unit or units (such as 'hours' or 'days') to include in the duration. Defaults to ['milliseconds'].\n     * @param opts - options that affect the creation of the Duration\n     * @param opts.conversionAccuracy - the conversion system to use. Defaults to 'casual'.\n     *\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n     */\n    toDuration(unit?: DurationUnit | DurationUnit[], opts?: DiffOptions): Duration;\n\n    /**\n     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n     *\n     * @param mapFn\n     *\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n     */\n    mapEndpoints(mapFn: (d: DateTime) => DateTime): Interval;\n}\n","node_modules/@types/luxon/src/luxon.d.ts":"export const VERSION: string;\n\nexport * from './datetime';\nexport * from './duration';\nexport * from './info';\nexport * from './interval';\nexport * from './settings';\nexport * from './zone';\nexport * from './misc';\n","node_modules/@types/luxon/src/misc.d.ts":"export type DateTimeFormatOptions = Intl.DateTimeFormatOptions;\n\nexport interface ZoneOptions {\n    /**\n     * If true, adjust the underlying time so that the local time stays the same, but in the target zone.\n     * You should rarely need this.\n     * Defaults to false.\n     */\n    keepLocalTime?: boolean | undefined;\n    /**\n     * @deprecated since 0.2.12. Use keepLocalTime instead\n     */\n    keepCalendarTime?: boolean | undefined;\n}\n\n/** @deprecated */\nexport type EraLength = StringUnitLength;\n\nexport type NumberingSystem = Intl.DateTimeFormatOptions extends { numberingSystem?: infer T }\n    ? T\n    :\n          | 'arab'\n          | 'arabext'\n          | 'bali'\n          | 'beng'\n          | 'deva'\n          | 'fullwide'\n          | 'gujr'\n          | 'guru'\n          | 'hanidec'\n          | 'khmr'\n          | 'knda'\n          | 'laoo'\n          | 'latn'\n          | 'limb'\n          | 'mlym'\n          | 'mong'\n          | 'mymr'\n          | 'orya'\n          | 'tamldec'\n          | 'telu'\n          | 'thai'\n          | 'tibt';\n\nexport type CalendarSystem = Intl.DateTimeFormatOptions extends { calendar?: infer T }\n    ? T\n    :\n          | 'buddhist'\n          | 'chinese'\n          | 'coptic'\n          | 'ethioaa'\n          | 'ethiopic'\n          | 'gregory'\n          | 'hebrew'\n          | 'indian'\n          | 'islamic'\n          | 'islamicc'\n          | 'iso8601'\n          | 'japanese'\n          | 'persian'\n          | 'roc';\n\nexport type HourCycle = 'h11' | 'h12' | 'h23' | 'h24';\n\nexport type StringUnitLength = 'narrow' | 'short' | 'long';\nexport type NumberUnitLength = 'numeric' | '2-digit';\nexport type UnitLength = StringUnitLength | NumberUnitLength;\n","node_modules/@types/luxon/src/settings.d.ts":"import { Zone } from './zone';\n\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior.\n * Luxon is a simple library with few options, but the ones it does have live here.\n */\n// tslint:disable-next-line:no-unnecessary-class\nexport class Settings {\n    /**\n     * Get the callback for returning the current timestamp.\n     */\n    static get now(): () => number;\n\n    /**\n     * Set the callback for returning the current timestamp.\n     * The function should return a number, which will be interpreted as an Epoch millisecond count\n     *\n     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n     */\n    static set now(now: () => number);\n\n    /**\n     * The default time zone object currently used to create DateTimes. Does not affect existing instances.\n     * The default value is the system's time zone (the one set on the machine that runs this code).\n     * Getting this property always returns a Zone object.\n     */\n    static defaultZone: Zone | string;\n\n    /**\n     * Get the default locale to create DateTimes with. Does not affect existing instances.\n     */\n    static get defaultLocale(): string;\n\n    /**\n     * Set the default locale to create DateTimes with. Does not affect existing instances.\n     */\n    static set defaultLocale(locale: string);\n\n    /**\n     * Get the default numbering system to create DateTimes with. Does not affect existing instances.\n     */\n    static get defaultNumberingSystem(): string;\n\n    /**\n     * Set the default numbering system to create DateTimes with. Does not affect existing instances.\n     */\n    static set defaultNumberingSystem(numberingSystem: string);\n\n    /**\n     * Get the default output calendar to create DateTimes with. Does not affect existing instances.\n     */\n    static get defaultOutputCalendar(): string;\n\n    /**\n     * Set the default output calendar to create DateTimes with. Does not affect existing instances.\n     */\n    static set defaultOutputCalendar(outputCalendar: string);\n\n    /**\n     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n     */\n    static get throwOnInvalid(): boolean;\n\n    /**\n     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n     */\n    static set throwOnInvalid(t: boolean);\n\n    /**\n     * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n     */\n    static resetCaches(): void;\n}\n","node_modules/@types/luxon/src/zone.d.ts":"export interface ZoneOffsetOptions {\n    /**\n     * What style of offset to return.\n     */\n    format?: 'short' | 'long' | undefined;\n    /**\n     * What locale to return the offset name in.\n     */\n    locale?: string | undefined;\n}\n\n/**\n * What style of offset to return.\n * Returning '+6', '+06:00', or '+0600' respectively\n */\nexport type ZoneOffsetFormat = 'narrow' | 'short' | 'techie';\n\nexport class Zone {\n    /**\n     * The type of zone\n     */\n    get type(): string;\n\n    /**\n     * The name of this zone.\n     */\n    get name(): string;\n\n    /**\n     * Returns whether the offset is known to be fixed for the whole year.\n     */\n    get isUniversal(): boolean;\n\n    /**\n     * Returns the offset's common name (such as EST) at the specified timestamp\n     *\n     * @param ts - Epoch milliseconds for which to get the name\n     * @param options - Options to affect the format\n     * @param options.format - What style of offset to return.\n     * @param options.locale - What locale to return the offset name in.\n     */\n    offsetName(ts: number, options: ZoneOffsetOptions): string;\n\n    /**\n     * Returns the offset's value as a string\n     *\n     * @param ts - Epoch milliseconds for which to get the offset\n     * @param format - What style of offset to return.\n     *                 Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n     */\n    formatOffset(ts: number, format: ZoneOffsetFormat): string;\n\n    /**\n     * Return the offset in minutes for this zone at the specified timestamp.\n     *\n     * @param ts - Epoch milliseconds for which to compute the offset\n     */\n    offset(ts: number): number;\n\n    /**\n     * Return whether this Zone is equal to another zone\n     *\n     * @param other - the zone to compare\n     */\n    equals(other: Zone): boolean;\n\n    /**\n     * Return whether this Zone is valid.\n     */\n    get isValid(): boolean;\n}\n\n/**\n * A zone identified by an IANA identifier, like America/New_York\n */\nexport class IANAZone extends Zone {\n    /**\n     * Same as constructor but has caching.\n     */\n    static create(name: string): IANAZone;\n\n    /**\n     * Reset local caches. Should only be necessary in testing scenarios.\n     */\n    static resetCache(): void;\n\n    /**\n     * Returns whether the provided string is a valid specifier.\n     * This only checks the string's format, not that the specifier\n     * identifies a known zone; see {@link isValidZone} for that.\n     *\n     * @param s - The string to check validity on\n     *\n     * @example\n     * IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n     * @example\n     * IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\n     * @example\n     * IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n     */\n    static isValidSpecifier(s: string): boolean;\n\n    /**\n     * Returns whether the provided string identifies a real zone\n     *\n     * @param zone - The string to check\n     *\n     * @example\n     * IANAZone.isValidZone(\"America/New_York\") //=> true\n     * @example\n     * IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n     * @example\n     * IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n     */\n    static isValidZone(zone: string): boolean;\n\n    constructor(name: string);\n}\n\n/**\n * A zone with a fixed offset (meaning no DST)\n */\nexport class FixedOffsetZone extends Zone {\n    /**\n     * Get a singleton instance of UTC\n     */\n    static get utcInstance(): FixedOffsetZone;\n\n    /**\n     * Get an instance with a specified offset\n     *\n     * @param offset - The offset in minutes\n     */\n    static instance(offset: number): FixedOffsetZone;\n\n    /**\n     * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n     *\n     * @param s - The offset string to parse\n     *\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC+6\")\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC+06\")\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n     */\n    static parseSpecifier(s: string): FixedOffsetZone;\n}\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n */\nexport class InvalidZone extends Zone {}\n\n/**\n * Represents the system zone for this JavaScript environment.\n */\nexport class SystemZone extends Zone {\n    /**\n     * Get a singleton instance of the system zone\n     */\n    static get instance(): SystemZone;\n}\n","pgPool.ts":"\n      import * as pg from 'pg';\n      export default new pg.Pool();"};