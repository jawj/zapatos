const zapatosBundle = {"zapatos/LICENCE":"Zapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","zapatos/schema.js":"/*\n** DON'T EDIT THIS FILE **\nIt's generated by Zapatos, and is liable to be overwritten\n\nGenerated using version 0.1.36 on 2020-05-28T12:50:10.213Z\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n","zapatos/schema.ts":"\n/*\n** DON'T EDIT THIS FILE **\nIt's generated by Zapatos, and is liable to be overwritten\n\nGenerated using version 0.1.36 on 2020-05-28T12:53:00.098Z\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport type {\n  JSONValue,\n  JSONArray,\n  DateString,\n  SQLFragment,\n  SQL,\n  GenericSQLExpression,\n  ColumnNames,\n  ColumnValues,\n  ParentColumn,\n  DefaultType,\n} from \"./src/core\";\n\n\n/* === schema: public === */\n\n/* --- enums --- */\n\nexport type appleEnvironment = 'PROD' | 'Sandbox';\nexport namespace every {\n  export type appleEnvironment = ['PROD', 'Sandbox'];\n}\n\n/* --- tables --- */\n\nexport namespace appleTransactions {\n  export type Table = 'appleTransactions';\n  export interface Selectable {\n    environment: appleEnvironment;\n    originalTransactionId: string;\n    accountId: number;\n    latestReceiptData: string | null;\n  }\n  export interface Insertable {\n    environment: appleEnvironment | SQLFragment;\n    originalTransactionId: string | SQLFragment;\n    accountId: number | SQLFragment;\n    latestReceiptData?: string | null | DefaultType | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'appleTransactionsPrimaryKey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace authors {\n  export type Table = 'authors';\n  export interface Selectable {\n    id: number;\n    name: string;\n    isLiving: boolean | null;\n  }\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    name: string | SQLFragment;\n    isLiving?: boolean | null | DefaultType | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'authors_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace bankAccounts {\n  export type Table = 'bankAccounts';\n  export interface Selectable {\n    id: number;\n    balance: number;\n  }\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    balance?: number | DefaultType | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'bankAccounts_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace books {\n  export type Table = 'books';\n  export interface Selectable {\n    id: number;\n    authorId: number;\n    title: string | null;\n    createdAt: Date;\n  }\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    authorId: number | SQLFragment;\n    title?: string | null | DefaultType | SQLFragment;\n    createdAt?: Date | DateString | DefaultType | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'books_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace doctors {\n  export type Table = 'doctors';\n  export interface Selectable {\n    id: number;\n    name: string;\n  }\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    name: string | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'doctors_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace emailAuthentication {\n  export type Table = 'emailAuthentication';\n  export interface Selectable {\n    email: string;\n    consecutiveFailedLogins: number;\n    lastFailedLogin: Date | null;\n  }\n  export interface Insertable {\n    email: string | SQLFragment;\n    consecutiveFailedLogins?: number | DefaultType | SQLFragment;\n    lastFailedLogin?: Date | DateString | null | DefaultType | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'emailAuthentication_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace employees {\n  export type Table = 'employees';\n  export interface Selectable {\n    id: number;\n    name: string;\n    managerId: number | null;\n  }\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    name: string | SQLFragment;\n    managerId?: number | null | DefaultType | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'employees_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace shifts {\n  export type Table = 'shifts';\n  export interface Selectable {\n    day: Date;\n    doctorId: number;\n  }\n  export interface Insertable {\n    day: Date | DateString | SQLFragment;\n    doctorId: number | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'shifts_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace stores {\n  export type Table = 'stores';\n  export interface Selectable {\n    id: number;\n    name: string;\n    geom: any;\n  }\n  export interface Insertable {\n    id?: number | DefaultType | SQLFragment;\n    name: string | SQLFragment;\n    geom: any | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'stores_pkey';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\nexport namespace tags {\n  export type Table = 'tags';\n  export interface Selectable {\n    tag: string;\n    bookId: number;\n  }\n  export interface Insertable {\n    tag: string | SQLFragment;\n    bookId: number | SQLFragment;\n  }\n  export interface Updatable extends Partial<Insertable> { }\n  export type Whereable = { [K in keyof Insertable]?: Exclude<Insertable[K] | ParentColumn, null | DefaultType> };\n  export type JSONSelectable = { [K in keyof Selectable]:\n    Date extends Selectable[K] ? Exclude<Selectable[K], Date> | DateString :\n    Date[] extends Selectable[K] ? Exclude<Selectable[K], Date[]> | DateString[] :\n    Selectable[K]\n  };\n  export type UniqueIndex = 'tagsUniqueIdx';\n  export type Column = keyof Selectable;\n  export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n  export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;\n  export type SQL = SQLExpression | SQLExpression[];\n}\n\n/* --- cross-table types --- */\n\nexport type Table = appleTransactions.Table | authors.Table | bankAccounts.Table | books.Table | doctors.Table | emailAuthentication.Table | employees.Table | shifts.Table | stores.Table | tags.Table;\nexport type Selectable = appleTransactions.Selectable | authors.Selectable | bankAccounts.Selectable | books.Selectable | doctors.Selectable | emailAuthentication.Selectable | employees.Selectable | shifts.Selectable | stores.Selectable | tags.Selectable;\nexport type Whereable = appleTransactions.Whereable | authors.Whereable | bankAccounts.Whereable | books.Whereable | doctors.Whereable | emailAuthentication.Whereable | employees.Whereable | shifts.Whereable | stores.Whereable | tags.Whereable;\nexport type Insertable = appleTransactions.Insertable | authors.Insertable | bankAccounts.Insertable | books.Insertable | doctors.Insertable | emailAuthentication.Insertable | employees.Insertable | shifts.Insertable | stores.Insertable | tags.Insertable;\nexport type Updatable = appleTransactions.Updatable | authors.Updatable | bankAccounts.Updatable | books.Updatable | doctors.Updatable | emailAuthentication.Updatable | employees.Updatable | shifts.Updatable | stores.Updatable | tags.Updatable;\nexport type UniqueIndex = appleTransactions.UniqueIndex | authors.UniqueIndex | bankAccounts.UniqueIndex | books.UniqueIndex | doctors.UniqueIndex | emailAuthentication.UniqueIndex | employees.UniqueIndex | shifts.UniqueIndex | stores.UniqueIndex | tags.UniqueIndex;\nexport type Column = appleTransactions.Column | authors.Column | bankAccounts.Column | books.Column | doctors.Column | emailAuthentication.Column | employees.Column | shifts.Column | stores.Column | tags.Column;\nexport type AllTables = [appleTransactions.Table, authors.Table, bankAccounts.Table, books.Table, doctors.Table, emailAuthentication.Table, employees.Table, shifts.Table, stores.Table, tags.Table];\n\n\nexport type SelectableForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Selectable;\n  authors: authors.Selectable;\n  bankAccounts: bankAccounts.Selectable;\n  books: books.Selectable;\n  doctors: doctors.Selectable;\n  emailAuthentication: emailAuthentication.Selectable;\n  employees: employees.Selectable;\n  shifts: shifts.Selectable;\n  stores: stores.Selectable;\n  tags: tags.Selectable;\n}[T];\n\nexport type WhereableForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Whereable;\n  authors: authors.Whereable;\n  bankAccounts: bankAccounts.Whereable;\n  books: books.Whereable;\n  doctors: doctors.Whereable;\n  emailAuthentication: emailAuthentication.Whereable;\n  employees: employees.Whereable;\n  shifts: shifts.Whereable;\n  stores: stores.Whereable;\n  tags: tags.Whereable;\n}[T];\n\nexport type InsertableForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Insertable;\n  authors: authors.Insertable;\n  bankAccounts: bankAccounts.Insertable;\n  books: books.Insertable;\n  doctors: doctors.Insertable;\n  emailAuthentication: emailAuthentication.Insertable;\n  employees: employees.Insertable;\n  shifts: shifts.Insertable;\n  stores: stores.Insertable;\n  tags: tags.Insertable;\n}[T];\n\nexport type UpdatableForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Updatable;\n  authors: authors.Updatable;\n  bankAccounts: bankAccounts.Updatable;\n  books: books.Updatable;\n  doctors: doctors.Updatable;\n  emailAuthentication: emailAuthentication.Updatable;\n  employees: employees.Updatable;\n  shifts: shifts.Updatable;\n  stores: stores.Updatable;\n  tags: tags.Updatable;\n}[T];\n\nexport type UniqueIndexForTable<T extends Table> = {\n  appleTransactions: appleTransactions.UniqueIndex;\n  authors: authors.UniqueIndex;\n  bankAccounts: bankAccounts.UniqueIndex;\n  books: books.UniqueIndex;\n  doctors: doctors.UniqueIndex;\n  emailAuthentication: emailAuthentication.UniqueIndex;\n  employees: employees.UniqueIndex;\n  shifts: shifts.UniqueIndex;\n  stores: stores.UniqueIndex;\n  tags: tags.UniqueIndex;\n}[T];\n\nexport type ColumnForTable<T extends Table> = {\n  appleTransactions: appleTransactions.Column;\n  authors: authors.Column;\n  bankAccounts: bankAccounts.Column;\n  books: books.Column;\n  doctors: doctors.Column;\n  emailAuthentication: emailAuthentication.Column;\n  employees: employees.Column;\n  shifts: shifts.Column;\n  stores: stores.Column;\n  tags: tags.Column;\n}[T];\n\nexport type SQLForTable<T extends Table> = {\n  appleTransactions: appleTransactions.SQL;\n  authors: authors.SQL;\n  bankAccounts: bankAccounts.SQL;\n  books: books.SQL;\n  doctors: doctors.SQL;\n  emailAuthentication: emailAuthentication.SQL;\n  employees: employees.SQL;\n  shifts: shifts.SQL;\n  stores: stores.SQL;\n  tags: tags.SQL;\n}[T];\n\n","zapatos/src/config.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nlet config = {\n    transactionAttemptsMax: 5,\n    transactionRetryDelay: { minMs: 25, maxMs: 250 },\n};\n/**\n * Get (a copy of) the current configuration.\n */\nexport const getConfig = () => (Object.assign({}, config));\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport const setConfig = (newConfig) => config = Object.assign(Object.assign({}, config), newConfig);\n","zapatos/src/config.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nexport interface Config {\n  transactionAttemptsMax: number;\n  transactionRetryDelay: { minMs: number; maxMs: number };\n  queryListener?(str: any): void;\n  resultListener?(str: any): void;\n  transactionListener?(str: any): void;\n}\nexport type NewConfig = Partial<Config>;\n\nlet config: Config = {  // defaults\n  transactionAttemptsMax: 5,\n  transactionRetryDelay: { minMs: 25, maxMs: 250 },\n};\n\n/**\n * Get (a copy of) the current configuration.\n */\nexport const getConfig = () => ({ ...config });\n\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport const setConfig = (newConfig: NewConfig) =>\n  config = { ...config, ...newConfig };\n","zapatos/src/core.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nimport { getConfig } from './config';\n// === symbols, types, wrapper classes and shortcuts ===\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport const Default = Symbol('DEFAULT');\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport const self = Symbol('self');\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport const all = Symbol('all');\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value\n * at the appropriate position of the values array passed to pg\n */\nexport class Parameter {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter (`$1`,\n * `$2`, etc) and adds its wrapped value at the appropriate position of the values array\n * passed to pg\n */\nexport function param(x) { return new Parameter(x); }\n/**\n * Compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport class DangerousRawString {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `DangerousRawString` instance, wrapping a string. `DangerousRawString`\n * compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport function raw(x) { return new DangerousRawString(x); }\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or object. `ColumnNames`\n * compiles to a quoted, comma-separated list of array values (for use in a `SELECT`\n * query) or object keys (for use in an `INSERT`, `UDPATE` or `UPSERT` query, alongside\n * `ColumnValues`).\n */\nexport class ColumnNames {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object. `ColumnNames`\n * compiles to a quoted, comma-separated list of array values (for use in a `SELECT`\n * query) or object keys (for use in an `INSERT`, `UDPATE` or `UPSERT` query alongside\n * a `ColumnValues`).\n */\nexport function cols(x) { return new ColumnNames(x); }\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an `INSERT`,\n * `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport class ColumnValues {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to a\n * quoted, comma-separated list of object keys for use in an INSERT, UPDATE or UPSERT\n * query alongside a `ColumnNames`.\n */\nexport function vals(x) { return new ColumnValues(x); }\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport class ParentColumn {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to that\n * column name of the table of the parent query.\n */\nexport function parent(x) { return new ParentColumn(x); }\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type argument\n * defines what interpolated value types are allowed. The second defines what type the\n * `SQLFragment` produces, where relevant (i.e. when calling `.run(...)` on it, or using\n * it as the value of an `extras` object).\n */\nexport function sql(literals, ...expressions) {\n    return new SQLFragment(Array.prototype.slice.apply(literals), expressions);\n}\nexport class SQLFragment {\n    constructor(literals, expressions) {\n        this.literals = literals;\n        this.expressions = expressions;\n        /**\n         * When calling `run`, this function is applied to the object returned by `pg` to\n         * produce the result that is returned. By default, the `rows` array is returned — i.e.\n         * `(qr) => qr.rows` — but some shortcut functions alter this in order to match their\n         * declared `RunResult` type.\n         */\n        this.runResultTransform = qr => qr.rows;\n        this.parentTable = undefined; // used for nested shortcut select queries\n        /**\n         * Compile and run this query using the provided database connection. What's returned\n         * is piped via `runResultTransform` before being returned.\n         * @param queryable A database client or pool\n         */\n        this.run = async (queryable) => {\n            const query = this.compile(), config = getConfig();\n            if (config.queryListener)\n                config.queryListener(query);\n            const qr = await queryable.query(query), result = this.runResultTransform(qr);\n            if (config.resultListener)\n                config.resultListener(result);\n            return result;\n        };\n        /**\n         * Compile this query, returning a `{ text: string, values: any[] }` object that could\n         * be passed to the `pg` query function. Arguments are generally only passed when the\n         * function calls itself recursively.\n         */\n        this.compile = (result = { text: '', values: [] }, parentTable, currentColumn) => {\n            if (this.parentTable)\n                parentTable = this.parentTable;\n            result.text += this.literals[0];\n            for (let i = 1, len = this.literals.length; i < len; i++) {\n                this.compileExpression(this.expressions[i - 1], result, parentTable, currentColumn);\n                result.text += this.literals[i];\n            }\n            return result;\n        };\n        this.compileExpression = (expression, result = { text: '', values: [] }, parentTable, currentColumn) => {\n            if (this.parentTable)\n                parentTable = this.parentTable;\n            if (expression instanceof SQLFragment) {\n                // another SQL fragment? recursively compile this one\n                expression.compile(result, parentTable, currentColumn);\n            }\n            else if (typeof expression === 'string') {\n                // if it's a string, it should be a x.Table or x.Columns type, so just needs quoting\n                result.text += expression.charAt(0) === '\"' ? expression : `\"${expression}\"`;\n            }\n            else if (expression instanceof DangerousRawString) {\n                // Little Bobby Tables passes straight through ...\n                result.text += expression.value;\n            }\n            else if (Array.isArray(expression)) {\n                // an array's elements are compiled one by one -- note that an empty array can be used as a non-value\n                for (let i = 0, len = expression.length; i < len; i++)\n                    this.compileExpression(expression[i], result, parentTable, currentColumn);\n            }\n            else if (expression instanceof Parameter) {\n                // parameters become placeholders, and a corresponding entry in the values array\n                result.values.push(expression.value);\n                result.text += '$' + String(result.values.length); // 1-based indexing\n            }\n            else if (expression === Default) {\n                // a column default\n                result.text += 'DEFAULT';\n            }\n            else if (expression === self) {\n                // alias to the latest column, if applicable\n                if (!currentColumn)\n                    throw new Error(`The 'self' column alias has no meaning here`);\n                result.text += `\"${currentColumn}\"`;\n            }\n            else if (expression instanceof ParentColumn) {\n                // alias to the parent table (plus supplied column name) of a nested query, if applicable\n                if (!parentTable)\n                    throw new Error(`The 'parent' table alias has no meaning here`);\n                result.text += `\"${parentTable}\".\"${expression.value}\"`;\n            }\n            else if (expression instanceof ColumnNames) {\n                // a ColumnNames-wrapped object -> quoted names in a repeatable order\n                // or: a ColumnNames-wrapped array\n                const columnNames = Array.isArray(expression.value) ? expression.value :\n                    Object.keys(expression.value).sort();\n                result.text += columnNames.map(k => `\"${k}\"`).join(', ');\n            }\n            else if (expression instanceof ColumnValues) {\n                // a ColumnValues-wrapped object -> values (in above order) are punted as SQL fragments or parameters\n                const columnNames = Object.keys(expression.value).sort(), columnValues = columnNames.map(k => expression.value[k]);\n                for (let i = 0, len = columnValues.length; i < len; i++) {\n                    const columnName = columnNames[i], columnValue = columnValues[i];\n                    if (i > 0)\n                        result.text += ', ';\n                    if (columnValue instanceof SQLFragment || columnValue === Default)\n                        this.compileExpression(columnValue, result, parentTable, columnName);\n                    else\n                        this.compileExpression(new Parameter(columnValue), result, parentTable, columnName);\n                }\n            }\n            else if (typeof expression === 'object') {\n                // must be a Whereable object, so put together a WHERE clause\n                const columnNames = Object.keys(expression).sort();\n                if (columnNames.length) { // if the object is not empty\n                    result.text += '(';\n                    for (let i = 0, len = columnNames.length; i < len; i++) {\n                        const columnName = columnNames[i], columnValue = expression[columnName];\n                        if (i > 0)\n                            result.text += ' AND ';\n                        if (columnValue instanceof SQLFragment) {\n                            result.text += '(';\n                            this.compileExpression(columnValue, result, parentTable, columnName);\n                            result.text += ')';\n                        }\n                        else {\n                            result.text += `\"${columnName}\" = `;\n                            this.compileExpression(columnValue instanceof ParentColumn ? columnValue : new Parameter(columnValue), result, parentTable, columnName);\n                        }\n                    }\n                    result.text += ')';\n                }\n                else {\n                    // or if it is empty, it should always match\n                    result.text += 'TRUE';\n                }\n            }\n            else {\n                throw new Error(`Alien object while interpolating SQL: ${expression}`);\n            }\n        };\n    }\n}\n","zapatos/src/core.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport type * as pg from 'pg';\nimport type {\n  Updatable,\n  Whereable,\n  Table,\n  Column,\n} from '../schema';\n\nimport { getConfig } from './config';\n\n\n// === symbols, types, wrapper classes and shortcuts ===\n\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport const Default = Symbol('DEFAULT');\nexport type DefaultType = typeof Default;\n\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport const self = Symbol('self');\nexport type SelfType = typeof self;\n\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport const all = Symbol('all');\nexport type AllType = typeof all;\n\nexport type JSONValue = null | boolean | number | string | JSONObject | JSONArray;\nexport type JSONObject = { [k: string]: JSONValue };\nexport type JSONArray = JSONValue[];\n\n/**\n * Date represented as an ISO8601 string in JSON.\n */\nexport type DateString = string;\n\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value \n * at the appropriate position of the values array passed to pg  \n */\nexport class Parameter { constructor(public value: any) { } }\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter (`$1`, \n * `$2`, etc) and adds its wrapped value at the appropriate position of the values array \n * passed to pg\n */\nexport function param(x: any) { return new Parameter(x); }\n\n/**\n * Compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport class DangerousRawString { constructor(public value: string) { } }\n/**\n * Returns a `DangerousRawString` instance, wrapping a string. `DangerousRawString`\n * compiles to the wrapped string value, as is. Dangerous: https://xkcd.com/327/.\n */\nexport function raw(x: string) { return new DangerousRawString(x); }\n\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or object. `ColumnNames` \n * compiles to a quoted, comma-separated list of array values (for use in a `SELECT` \n * query) or object keys (for use in an `INSERT`, `UDPATE` or `UPSERT` query, alongside \n * `ColumnValues`).\n */\nexport class ColumnNames<T> { constructor(public value: T) { } }\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object. `ColumnNames` \n * compiles to a quoted, comma-separated list of array values (for use in a `SELECT` \n * query) or object keys (for use in an `INSERT`, `UDPATE` or `UPSERT` query alongside \n * a `ColumnValues`).\n */\nexport function cols<T>(x: T) { return new ColumnNames<T>(x); }\n\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an `INSERT`, \n * `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport class ColumnValues<T> { constructor(public value: T) { } }\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to a \n * quoted, comma-separated list of object keys for use in an INSERT, UPDATE or UPSERT \n * query alongside a `ColumnNames`.\n */\nexport function vals<T>(x: T) { return new ColumnValues<T>(x); }\n\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport class ParentColumn { constructor(public value: Column) { } }\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to that \n * column name of the table of the parent query.\n */\nexport function parent(x: Column) { return new ParentColumn(x); }\n\nexport type GenericSQLExpression = SQLFragment<any> | Parameter | DefaultType | DangerousRawString | SelfType;\nexport type SQLExpression = Table | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable> | Whereable | Column | GenericSQLExpression;\nexport type SQL = SQLExpression | SQLExpression[];\n\nexport type Queryable = pg.ClientBase | pg.Pool;\n\n\n// === SQL tagged template strings ===\n\ninterface SQLQuery {\n  text: string;\n  values: any[];\n}\n\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type argument \n * defines what interpolated value types are allowed. The second defines what type the \n * `SQLFragment` produces, where relevant (i.e. when calling `.run(...)` on it, or using \n * it as the value of an `extras` object).\n */\nexport function sql<\n  Interpolations = SQL,\n  RunResult = pg.QueryResult['rows'],\n  InferredInterpolations extends Interpolations = Interpolations\n>(literals: TemplateStringsArray, ...expressions: InferredInterpolations[]) {\n  return new SQLFragment<RunResult>(Array.prototype.slice.apply(literals), expressions);\n}\n\nexport class SQLFragment<RunResult = pg.QueryResult['rows']> {\n\n  /**\n   * When calling `run`, this function is applied to the object returned by `pg` to \n   * produce the result that is returned. By default, the `rows` array is returned — i.e.\n   * `(qr) => qr.rows` — but some shortcut functions alter this in order to match their \n   * declared `RunResult` type.\n   */\n  runResultTransform: (qr: pg.QueryResult) => any = qr => qr.rows;\n\n  parentTable?: string = undefined;  // used for nested shortcut select queries\n\n  constructor(private literals: string[], private expressions: SQLExpression[]) { }\n\n  /**\n   * Compile and run this query using the provided database connection. What's returned \n   * is piped via `runResultTransform` before being returned.\n   * @param queryable A database client or pool\n   */\n  run = async (queryable: Queryable): Promise<RunResult> => {\n    const\n      query = this.compile(),\n      config = getConfig();\n    if (config.queryListener) config.queryListener(query);\n\n    const\n      qr = await queryable.query(query),\n      result = this.runResultTransform(qr);\n    if (config.resultListener) config.resultListener(result);\n\n    return result;\n  };\n\n  /**\n   * Compile this query, returning a `{ text: string, values: any[] }` object that could \n   * be passed to the `pg` query function. Arguments are generally only passed when the \n   * function calls itself recursively.\n   */\n  compile = (result: SQLQuery = { text: '', values: [] }, parentTable?: string, currentColumn?: Column) => {\n    if (this.parentTable) parentTable = this.parentTable;\n\n    result.text += this.literals[0];\n    for (let i = 1, len = this.literals.length; i < len; i++) {\n      this.compileExpression(this.expressions[i - 1], result, parentTable, currentColumn);\n      result.text += this.literals[i];\n    }\n    return result;\n  };\n\n  compileExpression = (expression: SQL, result: SQLQuery = { text: '', values: [] }, parentTable?: string, currentColumn?: Column) => {\n    if (this.parentTable) parentTable = this.parentTable;\n\n    if (expression instanceof SQLFragment) {\n      // another SQL fragment? recursively compile this one\n      expression.compile(result, parentTable, currentColumn);\n\n    } else if (typeof expression === 'string') {\n      // if it's a string, it should be a x.Table or x.Columns type, so just needs quoting\n      result.text += expression.charAt(0) === '\"' ? expression : `\"${expression}\"`;\n\n    } else if (expression instanceof DangerousRawString) {\n      // Little Bobby Tables passes straight through ...\n      result.text += expression.value;\n\n    } else if (Array.isArray(expression)) {\n      // an array's elements are compiled one by one -- note that an empty array can be used as a non-value\n      for (let i = 0, len = expression.length; i < len; i++) this.compileExpression(expression[i], result, parentTable, currentColumn);\n\n    } else if (expression instanceof Parameter) {\n      // parameters become placeholders, and a corresponding entry in the values array\n      result.values.push(expression.value);\n      result.text += '$' + String(result.values.length);  // 1-based indexing\n\n    } else if (expression === Default) {\n      // a column default\n      result.text += 'DEFAULT';\n\n    } else if (expression === self) {\n      // alias to the latest column, if applicable\n      if (!currentColumn) throw new Error(`The 'self' column alias has no meaning here`);\n      result.text += `\"${currentColumn}\"`;\n\n    } else if (expression instanceof ParentColumn) {\n      // alias to the parent table (plus supplied column name) of a nested query, if applicable\n      if (!parentTable) throw new Error(`The 'parent' table alias has no meaning here`);\n      result.text += `\"${parentTable}\".\"${expression.value}\"`;\n\n    } else if (expression instanceof ColumnNames) {\n      // a ColumnNames-wrapped object -> quoted names in a repeatable order\n      // or: a ColumnNames-wrapped array\n      const columnNames = Array.isArray(expression.value) ? expression.value :\n        Object.keys(expression.value).sort();\n      result.text += columnNames.map(k => `\"${k}\"`).join(', ');\n\n    } else if (expression instanceof ColumnValues) {\n      // a ColumnValues-wrapped object -> values (in above order) are punted as SQL fragments or parameters\n      const\n        columnNames = <Column[]>Object.keys(expression.value).sort(),\n        columnValues = columnNames.map(k => (<any>expression.value)[k]);\n\n      for (let i = 0, len = columnValues.length; i < len; i++) {\n        const\n          columnName = columnNames[i],\n          columnValue = columnValues[i];\n        if (i > 0) result.text += ', ';\n        if (columnValue instanceof SQLFragment || columnValue === Default) this.compileExpression(columnValue, result, parentTable, columnName);\n        else this.compileExpression(new Parameter(columnValue), result, parentTable, columnName);\n      }\n\n    } else if (typeof expression === 'object') {\n      // must be a Whereable object, so put together a WHERE clause\n      const columnNames = <Column[]>Object.keys(expression).sort();\n\n      if (columnNames.length) {  // if the object is not empty\n        result.text += '(';\n        for (let i = 0, len = columnNames.length; i < len; i++) {\n          const\n            columnName = columnNames[i],\n            columnValue = (<any>expression)[columnName];\n          if (i > 0) result.text += ' AND ';\n          if (columnValue instanceof SQLFragment) {\n            result.text += '(';\n            this.compileExpression(columnValue, result, parentTable, columnName);\n            result.text += ')';\n\n          } else {\n            result.text += `\"${columnName}\" = `;\n            this.compileExpression(columnValue instanceof ParentColumn ? columnValue : new Parameter(columnValue),\n              result, parentTable, columnName);\n          }\n        }\n        result.text += ')';\n\n      } else {\n        // or if it is empty, it should always match\n        result.text += 'TRUE';\n      }\n\n    } else {\n      throw new Error(`Alien object while interpolating SQL: ${expression}`);\n    }\n  };\n}\n\n\n","zapatos/src/index.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nexport * from './core';\nexport * from './shortcuts';\nexport * from './transaction';\nexport * from './config';\nexport * from './pgErrors';\n","zapatos/src/index.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nexport * from './core';\nexport * from './shortcuts';\nexport * from './transaction';\nexport * from './config';\nexport * from './pgErrors';\n","zapatos/src/pgErrors.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport function isDatabaseError(err, ...types) {\n    const { code } = err;\n    if (!code || code.length !== 5)\n        return false;\n    return types.some(type => code.startsWith(pgErrors[type]));\n}\nconst pgErrors = {\n    SuccessfulCompletion: \"00\",\n    Warning: \"01\",\n    NoData: \"02\",\n    SqlStatementNotYetComplete: \"03\",\n    ConnectionException: \"08\",\n    TriggeredActionException: \"09\",\n    FeatureNotSupported: \"0A\",\n    InvalidTransactionInitiation: \"0B\",\n    LocatorException: \"0F\",\n    InvalidGrantor: \"0L\",\n    InvalidRoleSpecification: \"0P\",\n    DiagnosticsException: \"0Z\",\n    CaseNotFound: \"20\",\n    CardinalityViolation: \"21\",\n    DataException: \"22\",\n    IntegrityConstraintViolation: \"23\",\n    InvalidCursorState: \"24\",\n    InvalidTransactionState: \"25\",\n    InvalidSqlStatementName: \"26\",\n    TriggeredDataChangeViolation: \"27\",\n    InvalidAuthorizationSpecification: \"28\",\n    DependentPrivilegeDescriptorsStillExist: \"2B\",\n    InvalidTransactionTermination: \"2D\",\n    SqlRoutineException: \"2F\",\n    InvalidCursorName: \"34\",\n    ExternalRoutineException: \"38\",\n    ExternalRoutineInvocationException: \"39\",\n    SavepointException: \"3B\",\n    InvalidCatalogName: \"3D\",\n    InvalidSchemaName: \"3F\",\n    TransactionRollback: \"40\",\n    SyntaxErrorOrAccessRuleViolation: \"42\",\n    WithCheckOptionViolation: \"44\",\n    InsufficientResources: \"53\",\n    DiskFull: \"53\",\n    OutOfMemory: \"53\",\n    TooManyConnections: \"53\",\n    ConfigurationLimitExceeded: \"53\",\n    ProgramLimitExceeded: \"54\",\n    ObjectNotInPrerequisiteState: \"55\",\n    OperatorIntervention: \"57\",\n    SystemError: \"58\",\n    SnapshotTooOld: \"72\",\n    ConfigFileError: \"F0\",\n    FdwError: \"HV\",\n    PlpgsqlError: \"P0\",\n    InternalError: \"XX\",\n    // specific errors from here\n    SuccessfulCompletion_SuccessfulCompletion: \"00000\",\n    Warning_Warning: \"01000\",\n    Warning_NullValueEliminatedInSetFunction: \"01003\",\n    Warning_StringDataRightTruncation: \"01004\",\n    Warning_PrivilegeNotRevoked: \"01006\",\n    Warning_PrivilegeNotGranted: \"01007\",\n    Warning_ImplicitZeroBitPadding: \"01008\",\n    Warning_DynamicResultSetsReturned: \"0100C\",\n    Warning_DeprecatedFeature: \"01P01\",\n    NoData_NoData: \"02000\",\n    NoData_NoAdditionalDynamicResultSetsReturned: \"02001\",\n    SqlStatementNotYetComplete_SqlStatementNotYetComplete: \"03000\",\n    ConnectionException_ConnectionException: \"08000\",\n    ConnectionException_SqlclientUnableToEstablishSqlconnection: \"08001\",\n    ConnectionException_ConnectionDoesNotExist: \"08003\",\n    ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: \"08004\",\n    ConnectionException_ConnectionFailure: \"08006\",\n    ConnectionException_TransactionResolutionUnknown: \"08007\",\n    ConnectionException_ProtocolViolation: \"08P01\",\n    TriggeredActionException_TriggeredActionException: \"09000\",\n    FeatureNotSupported_FeatureNotSupported: \"0A000\",\n    InvalidTransactionInitiation_InvalidTransactionInitiation: \"0B000\",\n    LocatorException_LocatorException: \"0F000\",\n    LocatorException_InvalidLocatorSpecification: \"0F001\",\n    InvalidGrantor_InvalidGrantor: \"0L000\",\n    InvalidGrantor_InvalidGrantOperation: \"0LP01\",\n    InvalidRoleSpecification_InvalidRoleSpecification: \"0P000\",\n    DiagnosticsException_DiagnosticsException: \"0Z000\",\n    DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: \"0Z002\",\n    CaseNotFound_CaseNotFound: \"20000\",\n    CardinalityViolation_CardinalityViolation: \"21000\",\n    DataException_DataException: \"22000\",\n    DataException_StringDataRightTruncation: \"22001\",\n    DataException_NullValueNoIndicatorParameter: \"22002\",\n    DataException_NumericValueOutOfRange: \"22003\",\n    DataException_NullValueNotAllowed: \"22004\",\n    DataException_ErrorInAssignment: \"22005\",\n    DataException_InvalidDatetimeFormat: \"22007\",\n    DataException_DatetimeFieldOverflow: \"22008\",\n    DataException_InvalidTimeZoneDisplacementValue: \"22009\",\n    DataException_EscapeCharacterConflict: \"2200B\",\n    DataException_InvalidUseOfEscapeCharacter: \"2200C\",\n    DataException_InvalidEscapeOctet: \"2200D\",\n    DataException_ZeroLengthCharacterString: \"2200F\",\n    DataException_MostSpecificTypeMismatch: \"2200G\",\n    DataException_SequenceGeneratorLimitExceeded: \"2200H\",\n    DataException_NotAnXmlDocument: \"2200L\",\n    DataException_InvalidXmlDocument: \"2200M\",\n    DataException_InvalidXmlContent: \"2200N\",\n    DataException_InvalidXmlComment: \"2200S\",\n    DataException_InvalidXmlProcessingInstruction: \"2200T\",\n    DataException_InvalidIndicatorParameterValue: \"22010\",\n    DataException_SubstringError: \"22011\",\n    DataException_DivisionByZero: \"22012\",\n    DataException_InvalidPrecedingOrFollowingSize: \"22013\",\n    DataException_InvalidArgumentForNtileFunction: \"22014\",\n    DataException_IntervalFieldOverflow: \"22015\",\n    DataException_InvalidArgumentForNthValueFunction: \"22016\",\n    DataException_InvalidCharacterValueForCast: \"22018\",\n    DataException_InvalidEscapeCharacter: \"22019\",\n    DataException_InvalidRegularExpression: \"2201B\",\n    DataException_InvalidArgumentForLogarithm: \"2201E\",\n    DataException_InvalidArgumentForPowerFunction: \"2201F\",\n    DataException_InvalidArgumentForWidthBucketFunction: \"2201G\",\n    DataException_InvalidRowCountInLimitClause: \"2201W\",\n    DataException_InvalidRowCountInResultOffsetClause: \"2201X\",\n    DataException_CharacterNotInRepertoire: \"22021\",\n    DataException_IndicatorOverflow: \"22022\",\n    DataException_InvalidParameterValue: \"22023\",\n    DataException_UnterminatedCString: \"22024\",\n    DataException_InvalidEscapeSequence: \"22025\",\n    DataException_StringDataLengthMismatch: \"22026\",\n    DataException_TrimError: \"22027\",\n    DataException_ArraySubscriptError: \"2202E\",\n    DataException_InvalidTablesampleRepeat: \"2202G\",\n    DataException_InvalidTablesampleArgument: \"2202H\",\n    DataException_FloatingPointException: \"22P01\",\n    DataException_InvalidTextRepresentation: \"22P02\",\n    DataException_InvalidBinaryRepresentation: \"22P03\",\n    DataException_BadCopyFileFormat: \"22P04\",\n    DataException_UntranslatableCharacter: \"22P05\",\n    DataException_NonstandardUseOfEscapeCharacter: \"22P06\",\n    IntegrityConstraintViolation_IntegrityConstraintViolation: \"23000\",\n    IntegrityConstraintViolation_RestrictViolation: \"23001\",\n    IntegrityConstraintViolation_NotNullViolation: \"23502\",\n    IntegrityConstraintViolation_ForeignKeyViolation: \"23503\",\n    IntegrityConstraintViolation_UniqueViolation: \"23505\",\n    IntegrityConstraintViolation_CheckViolation: \"23514\",\n    IntegrityConstraintViolation_ExclusionViolation: \"23P01\",\n    InvalidCursorState_InvalidCursorState: \"24000\",\n    InvalidTransactionState_InvalidTransactionState: \"25000\",\n    InvalidTransactionState_ActiveSqlTransaction: \"25001\",\n    InvalidTransactionState_BranchTransactionAlreadyActive: \"25002\",\n    InvalidTransactionState_InappropriateAccessModeForBranchTransaction: \"25003\",\n    InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: \"25004\",\n    InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: \"25005\",\n    InvalidTransactionState_ReadOnlySqlTransaction: \"25006\",\n    InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: \"25007\",\n    InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: \"25008\",\n    InvalidTransactionState_NoActiveSqlTransaction: \"25P01\",\n    InvalidTransactionState_InFailedSqlTransaction: \"25P02\",\n    InvalidTransactionState_IdleInTransactionSessionTimeout: \"25P03\",\n    InvalidSqlStatementName_InvalidSqlStatementName: \"26000\",\n    TriggeredDataChangeViolation_TriggeredDataChangeViolation: \"27000\",\n    InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: \"28000\",\n    InvalidAuthorizationSpecification_InvalidPassword: \"28P01\",\n    DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: \"2B000\",\n    DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: \"2BP01\",\n    InvalidTransactionTermination_InvalidTransactionTermination: \"2D000\",\n    SqlRoutineException_SqlRoutineException: \"2F000\",\n    SqlRoutineException_ModifyingSqlDataNotPermitted: \"2F002\",\n    SqlRoutineException_ProhibitedSqlStatementAttempted: \"2F003\",\n    SqlRoutineException_ReadingSqlDataNotPermitted: \"2F004\",\n    SqlRoutineException_FunctionExecutedNoReturnStatement: \"2F005\",\n    InvalidCursorName_InvalidCursorName: \"34000\",\n    ExternalRoutineException_ExternalRoutineException: \"38000\",\n    ExternalRoutineException_ContainingSqlNotPermitted: \"38001\",\n    ExternalRoutineException_ModifyingSqlDataNotPermitted: \"38002\",\n    ExternalRoutineException_ProhibitedSqlStatementAttempted: \"38003\",\n    ExternalRoutineException_ReadingSqlDataNotPermitted: \"38004\",\n    ExternalRoutineInvocationException_ExternalRoutineInvocationException: \"39000\",\n    ExternalRoutineInvocationException_InvalidSqlstateReturned: \"39001\",\n    ExternalRoutineInvocationException_NullValueNotAllowed: \"39004\",\n    ExternalRoutineInvocationException_TriggerProtocolViolated: \"39P01\",\n    ExternalRoutineInvocationException_SrfProtocolViolated: \"39P02\",\n    ExternalRoutineInvocationException_EventTriggerProtocolViolated: \"39P03\",\n    SavepointException_SavepointException: \"3B000\",\n    SavepointException_InvalidSavepointSpecification: \"3B001\",\n    InvalidCatalogName_InvalidCatalogName: \"3D000\",\n    InvalidSchemaName_InvalidSchemaName: \"3F000\",\n    TransactionRollback_TransactionRollback: \"40000\",\n    TransactionRollback_SerializationFailure: \"40001\",\n    TransactionRollback_TransactionIntegrityConstraintViolation: \"40002\",\n    TransactionRollback_StatementCompletionUnknown: \"40003\",\n    TransactionRollback_DeadlockDetected: \"40P01\",\n    SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: \"42000\",\n    SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: \"42501\",\n    SyntaxErrorOrAccessRuleViolation_SyntaxError: \"42601\",\n    SyntaxErrorOrAccessRuleViolation_InvalidName: \"42602\",\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: \"42611\",\n    SyntaxErrorOrAccessRuleViolation_NameTooLong: \"42622\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateColumn: \"42701\",\n    SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: \"42702\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedColumn: \"42703\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedObject: \"42704\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateObject: \"42710\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateAlias: \"42712\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateFunction: \"42723\",\n    SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: \"42725\",\n    SyntaxErrorOrAccessRuleViolation_GroupingError: \"42803\",\n    SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: \"42804\",\n    SyntaxErrorOrAccessRuleViolation_WrongObjectType: \"42809\",\n    SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: \"42830\",\n    SyntaxErrorOrAccessRuleViolation_CannotCoerce: \"42846\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedFunction: \"42883\",\n    SyntaxErrorOrAccessRuleViolation_GeneratedAlways: \"428C9\",\n    SyntaxErrorOrAccessRuleViolation_ReservedName: \"42939\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedTable: \"42P01\",\n    SyntaxErrorOrAccessRuleViolation_UndefinedParameter: \"42P02\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateCursor: \"42P03\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: \"42P04\",\n    SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: \"42P05\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateSchema: \"42P06\",\n    SyntaxErrorOrAccessRuleViolation_DuplicateTable: \"42P07\",\n    SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: \"42P08\",\n    SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: \"42P09\",\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: \"42P10\",\n    SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: \"42P11\",\n    SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: \"42P12\",\n    SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: \"42P13\",\n    SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: \"42P14\",\n    SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: \"42P15\",\n    SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: \"42P16\",\n    SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: \"42P17\",\n    SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: \"42P18\",\n    SyntaxErrorOrAccessRuleViolation_InvalidRecursion: \"42P19\",\n    SyntaxErrorOrAccessRuleViolation_WindowingError: \"42P20\",\n    SyntaxErrorOrAccessRuleViolation_CollationMismatch: \"42P21\",\n    SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: \"42P22\",\n    WithCheckOptionViolation_WithCheckOptionViolation: \"44000\",\n    InsufficientResources_InsufficientResources: \"53000\",\n    InsufficientResources_DiskFull: \"53100\",\n    InsufficientResources_OutOfMemory: \"53200\",\n    InsufficientResources_TooManyConnections: \"53300\",\n    InsufficientResources_ConfigurationLimitExceeded: \"53400\",\n    ProgramLimitExceeded_ProgramLimitExceeded: \"54000\",\n    ProgramLimitExceeded_StatementTooComplex: \"54001\",\n    ProgramLimitExceeded_TooManyColumns: \"54011\",\n    ProgramLimitExceeded_TooManyArguments: \"54023\",\n    ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: \"55000\",\n    ObjectNotInPrerequisiteState_ObjectInUse: \"55006\",\n    ObjectNotInPrerequisiteState_CantChangeRuntimeParam: \"55P02\",\n    ObjectNotInPrerequisiteState_LockNotAvailable: \"55P03\",\n    OperatorIntervention_OperatorIntervention: \"57000\",\n    OperatorIntervention_QueryCanceled: \"57014\",\n    OperatorIntervention_AdminShutdown: \"57P01\",\n    OperatorIntervention_CrashShutdown: \"57P02\",\n    OperatorIntervention_CannotConnectNow: \"57P03\",\n    OperatorIntervention_DatabaseDropped: \"57P04\",\n    SystemError_SystemError: \"58000\",\n    SystemError_IoError: \"58030\",\n    SystemError_UndefinedFile: \"58P01\",\n    SystemError_DuplicateFile: \"58P02\",\n    SnapshotTooOld_SnapshotTooOld: \"72000\",\n    ConfigFileError_ConfigFileError: \"F0000\",\n    ConfigFileError_LockFileExists: \"F0001\",\n    FdwError_FdwError: \"HV000\",\n    FdwError_FdwOutOfMemory: \"HV001\",\n    FdwError_FdwDynamicParameterValueNeeded: \"HV002\",\n    FdwError_FdwInvalidDataType: \"HV004\",\n    FdwError_FdwColumnNameNotFound: \"HV005\",\n    FdwError_FdwInvalidDataTypeDescriptors: \"HV006\",\n    FdwError_FdwInvalidColumnName: \"HV007\",\n    FdwError_FdwInvalidColumnNumber: \"HV008\",\n    FdwError_FdwInvalidUseOfNullPointer: \"HV009\",\n    FdwError_FdwInvalidStringFormat: \"HV00A\",\n    FdwError_FdwInvalidHandle: \"HV00B\",\n    FdwError_FdwInvalidOptionIndex: \"HV00C\",\n    FdwError_FdwInvalidOptionName: \"HV00D\",\n    FdwError_FdwOptionNameNotFound: \"HV00J\",\n    FdwError_FdwReplyHandle: \"HV00K\",\n    FdwError_FdwUnableToCreateExecution: \"HV00L\",\n    FdwError_FdwUnableToCreateReply: \"HV00M\",\n    FdwError_FdwUnableToEstablishConnection: \"HV00N\",\n    FdwError_FdwNoSchemas: \"HV00P\",\n    FdwError_FdwSchemaNotFound: \"HV00Q\",\n    FdwError_FdwTableNotFound: \"HV00R\",\n    FdwError_FdwFunctionSequenceError: \"HV010\",\n    FdwError_FdwTooManyHandles: \"HV014\",\n    FdwError_FdwInconsistentDescriptorInformation: \"HV021\",\n    FdwError_FdwInvalidAttributeValue: \"HV024\",\n    FdwError_FdwInvalidStringLengthOrBufferLength: \"HV090\",\n    FdwError_FdwInvalidDescriptorFieldIdentifier: \"HV091\",\n    PlpgsqlError_PlpgsqlError: \"P0000\",\n    PlpgsqlError_RaiseException: \"P0001\",\n    PlpgsqlError_NoDataFound: \"P0002\",\n    PlpgsqlError_TooManyRows: \"P0003\",\n    PlpgsqlError_AssertFailure: \"P0004\",\n    InternalError_InternalError: \"XX000\",\n    InternalError_DataCorrupted: \"XX001\",\n    InternalError_IndexCorrupted: \"XX002\",\n};\n","zapatos/src/pgErrors.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\ninterface Error {\n  code?: string;\n}\n\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport function isDatabaseError(err: Error, ...types: (keyof typeof pgErrors)[]) {\n  const { code } = err;\n  if (!code || code.length !== 5) return false;\n  return types.some(type => code.startsWith(pgErrors[type]));\n}\n\nconst pgErrors = {\n  SuccessfulCompletion: \"00\",\n  Warning: \"01\",\n  NoData: \"02\",\n  SqlStatementNotYetComplete: \"03\",\n  ConnectionException: \"08\",\n  TriggeredActionException: \"09\",\n  FeatureNotSupported: \"0A\",\n  InvalidTransactionInitiation: \"0B\",\n  LocatorException: \"0F\",\n  InvalidGrantor: \"0L\",\n  InvalidRoleSpecification: \"0P\",\n  DiagnosticsException: \"0Z\",\n  CaseNotFound: \"20\",\n  CardinalityViolation: \"21\",\n  DataException: \"22\",\n  IntegrityConstraintViolation: \"23\",\n  InvalidCursorState: \"24\",\n  InvalidTransactionState: \"25\",\n  InvalidSqlStatementName: \"26\",\n  TriggeredDataChangeViolation: \"27\",\n  InvalidAuthorizationSpecification: \"28\",\n  DependentPrivilegeDescriptorsStillExist: \"2B\",\n  InvalidTransactionTermination: \"2D\",\n  SqlRoutineException: \"2F\",\n  InvalidCursorName: \"34\",\n  ExternalRoutineException: \"38\",\n  ExternalRoutineInvocationException: \"39\",\n  SavepointException: \"3B\",\n  InvalidCatalogName: \"3D\",\n  InvalidSchemaName: \"3F\",\n  TransactionRollback: \"40\",\n  SyntaxErrorOrAccessRuleViolation: \"42\",\n  WithCheckOptionViolation: \"44\",\n  InsufficientResources: \"53\",\n  DiskFull: \"53\",\n  OutOfMemory: \"53\",\n  TooManyConnections: \"53\",\n  ConfigurationLimitExceeded: \"53\",\n  ProgramLimitExceeded: \"54\",\n  ObjectNotInPrerequisiteState: \"55\",\n  OperatorIntervention: \"57\",\n  SystemError: \"58\",\n  SnapshotTooOld: \"72\",\n  ConfigFileError: \"F0\",\n  FdwError: \"HV\",\n  PlpgsqlError: \"P0\",\n  InternalError: \"XX\",\n  // specific errors from here\n  SuccessfulCompletion_SuccessfulCompletion: \"00000\",\n  Warning_Warning: \"01000\",\n  Warning_NullValueEliminatedInSetFunction: \"01003\",\n  Warning_StringDataRightTruncation: \"01004\",\n  Warning_PrivilegeNotRevoked: \"01006\",\n  Warning_PrivilegeNotGranted: \"01007\",\n  Warning_ImplicitZeroBitPadding: \"01008\",\n  Warning_DynamicResultSetsReturned: \"0100C\",\n  Warning_DeprecatedFeature: \"01P01\",\n  NoData_NoData: \"02000\",\n  NoData_NoAdditionalDynamicResultSetsReturned: \"02001\",\n  SqlStatementNotYetComplete_SqlStatementNotYetComplete: \"03000\",\n  ConnectionException_ConnectionException: \"08000\",\n  ConnectionException_SqlclientUnableToEstablishSqlconnection: \"08001\",\n  ConnectionException_ConnectionDoesNotExist: \"08003\",\n  ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: \"08004\",\n  ConnectionException_ConnectionFailure: \"08006\",\n  ConnectionException_TransactionResolutionUnknown: \"08007\",\n  ConnectionException_ProtocolViolation: \"08P01\",\n  TriggeredActionException_TriggeredActionException: \"09000\",\n  FeatureNotSupported_FeatureNotSupported: \"0A000\",\n  InvalidTransactionInitiation_InvalidTransactionInitiation: \"0B000\",\n  LocatorException_LocatorException: \"0F000\",\n  LocatorException_InvalidLocatorSpecification: \"0F001\",\n  InvalidGrantor_InvalidGrantor: \"0L000\",\n  InvalidGrantor_InvalidGrantOperation: \"0LP01\",\n  InvalidRoleSpecification_InvalidRoleSpecification: \"0P000\",\n  DiagnosticsException_DiagnosticsException: \"0Z000\",\n  DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: \"0Z002\",\n  CaseNotFound_CaseNotFound: \"20000\",\n  CardinalityViolation_CardinalityViolation: \"21000\",\n  DataException_DataException: \"22000\",\n  DataException_StringDataRightTruncation: \"22001\",\n  DataException_NullValueNoIndicatorParameter: \"22002\",\n  DataException_NumericValueOutOfRange: \"22003\",\n  DataException_NullValueNotAllowed: \"22004\",\n  DataException_ErrorInAssignment: \"22005\",\n  DataException_InvalidDatetimeFormat: \"22007\",\n  DataException_DatetimeFieldOverflow: \"22008\",\n  DataException_InvalidTimeZoneDisplacementValue: \"22009\",\n  DataException_EscapeCharacterConflict: \"2200B\",\n  DataException_InvalidUseOfEscapeCharacter: \"2200C\",\n  DataException_InvalidEscapeOctet: \"2200D\",\n  DataException_ZeroLengthCharacterString: \"2200F\",\n  DataException_MostSpecificTypeMismatch: \"2200G\",\n  DataException_SequenceGeneratorLimitExceeded: \"2200H\",\n  DataException_NotAnXmlDocument: \"2200L\",\n  DataException_InvalidXmlDocument: \"2200M\",\n  DataException_InvalidXmlContent: \"2200N\",\n  DataException_InvalidXmlComment: \"2200S\",\n  DataException_InvalidXmlProcessingInstruction: \"2200T\",\n  DataException_InvalidIndicatorParameterValue: \"22010\",\n  DataException_SubstringError: \"22011\",\n  DataException_DivisionByZero: \"22012\",\n  DataException_InvalidPrecedingOrFollowingSize: \"22013\",\n  DataException_InvalidArgumentForNtileFunction: \"22014\",\n  DataException_IntervalFieldOverflow: \"22015\",\n  DataException_InvalidArgumentForNthValueFunction: \"22016\",\n  DataException_InvalidCharacterValueForCast: \"22018\",\n  DataException_InvalidEscapeCharacter: \"22019\",\n  DataException_InvalidRegularExpression: \"2201B\",\n  DataException_InvalidArgumentForLogarithm: \"2201E\",\n  DataException_InvalidArgumentForPowerFunction: \"2201F\",\n  DataException_InvalidArgumentForWidthBucketFunction: \"2201G\",\n  DataException_InvalidRowCountInLimitClause: \"2201W\",\n  DataException_InvalidRowCountInResultOffsetClause: \"2201X\",\n  DataException_CharacterNotInRepertoire: \"22021\",\n  DataException_IndicatorOverflow: \"22022\",\n  DataException_InvalidParameterValue: \"22023\",\n  DataException_UnterminatedCString: \"22024\",\n  DataException_InvalidEscapeSequence: \"22025\",\n  DataException_StringDataLengthMismatch: \"22026\",\n  DataException_TrimError: \"22027\",\n  DataException_ArraySubscriptError: \"2202E\",\n  DataException_InvalidTablesampleRepeat: \"2202G\",\n  DataException_InvalidTablesampleArgument: \"2202H\",\n  DataException_FloatingPointException: \"22P01\",\n  DataException_InvalidTextRepresentation: \"22P02\",\n  DataException_InvalidBinaryRepresentation: \"22P03\",\n  DataException_BadCopyFileFormat: \"22P04\",\n  DataException_UntranslatableCharacter: \"22P05\",\n  DataException_NonstandardUseOfEscapeCharacter: \"22P06\",\n  IntegrityConstraintViolation_IntegrityConstraintViolation: \"23000\",\n  IntegrityConstraintViolation_RestrictViolation: \"23001\",\n  IntegrityConstraintViolation_NotNullViolation: \"23502\",\n  IntegrityConstraintViolation_ForeignKeyViolation: \"23503\",\n  IntegrityConstraintViolation_UniqueViolation: \"23505\",\n  IntegrityConstraintViolation_CheckViolation: \"23514\",\n  IntegrityConstraintViolation_ExclusionViolation: \"23P01\",\n  InvalidCursorState_InvalidCursorState: \"24000\",\n  InvalidTransactionState_InvalidTransactionState: \"25000\",\n  InvalidTransactionState_ActiveSqlTransaction: \"25001\",\n  InvalidTransactionState_BranchTransactionAlreadyActive: \"25002\",\n  InvalidTransactionState_InappropriateAccessModeForBranchTransaction: \"25003\",\n  InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: \"25004\",\n  InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: \"25005\",\n  InvalidTransactionState_ReadOnlySqlTransaction: \"25006\",\n  InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: \"25007\",\n  InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: \"25008\",\n  InvalidTransactionState_NoActiveSqlTransaction: \"25P01\",\n  InvalidTransactionState_InFailedSqlTransaction: \"25P02\",\n  InvalidTransactionState_IdleInTransactionSessionTimeout: \"25P03\",\n  InvalidSqlStatementName_InvalidSqlStatementName: \"26000\",\n  TriggeredDataChangeViolation_TriggeredDataChangeViolation: \"27000\",\n  InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: \"28000\",\n  InvalidAuthorizationSpecification_InvalidPassword: \"28P01\",\n  DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: \"2B000\",\n  DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: \"2BP01\",\n  InvalidTransactionTermination_InvalidTransactionTermination: \"2D000\",\n  SqlRoutineException_SqlRoutineException: \"2F000\",\n  SqlRoutineException_ModifyingSqlDataNotPermitted: \"2F002\",\n  SqlRoutineException_ProhibitedSqlStatementAttempted: \"2F003\",\n  SqlRoutineException_ReadingSqlDataNotPermitted: \"2F004\",\n  SqlRoutineException_FunctionExecutedNoReturnStatement: \"2F005\",\n  InvalidCursorName_InvalidCursorName: \"34000\",\n  ExternalRoutineException_ExternalRoutineException: \"38000\",\n  ExternalRoutineException_ContainingSqlNotPermitted: \"38001\",\n  ExternalRoutineException_ModifyingSqlDataNotPermitted: \"38002\",\n  ExternalRoutineException_ProhibitedSqlStatementAttempted: \"38003\",\n  ExternalRoutineException_ReadingSqlDataNotPermitted: \"38004\",\n  ExternalRoutineInvocationException_ExternalRoutineInvocationException: \"39000\",\n  ExternalRoutineInvocationException_InvalidSqlstateReturned: \"39001\",\n  ExternalRoutineInvocationException_NullValueNotAllowed: \"39004\",\n  ExternalRoutineInvocationException_TriggerProtocolViolated: \"39P01\",\n  ExternalRoutineInvocationException_SrfProtocolViolated: \"39P02\",\n  ExternalRoutineInvocationException_EventTriggerProtocolViolated: \"39P03\",\n  SavepointException_SavepointException: \"3B000\",\n  SavepointException_InvalidSavepointSpecification: \"3B001\",\n  InvalidCatalogName_InvalidCatalogName: \"3D000\",\n  InvalidSchemaName_InvalidSchemaName: \"3F000\",\n  TransactionRollback_TransactionRollback: \"40000\",\n  TransactionRollback_SerializationFailure: \"40001\",\n  TransactionRollback_TransactionIntegrityConstraintViolation: \"40002\",\n  TransactionRollback_StatementCompletionUnknown: \"40003\",\n  TransactionRollback_DeadlockDetected: \"40P01\",\n  SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: \"42000\",\n  SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: \"42501\",\n  SyntaxErrorOrAccessRuleViolation_SyntaxError: \"42601\",\n  SyntaxErrorOrAccessRuleViolation_InvalidName: \"42602\",\n  SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: \"42611\",\n  SyntaxErrorOrAccessRuleViolation_NameTooLong: \"42622\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateColumn: \"42701\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: \"42702\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedColumn: \"42703\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedObject: \"42704\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateObject: \"42710\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateAlias: \"42712\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateFunction: \"42723\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: \"42725\",\n  SyntaxErrorOrAccessRuleViolation_GroupingError: \"42803\",\n  SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: \"42804\",\n  SyntaxErrorOrAccessRuleViolation_WrongObjectType: \"42809\",\n  SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: \"42830\",\n  SyntaxErrorOrAccessRuleViolation_CannotCoerce: \"42846\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedFunction: \"42883\",\n  SyntaxErrorOrAccessRuleViolation_GeneratedAlways: \"428C9\",\n  SyntaxErrorOrAccessRuleViolation_ReservedName: \"42939\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedTable: \"42P01\",\n  SyntaxErrorOrAccessRuleViolation_UndefinedParameter: \"42P02\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateCursor: \"42P03\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: \"42P04\",\n  SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: \"42P05\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateSchema: \"42P06\",\n  SyntaxErrorOrAccessRuleViolation_DuplicateTable: \"42P07\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: \"42P08\",\n  SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: \"42P09\",\n  SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: \"42P10\",\n  SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: \"42P11\",\n  SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: \"42P12\",\n  SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: \"42P13\",\n  SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: \"42P14\",\n  SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: \"42P15\",\n  SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: \"42P16\",\n  SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: \"42P17\",\n  SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: \"42P18\",\n  SyntaxErrorOrAccessRuleViolation_InvalidRecursion: \"42P19\",\n  SyntaxErrorOrAccessRuleViolation_WindowingError: \"42P20\",\n  SyntaxErrorOrAccessRuleViolation_CollationMismatch: \"42P21\",\n  SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: \"42P22\",\n  WithCheckOptionViolation_WithCheckOptionViolation: \"44000\",\n  InsufficientResources_InsufficientResources: \"53000\",\n  InsufficientResources_DiskFull: \"53100\",\n  InsufficientResources_OutOfMemory: \"53200\",\n  InsufficientResources_TooManyConnections: \"53300\",\n  InsufficientResources_ConfigurationLimitExceeded: \"53400\",\n  ProgramLimitExceeded_ProgramLimitExceeded: \"54000\",\n  ProgramLimitExceeded_StatementTooComplex: \"54001\",\n  ProgramLimitExceeded_TooManyColumns: \"54011\",\n  ProgramLimitExceeded_TooManyArguments: \"54023\",\n  ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: \"55000\",\n  ObjectNotInPrerequisiteState_ObjectInUse: \"55006\",\n  ObjectNotInPrerequisiteState_CantChangeRuntimeParam: \"55P02\",\n  ObjectNotInPrerequisiteState_LockNotAvailable: \"55P03\",\n  OperatorIntervention_OperatorIntervention: \"57000\",\n  OperatorIntervention_QueryCanceled: \"57014\",\n  OperatorIntervention_AdminShutdown: \"57P01\",\n  OperatorIntervention_CrashShutdown: \"57P02\",\n  OperatorIntervention_CannotConnectNow: \"57P03\",\n  OperatorIntervention_DatabaseDropped: \"57P04\",\n  SystemError_SystemError: \"58000\",\n  SystemError_IoError: \"58030\",\n  SystemError_UndefinedFile: \"58P01\",\n  SystemError_DuplicateFile: \"58P02\",\n  SnapshotTooOld_SnapshotTooOld: \"72000\",\n  ConfigFileError_ConfigFileError: \"F0000\",\n  ConfigFileError_LockFileExists: \"F0001\",\n  FdwError_FdwError: \"HV000\",\n  FdwError_FdwOutOfMemory: \"HV001\",\n  FdwError_FdwDynamicParameterValueNeeded: \"HV002\",\n  FdwError_FdwInvalidDataType: \"HV004\",\n  FdwError_FdwColumnNameNotFound: \"HV005\",\n  FdwError_FdwInvalidDataTypeDescriptors: \"HV006\",\n  FdwError_FdwInvalidColumnName: \"HV007\",\n  FdwError_FdwInvalidColumnNumber: \"HV008\",\n  FdwError_FdwInvalidUseOfNullPointer: \"HV009\",\n  FdwError_FdwInvalidStringFormat: \"HV00A\",\n  FdwError_FdwInvalidHandle: \"HV00B\",\n  FdwError_FdwInvalidOptionIndex: \"HV00C\",\n  FdwError_FdwInvalidOptionName: \"HV00D\",\n  FdwError_FdwOptionNameNotFound: \"HV00J\",\n  FdwError_FdwReplyHandle: \"HV00K\",\n  FdwError_FdwUnableToCreateExecution: \"HV00L\",\n  FdwError_FdwUnableToCreateReply: \"HV00M\",\n  FdwError_FdwUnableToEstablishConnection: \"HV00N\",\n  FdwError_FdwNoSchemas: \"HV00P\",\n  FdwError_FdwSchemaNotFound: \"HV00Q\",\n  FdwError_FdwTableNotFound: \"HV00R\",\n  FdwError_FdwFunctionSequenceError: \"HV010\",\n  FdwError_FdwTooManyHandles: \"HV014\",\n  FdwError_FdwInconsistentDescriptorInformation: \"HV021\",\n  FdwError_FdwInvalidAttributeValue: \"HV024\",\n  FdwError_FdwInvalidStringLengthOrBufferLength: \"HV090\",\n  FdwError_FdwInvalidDescriptorFieldIdentifier: \"HV091\",\n  PlpgsqlError_PlpgsqlError: \"P0000\",\n  PlpgsqlError_RaiseException: \"P0001\",\n  PlpgsqlError_NoDataFound: \"P0002\",\n  PlpgsqlError_TooManyRows: \"P0003\",\n  PlpgsqlError_AssertFailure: \"P0004\",\n  InternalError_InternalError: \"XX000\",\n  InternalError_DataCorrupted: \"XX001\",\n  InternalError_IndexCorrupted: \"XX002\",\n};\n","zapatos/src/shortcuts.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nimport { all, sql, cols, vals, raw, param, } from './core';\nimport { completeKeysWithDefault, mapWithSeparator } from './utils';\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport const insert = function (table, values) {\n    const completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values, colsSQL = cols(Array.isArray(completedValues) ? completedValues[0] : completedValues), valuesSQL = Array.isArray(completedValues) ?\n        mapWithSeparator(completedValues, sql `, `, v => sql `(${vals(v)})`) :\n        sql `(${vals(completedValues)})`, query = sql `INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} RETURNING to_jsonb(${table}.*) AS result`;\n    query.runResultTransform = Array.isArray(completedValues) ?\n        (qr) => qr.rows.map(r => r.result) :\n        (qr) => qr.rows[0].result;\n    return query;\n};\n/* === upsert === */\n/**\n * Wraps a unique index of the target table for use as the arbiter constraint of an\n * `upsert` shortcut query.\n */\nexport class Constraint {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Returns a `Constraint` instance, wrapping a unique index of the target table for\n * use as the arbiter constraint of an `upsert` shortcut query.\n */\nexport function constraint(x) { return new Constraint(x); }\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted or updated\n * @param conflictTarget A `UNIQUE` index or `UNIQUE`-indexed column (or array thereof) that determines\n * whether this is an `UPDATE` (when there's a matching existing value) or an `INSERT`\n * (when there isn't)\n * @param noNullUpdateCols Optionally, a column (or array thereof) that should not be\n * overwritten with `NULL` values during an update\n */\nexport const upsert = function (table, values, conflictTarget, noNullUpdateCols = []) {\n    if (typeof conflictTarget === 'string')\n        conflictTarget = [conflictTarget]; // now either Column[] or Constraint\n    if (!Array.isArray(noNullUpdateCols))\n        noNullUpdateCols = [noNullUpdateCols];\n    const completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values, firstRow = Array.isArray(completedValues) ? completedValues[0] : completedValues, colsSQL = cols(firstRow), valuesSQL = Array.isArray(completedValues) ?\n        mapWithSeparator(completedValues, sql `, `, v => sql `(${vals(v)})`) :\n        sql `(${vals(completedValues)})`, colNames = Object.keys(firstRow), nonUniqueCols = Array.isArray(conflictTarget) ?\n        colNames.filter(v => !conflictTarget.includes(v)) :\n        colNames, uniqueColsSQL = Array.isArray(conflictTarget) ?\n        sql `(${mapWithSeparator(conflictTarget.slice().sort(), sql `, `, c => c)})` :\n        sql `ON CONSTRAINT ${conflictTarget.value}`, updateColsSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql `, `, c => c), updateValuesSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql `, `, c => noNullUpdateCols.includes(c) ? sql `CASE WHEN EXCLUDED.${c} IS NULL THEN ${table}.${c} ELSE EXCLUDED.${c} END` : sql `EXCLUDED.${c}`);\n    // the added-on $action = 'INSERT' | 'UPDATE' key takes after SQL Server's approach to MERGE\n    // (and on the use of xmax for this purpose, see: https://stackoverflow.com/questions/39058213/postgresql-upsert-differentiate-inserted-and-updated-rows-using-system-columns-x)\n    const query = sql `INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} ON CONFLICT ${uniqueColsSQL} DO UPDATE SET (${updateColsSQL}) = ROW(${updateValuesSQL}) RETURNING to_jsonb(${table}.*) || jsonb_build_object('$action', CASE xmax WHEN 0 THEN 'INSERT' ELSE 'UPDATE' END) AS result`;\n    query.runResultTransform = Array.isArray(completedValues) ?\n        (qr) => qr.rows.map(r => r.result) :\n        (qr) => qr.rows[0].result;\n    return query;\n};\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport const update = function (table, values, where) {\n    // note: the ROW() constructor below is required in Postgres 10+ if we're updating a single column\n    // more info: https://www.postgresql-archive.org/Possible-regression-in-UPDATE-SET-lt-column-list-gt-lt-row-expression-gt-with-just-one-single-column0-td5989074.html\n    const query = sql `UPDATE ${table} SET (${cols(values)}) = ROW(${vals(values)}) WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n    query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n    return query;\n};\n/**\n * Generate an `DELETE` query `SQLFragment` (sadly, plain 'delete' is a reserved word).\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport const deletes = function (table, where) {\n    const query = sql `DELETE FROM ${table} WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n    query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n    return query;\n};\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or 'RESTRICT'/'CASCADE'\n */\nexport const truncate = function (table, ...opts) {\n    if (!Array.isArray(table))\n        table = [table];\n    const tables = mapWithSeparator(table, sql `, `, t => t), query = sql `TRUNCATE ${tables}${raw((opts.length ? ' ' : '') + opts.join(' '))}`;\n    return query;\n};\nexport var SelectResultMode;\n(function (SelectResultMode) {\n    SelectResultMode[SelectResultMode[\"Many\"] = 0] = \"Many\";\n    SelectResultMode[SelectResultMode[\"One\"] = 1] = \"One\";\n    SelectResultMode[SelectResultMode[\"Count\"] = 2] = \"Count\";\n})(SelectResultMode || (SelectResultMode = {}));\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other `select`/\n * `selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. Keys (all optional) are:\n * * `columns` — an array of column names: only these columns will be returned\n * * `order` — an array of `OrderSpec` objects, such as `{ by: 'column', direction: 'ASC'\n * }`\n * * `limit` and `offset` — numbers: apply this limit and offset to the query\n * * `lateral` — an object mapping key(s) to nested `select`/`selectOne`/`count` queries\n * to be `LATERAL JOIN`ed\n * * `alias` — table alias (string): required if using `lateral` to join a table to itself\n * * `extras` — an object mapping key(s) to `SQLFragment`s, so that derived\n * quantities can be included in the JSON result\n * @param mode Used internally by `selectOne` and `count`\n */\nexport const select = function (table, where = all, options = {}, mode = SelectResultMode.Many) {\n    const allOptions = mode === SelectResultMode.One ? Object.assign(Object.assign({}, options), { limit: 1 }) : options, aliasedTable = allOptions.alias || table, lateralOpt = allOptions.lateral, extrasOpt = allOptions.extras, tableAliasSQL = aliasedTable === table ? [] : sql ` AS ${aliasedTable}`, colsSQL = mode === SelectResultMode.Count ?\n        (allOptions.columns ? sql `count(${cols(allOptions.columns)})` : sql `count(${aliasedTable}.*)`) :\n        allOptions.columns ?\n            sql `jsonb_build_object(${mapWithSeparator(allOptions.columns, sql `, `, c => sql `${param(c)}::text, ${c}`)})` :\n            sql `to_jsonb(${aliasedTable}.*)`, colsLateralSQL = lateralOpt === undefined ? [] :\n        sql ` || jsonb_build_object(${mapWithSeparator(Object.keys(lateralOpt), sql `, `, (k, i) => sql `${param(k)}::text, \"ljoin_${raw(String(i))}\".result`)})`, colsExtraSQL = extrasOpt === undefined ? [] :\n        sql ` || jsonb_build_object(${mapWithSeparator(Object.keys(extrasOpt), sql `, `, k => sql `${param(k)}::text, ${extrasOpt[k]}`)})`, allColsSQL = sql `${colsSQL}${colsLateralSQL}${colsExtraSQL}`, whereSQL = where === all ? [] : sql ` WHERE ${where}`, orderSQL = !allOptions.order ? [] :\n        sql ` ORDER BY ${mapWithSeparator(allOptions.order, sql `, `, o => {\n            if (!['ASC', 'DESC'].includes(o.direction))\n                throw new Error(`Direction must be ASC/DESC, not '${o.direction}'`);\n            if (o.nulls && !['FIRST', 'LAST'].includes(o.nulls))\n                throw new Error(`Nulls must be FIRST/LAST/undefined, not '${o.nulls}'`);\n            return sql `${o.by} ${raw(o.direction)}${o.nulls ? sql ` NULLS ${raw(o.nulls)}` : []}`;\n        })}`, limitSQL = allOptions.limit === undefined ? [] : sql ` LIMIT ${param(allOptions.limit)}`, offsetSQL = allOptions.offset === undefined ? [] : sql ` OFFSET ${param(allOptions.offset)}`, lateralSQL = lateralOpt === undefined ? [] :\n        Object.keys(lateralOpt).map((k, i) => {\n            const subQ = lateralOpt[k];\n            subQ.parentTable = aliasedTable; // enables `parent('column')` in subquery's Wherables\n            return sql ` LEFT JOIN LATERAL (${subQ}) AS \"ljoin_${raw(String(i))}\" ON true`;\n        });\n    const rowsQuery = sql `SELECT ${allColsSQL} AS result FROM ${table}${tableAliasSQL}${lateralSQL}${whereSQL}${orderSQL}${limitSQL}${offsetSQL}`, query = mode !== SelectResultMode.Many ? rowsQuery :\n        // we need the aggregate to sit in a sub-SELECT in order to keep ORDER and LIMIT working as usual\n        sql `SELECT coalesce(jsonb_agg(result), '[]') AS result FROM (${rowsQuery}) AS ${raw(`\"sq_${aliasedTable}\"`)}`;\n    query.runResultTransform = mode === SelectResultMode.Count ?\n        // note: pg deliberately returns strings for int8 in case 64-bit numbers overflow\n        // (see https://github.com/brianc/node-pg-types#use), but we assume counts aren't that big\n        (qr) => Number(qr.rows[0].result) :\n        (qr) => { var _a; return (_a = qr.rows[0]) === null || _a === void 0 ? void 0 : _a.result; };\n    return query;\n};\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or\n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with other\n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport const selectOne = function (table, where, options = {}) {\n    // you might argue that 'selectOne' offers little that you can't get with destructuring assignment \n    // and plain 'select' -- e.g. let [x] = async select(...).run(pool); -- but a thing that is definitely worth \n    // having is '| undefined' in the return signature, because the result of indexing never includes undefined\n    // (see e.g. https://github.com/Microsoft/TypeScript/issues/13778)\n    return select(table, where, options, SelectResultMode.One);\n};\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be nested in\n * other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted, or `all`\n * @param options Options object. Keys are: `columns`, `alias`.\n */\nexport const count = function (table, where, options) {\n    return select(table, where, options, SelectResultMode.Count);\n};\n","zapatos/src/shortcuts.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport type {\n  SelectableForTable,\n  WhereableForTable,\n  InsertableForTable,\n  UpdatableForTable,\n  ColumnForTable,\n  UniqueIndexForTable,\n  SQLForTable,\n  Insertable,\n  Updatable,\n  Whereable,\n  Table,\n  Column,\n} from '../schema';\n\nimport {\n  AllType,\n  all,\n  DateString,\n  SQL,\n  SQLFragment,\n  sql,\n  cols,\n  vals,\n  raw,\n  param,\n} from './core';\n\nimport { completeKeysWithDefault, mapWithSeparator } from './utils';\n\ntype JSONSelectableForTable<T extends Table> = { [K in keyof SelectableForTable<T>]:\n  Date extends SelectableForTable<T>[K] ? Exclude<SelectableForTable<T>[K], Date> | DateString :\n  Date[] extends SelectableForTable<T>[K] ? Exclude<SelectableForTable<T>[K], Date[]> | DateString[] :\n  SelectableForTable<T>[K]\n};\n\n\n/* === insert === */\n\ninterface InsertSignatures {\n  <T extends Table>(table: T, values: InsertableForTable<T>): SQLFragment<JSONSelectableForTable<T>>;\n  <T extends Table>(table: T, values: InsertableForTable<T>[]): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport const insert: InsertSignatures = function\n  (table: Table, values: Insertable | Insertable[]): SQLFragment<any> {\n\n  const\n    completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values,\n    colsSQL = cols(Array.isArray(completedValues) ? completedValues[0] : completedValues),\n    valuesSQL = Array.isArray(completedValues) ?\n      mapWithSeparator(completedValues as Insertable[], sql<SQL>`, `, v => sql<SQL>`(${vals(v)})`) :\n      sql<SQL>`(${vals(completedValues)})`,\n    query = sql<SQL>`INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} RETURNING to_jsonb(${table}.*) AS result`;\n\n  query.runResultTransform = Array.isArray(completedValues) ?\n    (qr) => qr.rows.map(r => r.result) :\n    (qr) => qr.rows[0].result;\n\n  return query;\n};\n\n\n/* === upsert === */\n\n/**\n * Wraps a unique index of the target table for use as the arbiter constraint of an \n * `upsert` shortcut query.\n */\nexport class Constraint<T extends Table> { constructor(public value: UniqueIndexForTable<T>) { } }\n/**\n * Returns a `Constraint` instance, wrapping a unique index of the target table for \n * use as the arbiter constraint of an `upsert` shortcut query.\n */\nexport function constraint<T extends Table>(x: UniqueIndexForTable<T>) { return new Constraint<T>(x); }\n\nexport interface UpsertAction { $action: 'INSERT' | 'UPDATE' }\ntype UpsertReturnableForTable<T extends Table> = JSONSelectableForTable<T> & UpsertAction;\ntype UpsertConflictTargetForTable<T extends Table> = Constraint<T> | ColumnForTable<T> | ColumnForTable<T>[];\n\ninterface UpsertSignatures {\n  <T extends Table>(table: T, values: InsertableForTable<T>, conflictTarget: UpsertConflictTargetForTable<T>, noNullUpdateCols?: ColumnForTable<T> | ColumnForTable<T>[]): SQLFragment<UpsertReturnableForTable<T>>;\n  <T extends Table>(table: T, values: InsertableForTable<T>[], conflictTarget: UpsertConflictTargetForTable<T>, noNullUpdateCols?: ColumnForTable<T> | ColumnForTable<T>[]): SQLFragment<UpsertReturnableForTable<T>[]>;\n}\n\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted or updated\n * @param conflictTarget A `UNIQUE` index or `UNIQUE`-indexed column (or array thereof) that determines\n * whether this is an `UPDATE` (when there's a matching existing value) or an `INSERT` \n * (when there isn't)\n * @param noNullUpdateCols Optionally, a column (or array thereof) that should not be \n * overwritten with `NULL` values during an update\n */\nexport const upsert: UpsertSignatures = function\n  (table: Table, values: Insertable | Insertable[], conflictTarget: Column | Column[] | Constraint<Table>, noNullUpdateCols: Column | Column[] = []): SQLFragment<any> {\n\n  if (typeof conflictTarget === 'string') conflictTarget = [conflictTarget];  // now either Column[] or Constraint\n  if (!Array.isArray(noNullUpdateCols)) noNullUpdateCols = [noNullUpdateCols];\n\n  const\n    completedValues = Array.isArray(values) ? completeKeysWithDefault(values) : values,\n    firstRow = Array.isArray(completedValues) ? completedValues[0] : completedValues,\n    colsSQL = cols(firstRow),\n    valuesSQL = Array.isArray(completedValues) ?\n      mapWithSeparator(completedValues as Insertable[], sql`, `, v => sql`(${vals(v)})`) :\n      sql`(${vals(completedValues)})`,\n    colNames = Object.keys(firstRow) as Column[],\n    nonUniqueCols = Array.isArray(conflictTarget) ?\n      colNames.filter(v => !(conflictTarget as Column[]).includes(v)) :\n      colNames,\n    uniqueColsSQL = Array.isArray(conflictTarget) ?\n      sql`(${mapWithSeparator(conflictTarget.slice().sort(), sql`, `, c => c)})` :\n      sql<string>`ON CONSTRAINT ${conflictTarget.value}`,\n    updateColsSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql`, `, c => c),\n    updateValuesSQL = mapWithSeparator(nonUniqueCols.slice().sort(), sql`, `, c =>\n      noNullUpdateCols.includes(c) ? sql`CASE WHEN EXCLUDED.${c} IS NULL THEN ${table}.${c} ELSE EXCLUDED.${c} END` : sql`EXCLUDED.${c}`);\n\n  // the added-on $action = 'INSERT' | 'UPDATE' key takes after SQL Server's approach to MERGE\n  // (and on the use of xmax for this purpose, see: https://stackoverflow.com/questions/39058213/postgresql-upsert-differentiate-inserted-and-updated-rows-using-system-columns-x)\n\n  const query = sql<SQL>`INSERT INTO ${table} (${colsSQL}) VALUES ${valuesSQL} ON CONFLICT ${uniqueColsSQL} DO UPDATE SET (${updateColsSQL}) = ROW(${updateValuesSQL}) RETURNING to_jsonb(${table}.*) || jsonb_build_object('$action', CASE xmax WHEN 0 THEN 'INSERT' ELSE 'UPDATE' END) AS result`;\n\n  query.runResultTransform = Array.isArray(completedValues) ?\n    (qr) => qr.rows.map(r => r.result) :\n    (qr) => qr.rows[0].result;\n\n  return query;\n};\n\n\n/* === update === */\n\ninterface UpdateSignatures {\n  <T extends Table>(table: T, values: UpdatableForTable<T>, where: WhereableForTable<T> | SQLFragment): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport const update: UpdateSignatures = function (\n  table: Table,\n  values: Updatable,\n  where: Whereable | SQLFragment): SQLFragment {\n\n  // note: the ROW() constructor below is required in Postgres 10+ if we're updating a single column\n  // more info: https://www.postgresql-archive.org/Possible-regression-in-UPDATE-SET-lt-column-list-gt-lt-row-expression-gt-with-just-one-single-column0-td5989074.html\n\n  const query = sql<SQL>`UPDATE ${table} SET (${cols(values)}) = ROW(${vals(values)}) WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n  query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n  return query;\n};\n\n\n/* === delete === */\n\nexport interface DeleteSignatures {\n  <T extends Table>(table: T, where: WhereableForTable<T> | SQLFragment): SQLFragment<JSONSelectableForTable<T>[]>;\n}\n\n/**\n * Generate an `DELETE` query `SQLFragment` (sadly, plain 'delete' is a reserved word).\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport const deletes: DeleteSignatures = function\n  (table: Table, where: Whereable | SQLFragment): SQLFragment {\n\n  const query = sql<SQL>`DELETE FROM ${table} WHERE ${where} RETURNING to_jsonb(${table}.*) AS result`;\n  query.runResultTransform = (qr) => qr.rows.map(r => r.result);\n  return query;\n};\n\n\n/* === truncate === */\n\ntype TruncateIdentityOpts = 'CONTINUE IDENTITY' | 'RESTART IDENTITY';\ntype TruncateForeignKeyOpts = 'RESTRICT' | 'CASCADE';\n\ninterface TruncateSignatures {\n  (table: Table | Table[]): SQLFragment<undefined>;\n  (table: Table | Table[], optId: TruncateIdentityOpts): SQLFragment<undefined>;\n  (table: Table | Table[], optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n  (table: Table | Table[], optId: TruncateIdentityOpts, optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n}\n\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or 'RESTRICT'/'CASCADE'\n */\nexport const truncate: TruncateSignatures = function\n  (table: Table | Table[], ...opts: string[]): SQLFragment<undefined> {\n\n  if (!Array.isArray(table)) table = [table];\n  const\n    tables = mapWithSeparator(table, sql`, `, t => t),\n    query = sql<SQL, undefined>`TRUNCATE ${tables}${raw((opts.length ? ' ' : '') + opts.join(' '))}`;\n\n  return query;\n};\n\n\n/* === select === */\n\ninterface OrderSpecForTable<T extends Table> {\n  by: SQLForTable<T>;\n  direction: 'ASC' | 'DESC';\n  nulls?: 'FIRST' | 'LAST';\n}\n\nexport interface SelectOptionsForTable<T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap> {\n  order?: OrderSpecForTable<T>[];\n  limit?: number;\n  offset?: number;\n  columns?: C;\n  extras?: E;\n  lateral?: L;\n  alias?: string;\n}\n\nexport interface SQLFragmentsMap { [k: string]: SQLFragment<any> }\nexport type PromisedType<P> = P extends Promise<infer U> ? U : never;\nexport type PromisedSQLFragmentReturnType<R extends SQLFragment<any>> = PromisedType<ReturnType<R['run']>>;\nexport type PromisedSQLFragmentReturnTypeMap<L extends SQLFragmentsMap> = { [K in keyof L]: PromisedSQLFragmentReturnType<L[K]> };\n\nexport type JSONOnlyColsForTable<T extends Table, C extends any[] /* TS can't manage being more specific here */> = Pick<JSONSelectableForTable<T>, C[number]>;\n\ntype BaseSelectReturnTypeForTable<T extends Table, C extends ColumnForTable<T>[]> = C extends undefined ? JSONSelectableForTable<T> : JSONOnlyColsForTable<T, C>;\n\ntype EnhancedSelectReturnTypeForTable<T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap> =\n  L extends undefined ?\n  (E extends undefined ? BaseSelectReturnTypeForTable<T, C> : BaseSelectReturnTypeForTable<T, C> & PromisedSQLFragmentReturnTypeMap<E>) :\n  (E extends undefined ?\n    BaseSelectReturnTypeForTable<T, C> & PromisedSQLFragmentReturnTypeMap<L> :\n    BaseSelectReturnTypeForTable<T, C> & PromisedSQLFragmentReturnTypeMap<L> & PromisedSQLFragmentReturnTypeMap<E>);\n\nexport type FullSelectReturnTypeForTable<T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap, M extends SelectResultMode> =\n  M extends SelectResultMode.Many ? EnhancedSelectReturnTypeForTable<T, C, L, E>[] :\n  M extends SelectResultMode.One ? EnhancedSelectReturnTypeForTable<T, C, L, E> | undefined : number;\n\nexport enum SelectResultMode { Many, One, Count }\n\nexport interface SelectSignatures {\n  <T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap, M extends SelectResultMode = SelectResultMode.Many>(\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: SelectOptionsForTable<T, C, L, E>,\n    mode?: M,\n  ): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, M>>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other `select`/\n * `selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. Keys (all optional) are: \n * * `columns` — an array of column names: only these columns will be returned\n * * `order` — an array of `OrderSpec` objects, such as `{ by: 'column', direction: 'ASC' \n * }`  \n * * `limit` and `offset` — numbers: apply this limit and offset to the query\n * * `lateral` — an object mapping key(s) to nested `select`/`selectOne`/`count` queries \n * to be `LATERAL JOIN`ed\n * * `alias` — table alias (string): required if using `lateral` to join a table to itself\n * * `extras` — an object mapping key(s) to `SQLFragment`s, so that derived \n * quantities can be included in the JSON result\n * @param mode Used internally by `selectOne` and `count`\n */\nexport const select: SelectSignatures = function (\n  table: Table,\n  where: Whereable | SQLFragment | AllType = all,\n  options: SelectOptionsForTable<Table, ColumnForTable<Table>[], SQLFragmentsMap, SQLFragmentsMap> = {},\n  mode: SelectResultMode = SelectResultMode.Many,\n) {\n\n  const\n    allOptions = mode === SelectResultMode.One ? { ...options, limit: 1 } : options,\n    aliasedTable = allOptions.alias || table,\n    lateralOpt = allOptions.lateral,\n    extrasOpt = allOptions.extras,\n    tableAliasSQL = aliasedTable === table ? [] : sql<string>` AS ${aliasedTable}`,\n    colsSQL = mode === SelectResultMode.Count ?\n      (allOptions.columns ? sql`count(${cols(allOptions.columns)})` : sql<typeof aliasedTable>`count(${aliasedTable}.*)`) :\n      allOptions.columns ?\n        sql`jsonb_build_object(${mapWithSeparator(allOptions.columns, sql`, `, c => sql<SQL>`${param(c)}::text, ${c}`)})` :\n        sql<typeof aliasedTable>`to_jsonb(${aliasedTable}.*)`,\n    colsLateralSQL = lateralOpt === undefined ? [] :\n      sql` || jsonb_build_object(${mapWithSeparator(\n        Object.keys(lateralOpt), sql`, `, (k, i) => sql<SQL>`${param(k)}::text, \"ljoin_${raw(String(i))}\".result`)})`,\n    colsExtraSQL = extrasOpt === undefined ? [] :\n      sql<any[]>` || jsonb_build_object(${mapWithSeparator(\n        Object.keys(extrasOpt), sql`, `, k => sql<SQL>`${param(k)}::text, ${extrasOpt![k]}`)})`,\n    allColsSQL = sql`${colsSQL}${colsLateralSQL}${colsExtraSQL}`,\n    whereSQL = where === all ? [] : sql` WHERE ${where}`,\n    orderSQL = !allOptions.order ? [] :\n      sql` ORDER BY ${mapWithSeparator(allOptions.order, sql`, `, o => {\n        if (!['ASC', 'DESC'].includes(o.direction)) throw new Error(`Direction must be ASC/DESC, not '${o.direction}'`);\n        if (o.nulls && !['FIRST', 'LAST'].includes(o.nulls)) throw new Error(`Nulls must be FIRST/LAST/undefined, not '${o.nulls}'`);\n        return sql`${o.by} ${raw(o.direction)}${o.nulls ? sql` NULLS ${raw(o.nulls)}` : []}`;\n      })}`,\n    limitSQL = allOptions.limit === undefined ? [] : sql` LIMIT ${param(allOptions.limit)}`,\n    offsetSQL = allOptions.offset === undefined ? [] : sql` OFFSET ${param(allOptions.offset)}`,\n    lateralSQL = lateralOpt === undefined ? [] :\n      Object.keys(lateralOpt).map((k, i) => {\n        const subQ = lateralOpt[k];\n        subQ.parentTable = aliasedTable;  // enables `parent('column')` in subquery's Wherables\n        return sql<SQL>` LEFT JOIN LATERAL (${subQ}) AS \"ljoin_${raw(String(i))}\" ON true`;\n      });\n\n  const\n    rowsQuery = sql<SQL, any>`SELECT ${allColsSQL} AS result FROM ${table}${tableAliasSQL}${lateralSQL}${whereSQL}${orderSQL}${limitSQL}${offsetSQL}`,\n    query = mode !== SelectResultMode.Many ? rowsQuery :\n      // we need the aggregate to sit in a sub-SELECT in order to keep ORDER and LIMIT working as usual\n      sql<SQL, any>`SELECT coalesce(jsonb_agg(result), '[]') AS result FROM (${rowsQuery}) AS ${raw(`\"sq_${aliasedTable}\"`)}`;\n\n  query.runResultTransform = mode === SelectResultMode.Count ?\n    // note: pg deliberately returns strings for int8 in case 64-bit numbers overflow\n    // (see https://github.com/brianc/node-pg-types#use), but we assume counts aren't that big\n    (qr) => Number(qr.rows[0].result) :\n    (qr) => qr.rows[0]?.result;\n\n  return query;\n};\n\n\n/* === selectOne === */\n\nexport interface SelectOneSignatures {\n  <T extends Table, C extends ColumnForTable<T>[], L extends SQLFragmentsMap, E extends SQLFragmentsMap>(\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: SelectOptionsForTable<T, C, L, E>,\n  ): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.One>>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or \n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with other \n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected, or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport const selectOne: SelectOneSignatures = function (\n  table: any,\n  where: any,\n  options: any = {},\n) {\n  // you might argue that 'selectOne' offers little that you can't get with destructuring assignment \n  // and plain 'select' -- e.g. let [x] = async select(...).run(pool); -- but a thing that is definitely worth \n  // having is '| undefined' in the return signature, because the result of indexing never includes undefined\n  // (see e.g. https://github.com/Microsoft/TypeScript/issues/13778)\n\n  return select(table, where, options, SelectResultMode.One);\n};\n\n\n/* === count === */\n\nexport interface CountSignatures {\n  <T extends Table>(\n    table: T,\n    where: WhereableForTable<T> | SQLFragment | AllType,\n    options?: { columns?: ColumnForTable<T>[]; alias?: string },\n  ): SQLFragment<number>;\n}\n\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be nested in \n * other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted, or `all`\n * @param options Options object. Keys are: `columns`, `alias`.\n */\nexport const count: CountSignatures = function (\n  table: any,\n  where: any,\n  options?: any,\n) {\n\n  return select(table, where, options, SelectResultMode.Count);\n};\n","zapatos/src/transaction.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nimport { isDatabaseError } from './pgErrors';\nimport { wait } from './utils';\nimport { sql, raw } from './core';\nimport { getConfig } from \"./config\";\nexport var Isolation;\n(function (Isolation) {\n    // these are the only meaningful values in Postgres: \n    // see https://www.postgresql.org/docs/11/sql-set-transaction.html\n    Isolation[\"Serializable\"] = \"SERIALIZABLE\";\n    Isolation[\"RepeatableRead\"] = \"REPEATABLE READ\";\n    Isolation[\"ReadCommitted\"] = \"READ COMMITTED\";\n    Isolation[\"SerializableRO\"] = \"SERIALIZABLE, READ ONLY\";\n    Isolation[\"RepeatableReadRO\"] = \"REPEATABLE READ, READ ONLY\";\n    Isolation[\"ReadCommittedRO\"] = \"READ COMMITTED, READ ONLY\";\n    Isolation[\"SerializableRODeferrable\"] = \"SERIALIZABLE, READ ONLY, DEFERRABLE\";\n})(Isolation || (Isolation = {}));\nlet txnSeq = 0;\n/**\n * Provide a database client to the callback, whose queries are then wrapped in a\n * database transaction. The transaction is committed, retried, or rolled back as\n * appropriate.\n * @param pool The `pg.Pool` from which to check out the database client\n * @param isolationMode The `Isolation` mode (e.g `Serializable`)\n * @param callback The callback function that runs queries on the provided client\n */\nexport async function transaction(pool, isolationMode, callback) {\n    const txnId = txnSeq++, txnClient = await pool.connect(), config = getConfig(), { transactionListener } = config, maxAttempts = config.transactionAttemptsMax, { minMs, maxMs } = config.transactionRetryDelay;\n    try {\n        for (let attempt = 1;; attempt++) {\n            try {\n                if (attempt > 1 && transactionListener)\n                    transactionListener(`Retrying transaction #${txnId}, attempt ${attempt} of ${maxAttempts}`);\n                await sql `START TRANSACTION ISOLATION LEVEL ${raw(isolationMode)}`.run(txnClient);\n                const result = await callback(txnClient);\n                await sql `COMMIT`.run(txnClient);\n                return result;\n            }\n            catch (err) {\n                await sql `ROLLBACK`.run(txnClient);\n                // on trapping the following two rollback error codes, see:\n                // https://www.postgresql.org/message-id/1368066680.60649.YahooMailNeo@web162902.mail.bf1.yahoo.com\n                // this is also a good read:\n                // https://www.enterprisedb.com/blog/serializable-postgresql-11-and-beyond\n                if (isDatabaseError(err, \"TransactionRollback_SerializationFailure\", \"TransactionRollback_DeadlockDetected\")) {\n                    if (attempt < maxAttempts) {\n                        const delayBeforeRetry = Math.round(minMs + (maxMs - minMs) * Math.random());\n                        if (transactionListener)\n                            transactionListener(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, retrying in ${delayBeforeRetry}ms`);\n                        await wait(delayBeforeRetry);\n                    }\n                    else {\n                        if (transactionListener)\n                            transactionListener(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, giving up`);\n                        throw err;\n                    }\n                }\n                else {\n                    throw err;\n                }\n            }\n        }\n    }\n    finally {\n        txnClient.release();\n    }\n}\n","zapatos/src/transaction.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport type * as pg from 'pg';\nimport { isDatabaseError } from './pgErrors';\nimport { wait } from './utils';\nimport { sql, raw } from './core';\nimport { getConfig } from \"./config\";\n\n\nexport enum Isolation {\n  // these are the only meaningful values in Postgres: \n  // see https://www.postgresql.org/docs/11/sql-set-transaction.html\n  Serializable = \"SERIALIZABLE\",\n  RepeatableRead = \"REPEATABLE READ\",\n  ReadCommitted = \"READ COMMITTED\",\n  SerializableRO = \"SERIALIZABLE, READ ONLY\",\n  RepeatableReadRO = \"REPEATABLE READ, READ ONLY\",\n  ReadCommittedRO = \"READ COMMITTED, READ ONLY\",\n  SerializableRODeferrable = \"SERIALIZABLE, READ ONLY, DEFERRABLE\"\n}\n\nexport namespace TxnSatisfying {\n  export type Serializable = Isolation.Serializable;\n  export type RepeatableRead = Serializable | Isolation.RepeatableRead;\n  export type ReadCommitted = RepeatableRead | Isolation.ReadCommitted;\n  export type SerializableRO = Serializable | Isolation.SerializableRO;\n  export type RepeatableReadRO = SerializableRO | RepeatableRead | Isolation.RepeatableReadRO;\n  export type ReadCommittedRO = RepeatableReadRO | ReadCommitted | Isolation.ReadCommittedRO;\n  export type SerializableRODeferrable = SerializableRO | Isolation.SerializableRODeferrable;\n}\n\nexport interface TxnClient<T extends Isolation> extends pg.PoolClient { }\n\nlet txnSeq = 0;\n\n/**\n * Provide a database client to the callback, whose queries are then wrapped in a \n * database transaction. The transaction is committed, retried, or rolled back as \n * appropriate. \n * @param pool The `pg.Pool` from which to check out the database client\n * @param isolationMode The `Isolation` mode (e.g `Serializable`) \n * @param callback The callback function that runs queries on the provided client\n */\nexport async function transaction<T, M extends Isolation>(\n  pool: pg.Pool,\n  isolationMode: M,\n  callback: (client: TxnClient<M>) => Promise<T>\n): Promise<T> {\n\n  const\n    txnId = txnSeq++,\n    txnClient = await pool.connect() as TxnClient<typeof isolationMode>,\n    config = getConfig(),\n    { transactionListener } = config,\n    maxAttempts = config.transactionAttemptsMax,\n    { minMs, maxMs } = config.transactionRetryDelay;\n\n  try {\n    for (let attempt = 1; ; attempt++) {\n      try {\n        if (attempt > 1 && transactionListener) transactionListener(`Retrying transaction #${txnId}, attempt ${attempt} of ${maxAttempts}`);\n\n        await sql`START TRANSACTION ISOLATION LEVEL ${raw(isolationMode)}`.run(txnClient);\n        const result = await callback(txnClient);\n        await sql`COMMIT`.run(txnClient);\n\n        return result;\n\n      } catch (err) {\n        await sql`ROLLBACK`.run(txnClient);\n\n        // on trapping the following two rollback error codes, see:\n        // https://www.postgresql.org/message-id/1368066680.60649.YahooMailNeo@web162902.mail.bf1.yahoo.com\n        // this is also a good read:\n        // https://www.enterprisedb.com/blog/serializable-postgresql-11-and-beyond\n\n        if (isDatabaseError(err, \"TransactionRollback_SerializationFailure\", \"TransactionRollback_DeadlockDetected\")) {\n          if (attempt < maxAttempts) {\n            const delayBeforeRetry = Math.round(minMs + (maxMs - minMs) * Math.random());\n            if (transactionListener) transactionListener(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, retrying in ${delayBeforeRetry}ms`);\n            await wait(delayBeforeRetry);\n\n          } else {\n            if (transactionListener) transactionListener(`Transaction #${txnId} rollback (code ${err.code}) on attempt ${attempt} of ${maxAttempts}, giving up`);\n            throw err;\n          }\n\n        } else {\n          throw err;\n        }\n      }\n    }\n\n  } finally {\n    txnClient.release();\n  }\n}\n","zapatos/src/utils.js":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\nimport { Default } from './core';\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport const wait = (delayMs) => new Promise(resolve => setTimeout(resolve, delayMs));\n/**\n * Map an input array to an output array, interspersing a constant separator value\n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport const mapWithSeparator = (arr, separator, cb) => {\n    const result = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n        if (i > 0)\n            result.push(separator);\n        result.push(cb(arr[i], i, arr));\n    }\n    return result;\n};\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets the value Default.\n *\n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: Default }, { x: Default, y: 2}]`\n * @param objs The array of objects\n */\nexport const completeKeysWithDefault = (objs) => {\n    const unionKeys = Object.assign({}, ...objs);\n    for (const k in unionKeys)\n        unionKeys[k] = Default;\n    return objs.map(o => (Object.assign(Object.assign({}, unionKeys), o)));\n};\n","zapatos/src/utils.ts":"/*\n** DON'T EDIT THIS FILE (unless you're working on Zapatos) **\nIt's part of Zapatos, and will be overwritten when the database schema is regenerated\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\nimport { Default } from './core';\n\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport const wait = (delayMs: number) => new Promise(resolve => setTimeout(resolve, delayMs));\n\n/**\n * Map an input array to an output array, interspersing a constant separator value \n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport const mapWithSeparator = <TIn, TSep, TOut>(\n  arr: TIn[],\n  separator: TSep,\n  cb: (x: TIn, i: number, a: typeof arr) => TOut\n): (TOut | TSep)[] => {\n\n  const result: (TOut | TSep)[] = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (i > 0) result.push(separator);\n    result.push(cb(arr[i], i, arr));\n  }\n  return result;\n};\n\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets the value Default. \n * \n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: Default }, { x: Default, y: 2}]`\n * @param objs The array of objects\n */\nexport const completeKeysWithDefault = <T extends object>(objs: T[]): T[] => {\n  const unionKeys = Object.assign({}, ...objs);\n  for (const k in unionKeys) unionKeys[k] = Default;\n  return objs.map(o => ({ ...unionKeys, ...o }));\n};\n","pg.ts":"\n      export class Pool {}\n      export class PoolClient {}\n      export class QueryResult {\n        rows: any;\n      }","pgPool.ts":"\n      import * as pg from 'pg';\n      export default new pg.Pool();","zapatos/src.ts":"\n      export * from './src/index';"};