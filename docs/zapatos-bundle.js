const zapatosBundle = {"custom/PgGeometry.d.ts":"/*\n** Please edit this file as needed **\nIt's been generated by Zapatos as a custom type definition placeholder, and won't be overwritten\n*/\n\ndeclare module 'zapatos/custom' {\n  export type PgGeometry = any;  // replace with your custom type or interface as desired\n}\n","custom/index.d.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos (v4.0.1), and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 - 2021 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\n// this empty declaration appears to fix relative imports in other custom type files\ndeclare module 'zapatos/custom' { }\n","schema.d.ts":"/*\n** DON'T EDIT THIS FILE **\nIt's been generated by Zapatos (v4.0.1), and is liable to be overwritten\n\nZapatos: https://jawj.github.io/zapatos/\nCopyright (C) 2020 - 2021 George MacKerron\nReleased under the MIT licence: see LICENCE file\n*/\n\ndeclare module 'zapatos/schema' {\n\n  import type * as db from 'zapatos/db';\n  import type * as c from 'zapatos/custom';\n\n  // got a type error on schemaVersionCanary below? update by running `npx zapatos`\n  export interface schemaVersionCanary extends db.SchemaVersionCanary { version: 102 }\n\n  /* === schema: public === */\n\n  /* --- enums --- */\n\n  export type appleEnvironment = 'PROD' | 'Sandbox';\n  export namespace every {\n    export type appleEnvironment = ['PROD', 'Sandbox'];\n  }\n\n  /* --- tables --- */\n\n  export namespace appleTransactions {\n    export type Table = 'appleTransactions';\n    export interface Selectable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment: appleEnvironment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId: string;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId: number;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData: string | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment: appleEnvironment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId: string;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId: number;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData: string | null;\n    }\n    export interface Whereable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment?: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **appleTransactions.environment**\n      * - `appleEnvironment` in database\n      * - `NOT NULL`, no default\n      */\n      environment?: appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment | db.SQLFragment<any, appleEnvironment | db.Parameter<appleEnvironment> | db.SQLFragment>;\n      /**\n      * **appleTransactions.originalTransactionId**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      originalTransactionId?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **appleTransactions.accountId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      accountId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **appleTransactions.latestReceiptData**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      latestReceiptData?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'appleTransactionsPrimaryKey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace arrays {\n    export type Table = 'arrays';\n    export interface Selectable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue: db.JSONValue | null;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray: string[] | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue: db.JSONValue | null;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray: string[] | null;\n    }\n    export interface Whereable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string[] | db.Parameter<string[]> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **arrays.jsonValue**\n      * - `jsonb` in database\n      * - Nullable, no default\n      */\n      jsonValue?: db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, db.JSONValue | db.Parameter<db.JSONValue> | null | db.DefaultType | db.SQLFragment>;\n      /**\n      * **arrays.textArray**\n      * - `_text` in database\n      * - Nullable, no default\n      */\n      textArray?: string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string[] | db.Parameter<string[]> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = never;\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace authors {\n    export type Table = 'authors';\n    export interface Selectable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving: boolean | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving: boolean | null;\n    }\n    export interface Whereable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, boolean | db.Parameter<boolean> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **authors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('authors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **authors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **authors.isLiving**\n      * - `bool` in database\n      * - Nullable, no default\n      */\n      isLiving?: boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, boolean | db.Parameter<boolean> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'authors_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace bankAccounts {\n    export type Table = 'bankAccounts';\n    export interface Selectable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id: number;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id: number;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance: number;\n    }\n    export interface Whereable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **bankAccounts.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('\"bankAccounts_id_seq\"'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **bankAccounts.balance**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      balance?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'bankAccounts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace books {\n    export type Table = 'books';\n    export interface Selectable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId: number;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title: string | null;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt: Date;\n    }\n    export interface JSONSelectable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId: number;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title: string | null;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt: db.TimestampTzString;\n    }\n    export interface Whereable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **books.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('books_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **books.authorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      authorId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **books.title**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      title?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n      /**\n      * **books.createdAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      createdAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'books_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace doctors {\n    export type Table = 'doctors';\n    export interface Selectable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface Whereable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **doctors.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('doctors_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **doctors.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'doctors_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace emailAuthentication {\n    export type Table = 'emailAuthentication';\n    export interface Selectable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email: string;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins: number;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin: Date | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email: string;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins: number;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin: db.TimestampTzString | null;\n    }\n    export interface Whereable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **emailAuthentication.email**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      email?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **emailAuthentication.consecutiveFailedLogins**\n      * - `int4` in database\n      * - `NOT NULL`, default: `0`\n      */\n      consecutiveFailedLogins?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **emailAuthentication.lastFailedLogin**\n      * - `timestamptz` in database\n      * - Nullable, no default\n      */\n      lastFailedLogin?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'emailAuthentication_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace employees {\n    export type Table = 'employees';\n    export interface Selectable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId: number | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId: number | null;\n    }\n    export interface Whereable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **employees.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('employees_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **employees.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **employees.managerId**\n      * - `int4` in database\n      * - Nullable, no default\n      */\n      managerId?: number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'employees_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace nameCounts {\n    export type Table = 'nameCounts';\n    export interface Selectable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count: number;\n    }\n    export interface Whereable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **nameCounts.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **nameCounts.count**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      count?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'nameCounts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace photos {\n    export type Table = 'photos';\n    export interface Selectable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId: number;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId: number;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url: string;\n    }\n    export interface Whereable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **photos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      photoId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **photos.url**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      url?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'photos_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace shifts {\n    export type Table = 'shifts';\n    export interface Selectable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day: Date;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day: db.DateString;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId: number;\n    }\n    export interface Whereable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day?: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **shifts.day**\n      * - `date` in database\n      * - `NOT NULL`, no default\n      */\n      day?: (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment | db.SQLFragment<any, (db.DateString | Date) | db.Parameter<(db.DateString | Date)> | db.SQLFragment>;\n      /**\n      * **shifts.doctorId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      doctorId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'shifts_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace stores {\n    export type Table = 'stores';\n    export interface Selectable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom: c.PgGeometry;\n    }\n    export interface JSONSelectable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id: number;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom: c.PgGeometry;\n    }\n    export interface Whereable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom?: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **stores.id**\n      * - `int4` in database\n      * - `NOT NULL`, default: `nextval('stores_id_seq'::regclass)`\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **stores.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **stores.geom**\n      * - `geometry` in database\n      * - `NOT NULL`, no default\n      */\n      geom?: c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment | db.SQLFragment<any, c.PgGeometry | db.Parameter<c.PgGeometry> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'stores_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace subjectPhotos {\n    export type Table = 'subjectPhotos';\n    export interface Selectable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId: number;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId: number;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId: number;\n    }\n    export interface Whereable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId: number | db.Parameter<number> | db.SQLFragment;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **subjectPhotos.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n      /**\n      * **subjectPhotos.photoId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      photoId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'userphotosunique';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace subjects {\n    export type Table = 'subjects';\n    export interface Selectable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId: number;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface JSONSelectable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId: number;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string;\n    }\n    export interface Whereable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name: string | db.Parameter<string> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **subjects.subjectId**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      subjectId?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **subjects.name**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      name?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'subjects_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace tags {\n    export type Table = 'tags';\n    export interface Selectable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag: string;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId: number;\n    }\n    export interface JSONSelectable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag: string;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId: number;\n    }\n    export interface Whereable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId: number | db.Parameter<number> | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **tags.tag**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      tag?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **tags.bookId**\n      * - `int4` in database\n      * - `NOT NULL`, no default\n      */\n      bookId?: number | db.Parameter<number> | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'tagsUniqueIdx';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace usedVoucherCodes {\n    export type Table = 'usedVoucherCodes';\n    export interface Selectable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code: string;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt: Date;\n    }\n    export interface JSONSelectable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code: string;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt: db.TimestampTzString;\n    }\n    export interface Whereable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code: string | db.Parameter<string> | db.SQLFragment;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **usedVoucherCodes.code**\n      * - `text` in database\n      * - `NOT NULL`, no default\n      */\n      code?: string | db.Parameter<string> | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment>;\n      /**\n      * **usedVoucherCodes.redeemedAt**\n      * - `timestamptz` in database\n      * - `NOT NULL`, default: `now()`\n      */\n      redeemedAt?: (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, (db.TimestampTzString | Date) | db.Parameter<(db.TimestampTzString | Date)> | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'usedVoucherCodes_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  export namespace users {\n    export type Table = 'users';\n    export interface Selectable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id: number;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet: number;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName: string | null;\n    }\n    export interface JSONSelectable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id: number;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet: number;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName: string | null;\n    }\n    export interface Whereable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, number | db.Parameter<number> | db.SQLFragment | db.ParentColumn>;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | db.SQLFragment | db.ParentColumn | db.SQLFragment<any, string | db.Parameter<string> | db.SQLFragment | db.ParentColumn>;\n    }\n    export interface Insertable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment;\n    }\n    export interface Updatable {\n      /**\n      * **users.id**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      id?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **users.ipOctet**\n      * - `int4` in database\n      * - `NOT NULL`, identity column\n      */\n      ipOctet?: number | db.Parameter<number> | db.DefaultType | db.SQLFragment | db.SQLFragment<any, number | db.Parameter<number> | db.DefaultType | db.SQLFragment>;\n      /**\n      * **users.friendlyName**\n      * - `text` in database\n      * - Nullable, no default\n      */\n      friendlyName?: string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment | db.SQLFragment<any, string | db.Parameter<string> | null | db.DefaultType | db.SQLFragment>;\n    }\n    export type UniqueIndex = 'users_ipOctet_key' | 'users_pkey';\n    export type Column = keyof Selectable;\n    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;\n    export type SQLExpression = db.GenericSQLExpression | db.ColumnNames<Updatable | (keyof Updatable)[]> | db.ColumnValues<Updatable> | Table | Whereable | Column;\n    export type SQL = SQLExpression | SQLExpression[];\n  }\n\n  /* === cross-table types === */\n\n  export type Table = appleTransactions.Table | arrays.Table | authors.Table | bankAccounts.Table | books.Table | doctors.Table | emailAuthentication.Table | employees.Table | nameCounts.Table | photos.Table | shifts.Table | stores.Table | subjectPhotos.Table | subjects.Table | tags.Table | usedVoucherCodes.Table | users.Table;\n  export type Selectable = appleTransactions.Selectable | arrays.Selectable | authors.Selectable | bankAccounts.Selectable | books.Selectable | doctors.Selectable | emailAuthentication.Selectable | employees.Selectable | nameCounts.Selectable | photos.Selectable | shifts.Selectable | stores.Selectable | subjectPhotos.Selectable | subjects.Selectable | tags.Selectable | usedVoucherCodes.Selectable | users.Selectable;\n  export type JSONSelectable = appleTransactions.JSONSelectable | arrays.JSONSelectable | authors.JSONSelectable | bankAccounts.JSONSelectable | books.JSONSelectable | doctors.JSONSelectable | emailAuthentication.JSONSelectable | employees.JSONSelectable | nameCounts.JSONSelectable | photos.JSONSelectable | shifts.JSONSelectable | stores.JSONSelectable | subjectPhotos.JSONSelectable | subjects.JSONSelectable | tags.JSONSelectable | usedVoucherCodes.JSONSelectable | users.JSONSelectable;\n  export type Whereable = appleTransactions.Whereable | arrays.Whereable | authors.Whereable | bankAccounts.Whereable | books.Whereable | doctors.Whereable | emailAuthentication.Whereable | employees.Whereable | nameCounts.Whereable | photos.Whereable | shifts.Whereable | stores.Whereable | subjectPhotos.Whereable | subjects.Whereable | tags.Whereable | usedVoucherCodes.Whereable | users.Whereable;\n  export type Insertable = appleTransactions.Insertable | arrays.Insertable | authors.Insertable | bankAccounts.Insertable | books.Insertable | doctors.Insertable | emailAuthentication.Insertable | employees.Insertable | nameCounts.Insertable | photos.Insertable | shifts.Insertable | stores.Insertable | subjectPhotos.Insertable | subjects.Insertable | tags.Insertable | usedVoucherCodes.Insertable | users.Insertable;\n  export type Updatable = appleTransactions.Updatable | arrays.Updatable | authors.Updatable | bankAccounts.Updatable | books.Updatable | doctors.Updatable | emailAuthentication.Updatable | employees.Updatable | nameCounts.Updatable | photos.Updatable | shifts.Updatable | stores.Updatable | subjectPhotos.Updatable | subjects.Updatable | tags.Updatable | usedVoucherCodes.Updatable | users.Updatable;\n  export type UniqueIndex = appleTransactions.UniqueIndex | arrays.UniqueIndex | authors.UniqueIndex | bankAccounts.UniqueIndex | books.UniqueIndex | doctors.UniqueIndex | emailAuthentication.UniqueIndex | employees.UniqueIndex | nameCounts.UniqueIndex | photos.UniqueIndex | shifts.UniqueIndex | stores.UniqueIndex | subjectPhotos.UniqueIndex | subjects.UniqueIndex | tags.UniqueIndex | usedVoucherCodes.UniqueIndex | users.UniqueIndex;\n  export type Column = appleTransactions.Column | arrays.Column | authors.Column | bankAccounts.Column | books.Column | doctors.Column | emailAuthentication.Column | employees.Column | nameCounts.Column | photos.Column | shifts.Column | stores.Column | subjectPhotos.Column | subjects.Column | tags.Column | usedVoucherCodes.Column | users.Column;\n  export type AllTables = [appleTransactions.Table, arrays.Table, authors.Table, bankAccounts.Table, books.Table, doctors.Table, emailAuthentication.Table, employees.Table, nameCounts.Table, photos.Table, shifts.Table, stores.Table, subjectPhotos.Table, subjects.Table, tags.Table, usedVoucherCodes.Table, users.Table];\n  export type AllMaterializedViews = [];\n\n\n  export type SelectableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Selectable;\n    arrays: arrays.Selectable;\n    authors: authors.Selectable;\n    bankAccounts: bankAccounts.Selectable;\n    books: books.Selectable;\n    doctors: doctors.Selectable;\n    emailAuthentication: emailAuthentication.Selectable;\n    employees: employees.Selectable;\n    nameCounts: nameCounts.Selectable;\n    photos: photos.Selectable;\n    shifts: shifts.Selectable;\n    stores: stores.Selectable;\n    subjectPhotos: subjectPhotos.Selectable;\n    subjects: subjects.Selectable;\n    tags: tags.Selectable;\n    usedVoucherCodes: usedVoucherCodes.Selectable;\n    users: users.Selectable;\n  }[T];\n\n  export type JSONSelectableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.JSONSelectable;\n    arrays: arrays.JSONSelectable;\n    authors: authors.JSONSelectable;\n    bankAccounts: bankAccounts.JSONSelectable;\n    books: books.JSONSelectable;\n    doctors: doctors.JSONSelectable;\n    emailAuthentication: emailAuthentication.JSONSelectable;\n    employees: employees.JSONSelectable;\n    nameCounts: nameCounts.JSONSelectable;\n    photos: photos.JSONSelectable;\n    shifts: shifts.JSONSelectable;\n    stores: stores.JSONSelectable;\n    subjectPhotos: subjectPhotos.JSONSelectable;\n    subjects: subjects.JSONSelectable;\n    tags: tags.JSONSelectable;\n    usedVoucherCodes: usedVoucherCodes.JSONSelectable;\n    users: users.JSONSelectable;\n  }[T];\n\n  export type WhereableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Whereable;\n    arrays: arrays.Whereable;\n    authors: authors.Whereable;\n    bankAccounts: bankAccounts.Whereable;\n    books: books.Whereable;\n    doctors: doctors.Whereable;\n    emailAuthentication: emailAuthentication.Whereable;\n    employees: employees.Whereable;\n    nameCounts: nameCounts.Whereable;\n    photos: photos.Whereable;\n    shifts: shifts.Whereable;\n    stores: stores.Whereable;\n    subjectPhotos: subjectPhotos.Whereable;\n    subjects: subjects.Whereable;\n    tags: tags.Whereable;\n    usedVoucherCodes: usedVoucherCodes.Whereable;\n    users: users.Whereable;\n  }[T];\n\n  export type InsertableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Insertable;\n    arrays: arrays.Insertable;\n    authors: authors.Insertable;\n    bankAccounts: bankAccounts.Insertable;\n    books: books.Insertable;\n    doctors: doctors.Insertable;\n    emailAuthentication: emailAuthentication.Insertable;\n    employees: employees.Insertable;\n    nameCounts: nameCounts.Insertable;\n    photos: photos.Insertable;\n    shifts: shifts.Insertable;\n    stores: stores.Insertable;\n    subjectPhotos: subjectPhotos.Insertable;\n    subjects: subjects.Insertable;\n    tags: tags.Insertable;\n    usedVoucherCodes: usedVoucherCodes.Insertable;\n    users: users.Insertable;\n  }[T];\n\n  export type UpdatableForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Updatable;\n    arrays: arrays.Updatable;\n    authors: authors.Updatable;\n    bankAccounts: bankAccounts.Updatable;\n    books: books.Updatable;\n    doctors: doctors.Updatable;\n    emailAuthentication: emailAuthentication.Updatable;\n    employees: employees.Updatable;\n    nameCounts: nameCounts.Updatable;\n    photos: photos.Updatable;\n    shifts: shifts.Updatable;\n    stores: stores.Updatable;\n    subjectPhotos: subjectPhotos.Updatable;\n    subjects: subjects.Updatable;\n    tags: tags.Updatable;\n    usedVoucherCodes: usedVoucherCodes.Updatable;\n    users: users.Updatable;\n  }[T];\n\n  export type UniqueIndexForTable<T extends Table> = {\n    appleTransactions: appleTransactions.UniqueIndex;\n    arrays: arrays.UniqueIndex;\n    authors: authors.UniqueIndex;\n    bankAccounts: bankAccounts.UniqueIndex;\n    books: books.UniqueIndex;\n    doctors: doctors.UniqueIndex;\n    emailAuthentication: emailAuthentication.UniqueIndex;\n    employees: employees.UniqueIndex;\n    nameCounts: nameCounts.UniqueIndex;\n    photos: photos.UniqueIndex;\n    shifts: shifts.UniqueIndex;\n    stores: stores.UniqueIndex;\n    subjectPhotos: subjectPhotos.UniqueIndex;\n    subjects: subjects.UniqueIndex;\n    tags: tags.UniqueIndex;\n    usedVoucherCodes: usedVoucherCodes.UniqueIndex;\n    users: users.UniqueIndex;\n  }[T];\n\n  export type ColumnForTable<T extends Table> = {\n    appleTransactions: appleTransactions.Column;\n    arrays: arrays.Column;\n    authors: authors.Column;\n    bankAccounts: bankAccounts.Column;\n    books: books.Column;\n    doctors: doctors.Column;\n    emailAuthentication: emailAuthentication.Column;\n    employees: employees.Column;\n    nameCounts: nameCounts.Column;\n    photos: photos.Column;\n    shifts: shifts.Column;\n    stores: stores.Column;\n    subjectPhotos: subjectPhotos.Column;\n    subjects: subjects.Column;\n    tags: tags.Column;\n    usedVoucherCodes: usedVoucherCodes.Column;\n    users: users.Column;\n  }[T];\n\n  export type SQLForTable<T extends Table> = {\n    appleTransactions: appleTransactions.SQL;\n    arrays: arrays.SQL;\n    authors: authors.SQL;\n    bankAccounts: bankAccounts.SQL;\n    books: books.SQL;\n    doctors: doctors.SQL;\n    emailAuthentication: emailAuthentication.SQL;\n    employees: employees.SQL;\n    nameCounts: nameCounts.SQL;\n    photos: photos.SQL;\n    shifts: shifts.SQL;\n    stores: stores.SQL;\n    subjectPhotos: subjectPhotos.SQL;\n    subjects: subjects.SQL;\n    tags: tags.SQL;\n    usedVoucherCodes: usedVoucherCodes.SQL;\n    users: users.SQL;\n  }[T];\n\n}\n","node_modules/@types/zapatos/db/canary.d.ts":"/**\n * This value gets incremented whenever there's an incompatible change to the\n * generated schema format, in order to raise a type error and thereby force\n * schema regeneration.\n */\nexport interface SchemaVersionCanary {\n    version: 102;\n}\n","node_modules/@types/zapatos/db/conditions.d.ts":"import { SQLFragment } from './core';\nexport declare const isNull: SQLFragment<boolean, never>;\nexport declare const isNotNull: SQLFragment<boolean, never>;\nexport declare const isTrue: SQLFragment<boolean, never>;\nexport declare const isNotTrue: SQLFragment<boolean, never>;\nexport declare const isFalse: SQLFragment<boolean, never>;\nexport declare const isNotFalse: SQLFragment<boolean, never>;\nexport declare const isUnknown: SQLFragment<boolean, never>;\nexport declare const isNotUnknown: SQLFragment<boolean, never>;\nexport declare const isDistinctFrom: <T>(a: T) => SQLFragment<boolean, T>;\nexport declare const isNotDistinctFrom: <T>(a: T) => SQLFragment<boolean, T>;\nexport declare const eq: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const ne: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const gt: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const gte: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const lt: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const lte: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const between: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const betweenSymmetric: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const notBetween: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const notBetweenSymmetric: <T>(a: T, b: T) => SQLFragment<boolean | null, T>;\nexport declare const like: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notLike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const ilike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notIlike: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const similarTo: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notSimilarTo: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const reMatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const reImatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notReMatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const notReImatch: <T extends string>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const isIn: <T>(a: readonly T[]) => SQLFragment<boolean | null, T> | SQLFragment<any[], never>;\nexport declare const isNotIn: <T>(a: readonly T[]) => SQLFragment<any[], never> | SQLFragment<boolean | null, T>;\nexport declare const or: <T>(...conditions: SQLFragment<any, T>[]) => SQLFragment<boolean | null, T>;\nexport declare const and: <T>(...conditions: SQLFragment<any, T>[]) => SQLFragment<boolean | null, T>;\nexport declare const not: <T>(condition: SQLFragment<any, T>) => SQLFragment<boolean | null, T>;\ndeclare type IntervalUnit = 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year' | 'decade' | 'century' | 'millennium';\nexport declare const fromNow: (n: number, unit?: IntervalUnit) => SQLFragment<any[], never>;\nexport declare const after: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const before: <T>(a: T) => SQLFragment<boolean | null, T>;\nexport declare const add: <T extends number | Date>(a: T) => SQLFragment<number, T>;\nexport declare const subtract: <T extends number | Date>(a: T) => SQLFragment<number, T>;\nexport {};\n","node_modules/@types/zapatos/db/config.d.ts":"export interface SQLQuery {\n    text: string;\n    values: any[];\n    name?: string;\n}\nexport interface Config {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?(query: SQLQuery, txnId?: number): void;\n    resultListener?(result: any, txnId?: number, elapsedMs?: number): void;\n    transactionListener?(message: string, txnId?: number): void;\n}\nexport declare type NewConfig = Partial<Config>;\n/**\n * Get (a copy of) the current configuration.\n */\nexport declare const getConfig: () => {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?(query: SQLQuery, txnId?: number | undefined): void;\n    resultListener?(result: any, txnId?: number | undefined, elapsedMs?: number | undefined): void;\n    transactionListener?(message: string, txnId?: number | undefined): void;\n};\n/**\n * Set key(s) on the configuration.\n * @param newConfig Partial configuration object\n */\nexport declare const setConfig: (newConfig: NewConfig) => {\n    transactionAttemptsMax: number;\n    transactionRetryDelay: {\n        minMs: number;\n        maxMs: number;\n    };\n    castArrayParamsToJson: boolean;\n    castObjectParamsToJson: boolean;\n    queryListener?: ((query: SQLQuery, txnId?: number | undefined) => void) | undefined;\n    resultListener?: ((result: any, txnId?: number | undefined, elapsedMs?: number | undefined) => void) | undefined;\n    transactionListener?: ((message: string, txnId?: number | undefined) => void) | undefined;\n};\n","node_modules/@types/zapatos/db/core.d.ts":"/// <reference types=\"node\" />\nimport type * as pg from 'pg';\nimport { SQLQuery } from './config';\nimport { NoInfer } from './utils';\nimport type { Updatable, Whereable, Table, Column } from 'zapatos/schema';\n/**\n * Compiles to `DEFAULT` for use in `INSERT`/`UPDATE` queries.\n */\nexport declare const Default: unique symbol;\nexport declare type DefaultType = typeof Default;\n/**\n * Compiles to the current column name within a `Whereable`.\n */\nexport declare const self: unique symbol;\nexport declare type SelfType = typeof self;\n/**\n * Signals all rows are to be returned (without filtering via a `WHERE` clause)\n */\nexport declare const all: unique symbol;\nexport declare type AllType = typeof all;\n/**\n * JSON types\n */\nexport declare type JSONValue = null | boolean | number | string | JSONObject | JSONArray;\nexport declare type JSONObject = {\n    [k: string]: JSONValue;\n};\nexport declare type JSONArray = JSONValue[];\n/**\n * `int8` value represented as a string\n */\nexport declare type Int8String = `${number}`;\n/**\n * Generic range value represented as a string\n */\nexport declare type RangeString<Bound extends string | number> = `${'[' | '('}${Bound},${Bound}${']' | ')'}`;\n/**\n * `tsrange`, `tstzrange` or `daterange` value represented as a string. The\n * format of the upper and lower bound `date`, `timestamp` or `timestamptz`\n * values depends on pg's `DateStyle` setting.\n */\nexport declare type DateRangeString = RangeString<string>;\n/**\n * `int4range`, `int8range` or `numrange` value represented as a string\n */\nexport declare type NumberRangeString = RangeString<number | ''>;\n/**\n * `bytea` value representated as a hex string. Note: for large objects, use\n * something like https://www.npmjs.com/package/pg-large-object instead.\n */\nexport declare type ByteArrayString = `\\\\x${string}`;\n/**\n * Make a function `STRICT` in the Postgres sense  where it's an alias for\n * `RETURNS NULL ON NULL INPUT`  with appropriate typing.\n *\n * For example, Zapatos' `toBuffer()` function is defined as:\n *\n * ```\n * export const toBuffer = strict((ba: ByteArrayString) => Buffer.from(ba.slice(2), 'hex'));\n * ```\n *\n * The generic input and output types `FnIn` and `FnOut` can be inferred from\n * `fn`, as seen above, but can also be explicitly narrowed. For example, to\n * convert specifically from `TimestampTzString` to Luxon's `DateTime`, but\n * pass through `null`s unchanged:\n *\n * ```\n * const toDateTime = db.strict<db.TimestampTzString, DateTime>(DateTime.fromISO);\n * ```\n *\n * @param fn The single-argument transformation function to be made strict.\n */\nexport declare function strict<FnIn, FnOut>(fn: (x: FnIn) => FnOut): <T extends FnIn | null>(d: T) => T extends FnIn ? Exclude<T, FnIn> | FnOut : T;\n/**\n * Convert a `bytea` hex representation to a JavaScript `Buffer`. Note: for\n * large objects, use something like\n * [pg-large-object](https://www.npmjs.com/package/pg-large-object) instead.\n *\n * @param ba The `ByteArrayString` hex representation (or `null`)\n */\nexport declare const toBuffer: <T extends `\\\\x${string}` | null>(d: T) => T extends `\\\\x${string}` ? Buffer | Exclude<T, `\\\\x${string}`> : T;\n/**\n * Compiles to a numbered query parameter (`$1`, `$2`, etc) and adds the wrapped value\n * at the appropriate position of the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to\n * this type within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If\n * `true`, the value will be JSON stringified and cast to `json` (irrespective\n * of the configuration parameters `castArrayParamsToJson` and\n * `castObjectParamsToJson`). If `false`, the value will **not** be JSON-\n * stringified or cast to `json` (again irrespective of the configuration\n * parameters `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport declare class Parameter<T = any> {\n    value: T;\n    cast?: string | boolean | undefined;\n    constructor(value: T, cast?: string | boolean | undefined);\n}\n/**\n * Returns a `Parameter` instance, which compiles to a numbered query parameter\n * (`$1`, `$2`, etc) and adds its wrapped value at the appropriate position of\n * the values array passed to `pg`.\n * @param x The value to be wrapped\n * @param cast Optional cast type. If a string, the parameter will be cast to\n * this type within the query e.g. `CAST($1 AS type)` instead of plain `$1`. If\n * `true`, the value will be JSON stringified and cast to `json` (irrespective\n * of the configuration parameters `castArrayParamsToJson` and\n * `castObjectParamsToJson`). If `false`, the value will **not** be JSON\n * stringified or cast to `json` (again irrespective of the configuration\n * parameters `castArrayParamsToJson` and `castObjectParamsToJson`).\n */\nexport declare function param<T = any>(x: T, cast?: boolean | string): Parameter<T>;\n/**\n *  **DANGEROUS** \n *\n * Compiles to the wrapped string value, as is, which may enable SQL injection\n * attacks.\n */\nexport declare class DangerousRawString {\n    value: string;\n    constructor(value: string);\n}\n/**\n *  **DANGEROUS** \n *\n * Remember [Little Bobby Tables](https://xkcd.com/327/).\n * Did you want `db.param` instead?\n * ---\n * Returns a `DangerousRawString` instance, wrapping a string.\n * `DangerousRawString` compiles to the wrapped string value, as-is, which may\n * enable SQL injection attacks.\n */\nexport declare function raw(x: string): DangerousRawString;\n/**\n * Wraps either an array or object, and compiles to a quoted, comma-separated\n * list of array values (for use in a `SELECT` query) or object keys (for use\n * in an `INSERT`, `UPDATE` or `UPSERT` query, alongside `ColumnValues`).\n */\nexport declare class ColumnNames<T> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a `ColumnNames` instance, wrapping either an array or an object.\n * `ColumnNames` compiles to a quoted, comma-separated list of array values (for\n * use in a `SELECT` query) or object keys (for use in an `INSERT`, `UDPATE` or\n * `UPSERT` query alongside a `ColumnValues`).\n */\nexport declare function cols<T>(x: T): ColumnNames<T>;\n/**\n * Compiles to a quoted, comma-separated list of object keys for use in an\n * `INSERT`, `UPDATE` or `UPSERT` query, alongside `ColumnNames`.\n */\nexport declare class ColumnValues<T> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a ColumnValues instance, wrapping an object. ColumnValues compiles to\n * a  quoted, comma-separated list of object keys for use in an INSERT, UPDATE\n * or UPSERT query alongside a `ColumnNames`.\n */\nexport declare function vals<T>(x: T): ColumnValues<T>;\n/**\n * Compiles to the name of the column it wraps in the table of the parent query.\n * @param value The column name\n */\nexport declare class ParentColumn<T extends Column = Column> {\n    value: T;\n    constructor(value: T);\n}\n/**\n * Returns a `ParentColumn` instance, wrapping a column name, which compiles to\n * that column name of the table of the parent query.\n */\nexport declare function parent<T extends Column = Column>(x: T): ParentColumn<T>;\nexport declare type GenericSQLExpression = SQLFragment<any, any> | Parameter | DefaultType | DangerousRawString | SelfType;\nexport declare type SQLExpression = Table | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable | any[]> | Whereable | Column | GenericSQLExpression;\nexport declare type SQL = SQLExpression | SQLExpression[];\nexport declare type Queryable = pg.ClientBase | pg.Pool;\n/**\n * Tagged template function returning a `SQLFragment`. The first generic type\n * argument defines what interpolated value types are allowed. The second\n * defines what type the `SQLFragment` produces, where relevant (i.e. when\n * calling `.run(...)` on it, or using it as the value of an `extras` object).\n */\nexport declare function sql<Interpolations = SQL, RunResult = pg.QueryResult['rows'], Constraint = never>(literals: TemplateStringsArray, ...expressions: NoInfer<Interpolations>[]): SQLFragment<RunResult, Constraint>;\nexport declare class SQLFragment<RunResult = pg.QueryResult['rows'], Constraint = never> {\n    protected literals: string[];\n    protected expressions: SQL[];\n    protected constraint?: Constraint;\n    /**\n     * When calling `run`, this function is applied to the object returned by `pg`\n     * to produce the result that is returned. By default, the `rows` array is\n     * returned  i.e. `(qr) => qr.rows`  but some shortcut functions alter this\n     * in order to match their declared `RunResult` type.\n     */\n    runResultTransform: (qr: pg.QueryResult) => any;\n    parentTable?: string;\n    preparedName?: string;\n    noop: boolean;\n    noopResult: any;\n    constructor(literals: string[], expressions: SQL[]);\n    /**\n     * Instruct Postgres to treat this as a prepared statement: see\n     * https://node-postgres.com/features/queries#prepared-statements\n     * @param name A name for the prepared query. If not specified, it takes the\n     * value '_zapatos_prepared_N', where N is an increasing sequence number.\n     */\n    prepared: (name?: string) => this;\n    /**\n     * Compile and run this query using the provided database connection. What's\n     * returned is piped via `runResultTransform` before being returned.\n     * @param queryable A database client or pool\n     * @param force If true, force this query to hit the DB even if it's marked as a no-op\n     */\n    run: (queryable: Queryable, force?: boolean) => Promise<RunResult>;\n    /**\n     * Compile this query, returning a `{ text: string, values: any[] }` object\n     * that could be passed to the `pg` query function. Arguments are generally\n     * only passed when the function calls itself recursively.\n     */\n    compile: (result?: SQLQuery, parentTable?: string | undefined, currentColumn?: string | undefined) => SQLQuery;\n    compileExpression: (expression: SQL, result?: SQLQuery, parentTable?: string | undefined, currentColumn?: string | undefined) => void;\n}\n","node_modules/@types/zapatos/db/date.d.ts":"/**\n * An ISO8601-formatted date string, such as `\"2021-05-25\"`.\n */\nexport declare type DateString = `${number}-${number}-${number}`;\n/**\n * An ISO8601-formatted time string, such as `\"14:41\"` or `\"14:41:10.249\"`.\n */\nexport declare type TimeString = `${number}:${number}${'' | `:${number}`}`;\n/**\n * A timezone suffix string, such as `\"Z\"`, `\"-02\"`, or `\"+01:00\"`.\n */\nexport declare type TzSuffix = 'Z' | `${'+' | '-'}${number}${'' | `:${number}`}`;\n/**\n * A time and timezone string, such as `\"14:41:10+02\"`. **Postgres docs advise\n * against use of this type except in legacy contexts.**\n */\nexport declare type TimeTzString = `${TimeString}${TzSuffix}`;\n/**\n * An ISO8601-formatted date and time string **with no timezone**, such as\n * `\"2021-05-25T14:41.10.249097\"`.\n */\nexport declare type TimestampString = `${DateString}T${TimeString}`;\n/**\n * An ISO8601-formatted date, time and (numeric) timezone string, such as\n * `\"2021-05-25T14:41.10.249097+01:00\"`.\n */\nexport declare type TimestampTzString = `${TimestampString}${TzSuffix}`;\ndeclare type TzLocalOrUTC = 'UTC' | 'local';\ninterface ToDate {\n    <D extends null | TimestampTzString>(d: D, tzInterpretation?: undefined): D extends null ? null : Date;\n    <D extends null | TimestampString | DateString>(d: D, tzInterpretation: TzLocalOrUTC): D extends null ? null : Date;\n}\n/**\n * Convert a `TimestampTzString`, `TimestampString` or `DateString` to a\n * JavaScript `Date`. For `TimestampString` and `DateString`, you must specify\n * whether the input is to be interpreted in the JavaScript environment's local\n * time or as UTC.\n *\n * Nullability is preserved (e.g. `TimestampTzString | null` input gives\n * `Date | null` output).\n *\n * _Note:_ Postgres date-time types default to microsecond precision, but must be\n * truncated to the millisecond precision of a JavaScript `Date` here.\n *\n * @param d A `TimestampTzString`, `TimestampString` or `DateString` (or\n * `null`) for conversion.\n * @param tzInterpretation For `TimestampString` or `DateString` input only,\n * `\"UTC\"` if the input is to be interpreted as UTC or `\"local\"` if it is to be\n * interpreted in the JavaScript environment's local time\n */\nexport declare const toDate: ToDate;\ninterface ToString {\n    <D extends Date | null, T extends 'timestamptz' | `${'timestamp' | 'date'}:${TzLocalOrUTC}`>(d: D, stringTypeTz: T): D extends null ? null : {\n        'timestamptz': TimestampTzString;\n        'timestamp:UTC': TimestampString;\n        'timestamp:local': TimestampString;\n        'date:UTC': DateString;\n        'date:local': DateString;\n    }[T];\n}\n/**\n * Convert a JavaScript `Date` to a `TimestampTzString`, `TimestampString` or\n * `DateString`.\n *\n * For `TimestampString` and `DateString`, you must specify whether the input\n * is to be expressed in the JavaScript environment's local time or as UTC.\n *\n * Nullability is preserved (e.g. `Date | null` maps to something extending\n * `string | null`).\n *\n * @param d A `Date` (or `null`) for conversion.\n * @param stringTypeTz The pg type corresponding to the desired string format\n * and (except for `timestamptz`) whether to express in UTC or local time. For\n * example: `\"timestamptz\"`, `\"timestamp:local\"` or `\"date:UTC\"`.\n */\nexport declare const toString: ToString;\nexport {};\n","node_modules/@types/zapatos/db/index.d.ts":"export * from './canary';\nexport * from './config';\nexport * from './core';\nexport * from './date';\nexport * from './pgErrors';\nexport * from './shortcuts';\nexport * from './transaction';\nexport * as conditions from './conditions';\n","node_modules/@types/zapatos/db/pgErrors.d.ts":"interface Error {\n    code?: string;\n}\n/**\n * Check whether an error object matches any of a set of Postgres error types.\n * @param err The error to check\n * @param types The Postgres error types to check against\n */\nexport declare function isDatabaseError(err: Error, ...types: (keyof typeof pgErrors)[]): boolean;\ndeclare const pgErrors: {\n    SuccessfulCompletion: string;\n    Warning: string;\n    NoData: string;\n    SqlStatementNotYetComplete: string;\n    ConnectionException: string;\n    TriggeredActionException: string;\n    FeatureNotSupported: string;\n    InvalidTransactionInitiation: string;\n    LocatorException: string;\n    InvalidGrantor: string;\n    InvalidRoleSpecification: string;\n    DiagnosticsException: string;\n    CaseNotFound: string;\n    CardinalityViolation: string;\n    DataException: string;\n    IntegrityConstraintViolation: string;\n    InvalidCursorState: string;\n    InvalidTransactionState: string;\n    InvalidSqlStatementName: string;\n    TriggeredDataChangeViolation: string;\n    InvalidAuthorizationSpecification: string;\n    DependentPrivilegeDescriptorsStillExist: string;\n    InvalidTransactionTermination: string;\n    SqlRoutineException: string;\n    InvalidCursorName: string;\n    ExternalRoutineException: string;\n    ExternalRoutineInvocationException: string;\n    SavepointException: string;\n    InvalidCatalogName: string;\n    InvalidSchemaName: string;\n    TransactionRollback: string;\n    SyntaxErrorOrAccessRuleViolation: string;\n    WithCheckOptionViolation: string;\n    InsufficientResources: string;\n    DiskFull: string;\n    OutOfMemory: string;\n    TooManyConnections: string;\n    ConfigurationLimitExceeded: string;\n    ProgramLimitExceeded: string;\n    ObjectNotInPrerequisiteState: string;\n    OperatorIntervention: string;\n    SystemError: string;\n    SnapshotTooOld: string;\n    ConfigFileError: string;\n    FdwError: string;\n    PlpgsqlError: string;\n    InternalError: string;\n    SuccessfulCompletion_SuccessfulCompletion: string;\n    Warning_Warning: string;\n    Warning_NullValueEliminatedInSetFunction: string;\n    Warning_StringDataRightTruncation: string;\n    Warning_PrivilegeNotRevoked: string;\n    Warning_PrivilegeNotGranted: string;\n    Warning_ImplicitZeroBitPadding: string;\n    Warning_DynamicResultSetsReturned: string;\n    Warning_DeprecatedFeature: string;\n    NoData_NoData: string;\n    NoData_NoAdditionalDynamicResultSetsReturned: string;\n    SqlStatementNotYetComplete_SqlStatementNotYetComplete: string;\n    ConnectionException_ConnectionException: string;\n    ConnectionException_SqlclientUnableToEstablishSqlconnection: string;\n    ConnectionException_ConnectionDoesNotExist: string;\n    ConnectionException_SqlserverRejectedEstablishmentOfSqlconnection: string;\n    ConnectionException_ConnectionFailure: string;\n    ConnectionException_TransactionResolutionUnknown: string;\n    ConnectionException_ProtocolViolation: string;\n    TriggeredActionException_TriggeredActionException: string;\n    FeatureNotSupported_FeatureNotSupported: string;\n    InvalidTransactionInitiation_InvalidTransactionInitiation: string;\n    LocatorException_LocatorException: string;\n    LocatorException_InvalidLocatorSpecification: string;\n    InvalidGrantor_InvalidGrantor: string;\n    InvalidGrantor_InvalidGrantOperation: string;\n    InvalidRoleSpecification_InvalidRoleSpecification: string;\n    DiagnosticsException_DiagnosticsException: string;\n    DiagnosticsException_StackedDiagnosticsAccessedWithoutActiveHandler: string;\n    CaseNotFound_CaseNotFound: string;\n    CardinalityViolation_CardinalityViolation: string;\n    DataException_DataException: string;\n    DataException_StringDataRightTruncation: string;\n    DataException_NullValueNoIndicatorParameter: string;\n    DataException_NumericValueOutOfRange: string;\n    DataException_NullValueNotAllowed: string;\n    DataException_ErrorInAssignment: string;\n    DataException_InvalidDatetimeFormat: string;\n    DataException_DatetimeFieldOverflow: string;\n    DataException_InvalidTimeZoneDisplacementValue: string;\n    DataException_EscapeCharacterConflict: string;\n    DataException_InvalidUseOfEscapeCharacter: string;\n    DataException_InvalidEscapeOctet: string;\n    DataException_ZeroLengthCharacterString: string;\n    DataException_MostSpecificTypeMismatch: string;\n    DataException_SequenceGeneratorLimitExceeded: string;\n    DataException_NotAnXmlDocument: string;\n    DataException_InvalidXmlDocument: string;\n    DataException_InvalidXmlContent: string;\n    DataException_InvalidXmlComment: string;\n    DataException_InvalidXmlProcessingInstruction: string;\n    DataException_InvalidIndicatorParameterValue: string;\n    DataException_SubstringError: string;\n    DataException_DivisionByZero: string;\n    DataException_InvalidPrecedingOrFollowingSize: string;\n    DataException_InvalidArgumentForNtileFunction: string;\n    DataException_IntervalFieldOverflow: string;\n    DataException_InvalidArgumentForNthValueFunction: string;\n    DataException_InvalidCharacterValueForCast: string;\n    DataException_InvalidEscapeCharacter: string;\n    DataException_InvalidRegularExpression: string;\n    DataException_InvalidArgumentForLogarithm: string;\n    DataException_InvalidArgumentForPowerFunction: string;\n    DataException_InvalidArgumentForWidthBucketFunction: string;\n    DataException_InvalidRowCountInLimitClause: string;\n    DataException_InvalidRowCountInResultOffsetClause: string;\n    DataException_CharacterNotInRepertoire: string;\n    DataException_IndicatorOverflow: string;\n    DataException_InvalidParameterValue: string;\n    DataException_UnterminatedCString: string;\n    DataException_InvalidEscapeSequence: string;\n    DataException_StringDataLengthMismatch: string;\n    DataException_TrimError: string;\n    DataException_ArraySubscriptError: string;\n    DataException_InvalidTablesampleRepeat: string;\n    DataException_InvalidTablesampleArgument: string;\n    DataException_FloatingPointException: string;\n    DataException_InvalidTextRepresentation: string;\n    DataException_InvalidBinaryRepresentation: string;\n    DataException_BadCopyFileFormat: string;\n    DataException_UntranslatableCharacter: string;\n    DataException_NonstandardUseOfEscapeCharacter: string;\n    IntegrityConstraintViolation_IntegrityConstraintViolation: string;\n    IntegrityConstraintViolation_RestrictViolation: string;\n    IntegrityConstraintViolation_NotNullViolation: string;\n    IntegrityConstraintViolation_ForeignKeyViolation: string;\n    IntegrityConstraintViolation_UniqueViolation: string;\n    IntegrityConstraintViolation_CheckViolation: string;\n    IntegrityConstraintViolation_ExclusionViolation: string;\n    InvalidCursorState_InvalidCursorState: string;\n    InvalidTransactionState_InvalidTransactionState: string;\n    InvalidTransactionState_ActiveSqlTransaction: string;\n    InvalidTransactionState_BranchTransactionAlreadyActive: string;\n    InvalidTransactionState_InappropriateAccessModeForBranchTransaction: string;\n    InvalidTransactionState_InappropriateIsolationLevelForBranchTransaction: string;\n    InvalidTransactionState_NoActiveSqlTransactionForBranchTransaction: string;\n    InvalidTransactionState_ReadOnlySqlTransaction: string;\n    InvalidTransactionState_SchemaAndDataStatementMixingNotSupported: string;\n    InvalidTransactionState_HeldCursorRequiresSameIsolationLevel: string;\n    InvalidTransactionState_NoActiveSqlTransaction: string;\n    InvalidTransactionState_InFailedSqlTransaction: string;\n    InvalidTransactionState_IdleInTransactionSessionTimeout: string;\n    InvalidSqlStatementName_InvalidSqlStatementName: string;\n    TriggeredDataChangeViolation_TriggeredDataChangeViolation: string;\n    InvalidAuthorizationSpecification_InvalidAuthorizationSpecification: string;\n    InvalidAuthorizationSpecification_InvalidPassword: string;\n    DependentPrivilegeDescriptorsStillExist_DependentPrivilegeDescriptorsStillExist: string;\n    DependentPrivilegeDescriptorsStillExist_DependentObjectsStillExist: string;\n    InvalidTransactionTermination_InvalidTransactionTermination: string;\n    SqlRoutineException_SqlRoutineException: string;\n    SqlRoutineException_ModifyingSqlDataNotPermitted: string;\n    SqlRoutineException_ProhibitedSqlStatementAttempted: string;\n    SqlRoutineException_ReadingSqlDataNotPermitted: string;\n    SqlRoutineException_FunctionExecutedNoReturnStatement: string;\n    InvalidCursorName_InvalidCursorName: string;\n    ExternalRoutineException_ExternalRoutineException: string;\n    ExternalRoutineException_ContainingSqlNotPermitted: string;\n    ExternalRoutineException_ModifyingSqlDataNotPermitted: string;\n    ExternalRoutineException_ProhibitedSqlStatementAttempted: string;\n    ExternalRoutineException_ReadingSqlDataNotPermitted: string;\n    ExternalRoutineInvocationException_ExternalRoutineInvocationException: string;\n    ExternalRoutineInvocationException_InvalidSqlstateReturned: string;\n    ExternalRoutineInvocationException_NullValueNotAllowed: string;\n    ExternalRoutineInvocationException_TriggerProtocolViolated: string;\n    ExternalRoutineInvocationException_SrfProtocolViolated: string;\n    ExternalRoutineInvocationException_EventTriggerProtocolViolated: string;\n    SavepointException_SavepointException: string;\n    SavepointException_InvalidSavepointSpecification: string;\n    InvalidCatalogName_InvalidCatalogName: string;\n    InvalidSchemaName_InvalidSchemaName: string;\n    TransactionRollback_TransactionRollback: string;\n    TransactionRollback_SerializationFailure: string;\n    TransactionRollback_TransactionIntegrityConstraintViolation: string;\n    TransactionRollback_StatementCompletionUnknown: string;\n    TransactionRollback_DeadlockDetected: string;\n    SyntaxErrorOrAccessRuleViolation_SyntaxErrorOrAccessRuleViolation: string;\n    SyntaxErrorOrAccessRuleViolation_InsufficientPrivilege: string;\n    SyntaxErrorOrAccessRuleViolation_SyntaxError: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidName: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_NameTooLong: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateColumn: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousColumn: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedColumn: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedObject: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateObject: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateAlias: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateFunction: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousFunction: string;\n    SyntaxErrorOrAccessRuleViolation_GroupingError: string;\n    SyntaxErrorOrAccessRuleViolation_DatatypeMismatch: string;\n    SyntaxErrorOrAccessRuleViolation_WrongObjectType: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidForeignKey: string;\n    SyntaxErrorOrAccessRuleViolation_CannotCoerce: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedFunction: string;\n    SyntaxErrorOrAccessRuleViolation_GeneratedAlways: string;\n    SyntaxErrorOrAccessRuleViolation_ReservedName: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedTable: string;\n    SyntaxErrorOrAccessRuleViolation_UndefinedParameter: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateCursor: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateDatabase: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicatePreparedStatement: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateSchema: string;\n    SyntaxErrorOrAccessRuleViolation_DuplicateTable: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousParameter: string;\n    SyntaxErrorOrAccessRuleViolation_AmbiguousAlias: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidColumnReference: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidCursorDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidDatabaseDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidFunctionDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidPreparedStatementDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidSchemaDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidTableDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidObjectDefinition: string;\n    SyntaxErrorOrAccessRuleViolation_IndeterminateDatatype: string;\n    SyntaxErrorOrAccessRuleViolation_InvalidRecursion: string;\n    SyntaxErrorOrAccessRuleViolation_WindowingError: string;\n    SyntaxErrorOrAccessRuleViolation_CollationMismatch: string;\n    SyntaxErrorOrAccessRuleViolation_IndeterminateCollation: string;\n    WithCheckOptionViolation_WithCheckOptionViolation: string;\n    InsufficientResources_InsufficientResources: string;\n    InsufficientResources_DiskFull: string;\n    InsufficientResources_OutOfMemory: string;\n    InsufficientResources_TooManyConnections: string;\n    InsufficientResources_ConfigurationLimitExceeded: string;\n    ProgramLimitExceeded_ProgramLimitExceeded: string;\n    ProgramLimitExceeded_StatementTooComplex: string;\n    ProgramLimitExceeded_TooManyColumns: string;\n    ProgramLimitExceeded_TooManyArguments: string;\n    ObjectNotInPrerequisiteState_ObjectNotInPrerequisiteState: string;\n    ObjectNotInPrerequisiteState_ObjectInUse: string;\n    ObjectNotInPrerequisiteState_CantChangeRuntimeParam: string;\n    ObjectNotInPrerequisiteState_LockNotAvailable: string;\n    OperatorIntervention_OperatorIntervention: string;\n    OperatorIntervention_QueryCanceled: string;\n    OperatorIntervention_AdminShutdown: string;\n    OperatorIntervention_CrashShutdown: string;\n    OperatorIntervention_CannotConnectNow: string;\n    OperatorIntervention_DatabaseDropped: string;\n    SystemError_SystemError: string;\n    SystemError_IoError: string;\n    SystemError_UndefinedFile: string;\n    SystemError_DuplicateFile: string;\n    SnapshotTooOld_SnapshotTooOld: string;\n    ConfigFileError_ConfigFileError: string;\n    ConfigFileError_LockFileExists: string;\n    FdwError_FdwError: string;\n    FdwError_FdwOutOfMemory: string;\n    FdwError_FdwDynamicParameterValueNeeded: string;\n    FdwError_FdwInvalidDataType: string;\n    FdwError_FdwColumnNameNotFound: string;\n    FdwError_FdwInvalidDataTypeDescriptors: string;\n    FdwError_FdwInvalidColumnName: string;\n    FdwError_FdwInvalidColumnNumber: string;\n    FdwError_FdwInvalidUseOfNullPointer: string;\n    FdwError_FdwInvalidStringFormat: string;\n    FdwError_FdwInvalidHandle: string;\n    FdwError_FdwInvalidOptionIndex: string;\n    FdwError_FdwInvalidOptionName: string;\n    FdwError_FdwOptionNameNotFound: string;\n    FdwError_FdwReplyHandle: string;\n    FdwError_FdwUnableToCreateExecution: string;\n    FdwError_FdwUnableToCreateReply: string;\n    FdwError_FdwUnableToEstablishConnection: string;\n    FdwError_FdwNoSchemas: string;\n    FdwError_FdwSchemaNotFound: string;\n    FdwError_FdwTableNotFound: string;\n    FdwError_FdwFunctionSequenceError: string;\n    FdwError_FdwTooManyHandles: string;\n    FdwError_FdwInconsistentDescriptorInformation: string;\n    FdwError_FdwInvalidAttributeValue: string;\n    FdwError_FdwInvalidStringLengthOrBufferLength: string;\n    FdwError_FdwInvalidDescriptorFieldIdentifier: string;\n    PlpgsqlError_PlpgsqlError: string;\n    PlpgsqlError_RaiseException: string;\n    PlpgsqlError_NoDataFound: string;\n    PlpgsqlError_TooManyRows: string;\n    PlpgsqlError_AssertFailure: string;\n    InternalError_InternalError: string;\n    InternalError_DataCorrupted: string;\n    InternalError_IndexCorrupted: string;\n};\nexport {};\n","node_modules/@types/zapatos/db/shortcuts.d.ts":"import type { JSONSelectableForTable, WhereableForTable, InsertableForTable, UpdatableForTable, ColumnForTable, UniqueIndexForTable, SQLForTable, Table } from 'zapatos/schema';\nimport { AllType, SQLFragment } from './core';\nexport declare type JSONOnlyColsForTable<T extends Table, C extends any[]> = Pick<JSONSelectableForTable<T>, C[number]>;\nexport interface SQLFragmentMap {\n    [k: string]: SQLFragment<any>;\n}\nexport interface SQLFragmentOrColumnMap<T extends Table> {\n    [k: string]: SQLFragment<any> | ColumnForTable<T>;\n}\nexport declare type RunResultForSQLFragment<T extends SQLFragment<any, any>> = T extends SQLFragment<infer RunResult, any> ? RunResult : never;\nexport declare type LateralResult<L extends SQLFragmentMap> = {\n    [K in keyof L]: RunResultForSQLFragment<L[K]>;\n};\nexport declare type ExtrasResult<T extends Table, E extends SQLFragmentOrColumnMap<T>> = {\n    [K in keyof E]: E[K] extends SQLFragment<any> ? RunResultForSQLFragment<E[K]> : E[K] extends keyof JSONSelectableForTable<T> ? JSONSelectableForTable<T>[E[K]] : never;\n};\ndeclare type ExtrasOption<T extends Table> = SQLFragmentOrColumnMap<T> | undefined;\ndeclare type ColumnsOption<T extends Table> = ColumnForTable<T>[] | undefined;\ndeclare type LimitedLateralOption = SQLFragmentMap | undefined;\ndeclare type FullLateralOption = LimitedLateralOption | SQLFragment<any>;\ndeclare type LateralOption<C extends ColumnsOption<Table>, E extends ExtrasOption<Table>> = undefined extends C ? undefined extends E ? FullLateralOption : LimitedLateralOption : LimitedLateralOption;\nexport interface ReturningOptionsForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>> {\n    returning?: C;\n    extras?: E;\n}\ndeclare type ReturningTypeForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>> = (undefined extends C ? JSONSelectableForTable<T> : C extends ColumnForTable<T>[] ? JSONOnlyColsForTable<T, C> : never) & (undefined extends E ? {} : E extends SQLFragmentOrColumnMap<T> ? ExtrasResult<T, E> : never);\ninterface InsertSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: InsertableForTable<T>, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>>;\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: InsertableForTable<T>[], options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `INSERT` query `SQLFragment`.\n * @param table The table into which to insert\n * @param values The `Insertable` values (or array thereof) to be inserted\n */\nexport declare const insert: InsertSignatures;\n/**\n * Wraps a unique index of the target table for use as the arbiter constraint\n * of an `upsert` shortcut query.\n */\nexport declare class Constraint<T extends Table> {\n    value: UniqueIndexForTable<T>;\n    constructor(value: UniqueIndexForTable<T>);\n}\n/**\n * Returns a `Constraint` instance, wrapping a unique index of the target table\n * for use as the arbiter constraint of an `upsert` shortcut query.\n */\nexport declare function constraint<T extends Table>(x: UniqueIndexForTable<T>): Constraint<T>;\nexport interface UpsertAction {\n    $action: 'INSERT' | 'UPDATE';\n}\ndeclare type UpsertReportAction = 'suppress';\ndeclare type UpsertReturnableForTable<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, RA extends UpsertReportAction | undefined> = ReturningTypeForTable<T, C, E> & (undefined extends RA ? UpsertAction : {});\ndeclare type UpsertConflictTargetForTable<T extends Table> = Constraint<T> | ColumnForTable<T> | ColumnForTable<T>[];\ndeclare type UpdateColumns<T extends Table> = ColumnForTable<T> | ColumnForTable<T>[];\ninterface UpsertOptions<T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined> extends ReturningOptionsForTable<T, C, E> {\n    updateValues?: UpdatableForTable<T>;\n    updateColumns?: UC;\n    noNullUpdateColumns?: ColumnForTable<T> | ColumnForTable<T>[];\n    reportAction?: RA;\n}\ninterface UpsertSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined>(table: T, values: InsertableForTable<T>, conflictTarget: UpsertConflictTargetForTable<T>, options?: UpsertOptions<T, C, E, UC, RA>): SQLFragment<UpsertReturnableForTable<T, C, E, RA> | (UC extends never[] ? undefined : never)>;\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>, UC extends UpdateColumns<T> | undefined, RA extends UpsertReportAction | undefined>(table: T, values: InsertableForTable<T>[], conflictTarget: UpsertConflictTargetForTable<T>, options?: UpsertOptions<T, C, E, UC, RA>): SQLFragment<UpsertReturnableForTable<T, C, E, RA>[]>;\n}\nexport declare const doNothing: never[];\n/**\n * Generate an 'upsert' (`INSERT ... ON CONFLICT ...`) query `SQLFragment`.\n * @param table The table to update or insert into\n * @param values An `Insertable` of values (or an array thereof) to be inserted\n * or updated\n * @param conflictTarget A `UNIQUE`-indexed column (or array thereof) or a\n * `UNIQUE` index (wrapped in `db.constraint(...)`) that determines whether we\n * get an `UPDATE` (when there's a matching existing value) or an `INSERT`\n * (when there isn't)\n * @param options Optionally, an object with any of the keys `updateColumns`,\n * `noNullUpdateColumns` and `updateValues` (see documentation).\n */\nexport declare const upsert: UpsertSignatures;\ninterface UpdateSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, values: UpdatableForTable<T>, where: WhereableForTable<T> | SQLFragment, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `UPDATE` query `SQLFragment`.\n * @param table The table to update\n * @param values An `Updatable` of the new values with which to update the table\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to update\n */\nexport declare const update: UpdateSignatures;\nexport interface DeleteSignatures {\n    <T extends Table, C extends ColumnsOption<T>, E extends ExtrasOption<T>>(table: T, where: WhereableForTable<T> | SQLFragment, options?: ReturningOptionsForTable<T, C, E>): SQLFragment<ReturningTypeForTable<T, C, E>[]>;\n}\n/**\n * Generate an `DELETE` query `SQLFragment` (plain 'delete' is a reserved word)\n * @param table The table to delete from\n * @param where A `Whereable` (or `SQLFragment`) defining which rows to delete\n */\nexport declare const deletes: DeleteSignatures;\ndeclare type TruncateIdentityOpts = 'CONTINUE IDENTITY' | 'RESTART IDENTITY';\ndeclare type TruncateForeignKeyOpts = 'RESTRICT' | 'CASCADE';\ninterface TruncateSignatures {\n    (table: Table | Table[]): SQLFragment<undefined>;\n    (table: Table | Table[], optId: TruncateIdentityOpts): SQLFragment<undefined>;\n    (table: Table | Table[], optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n    (table: Table | Table[], optId: TruncateIdentityOpts, optFK: TruncateForeignKeyOpts): SQLFragment<undefined>;\n}\n/**\n * Generate a `TRUNCATE` query `SQLFragment`.\n * @param table The table (or array thereof) to truncate\n * @param opts Options: 'CONTINUE IDENTITY'/'RESTART IDENTITY' and/or\n * 'RESTRICT'/'CASCADE'\n */\nexport declare const truncate: TruncateSignatures;\ninterface OrderSpecForTable<T extends Table> {\n    by: SQLForTable<T>;\n    direction: 'ASC' | 'DESC';\n    nulls?: 'FIRST' | 'LAST';\n}\nexport interface SelectLockingOptions {\n    for: 'UPDATE' | 'NO KEY UPDATE' | 'SHARE' | 'KEY SHARE';\n    of?: Table | Table[];\n    wait?: 'NOWAIT' | 'SKIP LOCKED';\n}\nexport interface SelectOptionsForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>> {\n    distinct?: boolean | ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n    order?: OrderSpecForTable<T> | OrderSpecForTable<T>[];\n    limit?: number;\n    offset?: number;\n    withTies?: boolean;\n    columns?: C;\n    extras?: E;\n    groupBy?: ColumnForTable<T> | ColumnForTable<T>[] | SQLFragment<any>;\n    having?: WhereableForTable<T> | SQLFragment<any>;\n    lateral?: L;\n    alias?: string;\n    lock?: SelectLockingOptions | SelectLockingOptions[];\n}\ndeclare type SelectReturnTypeForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>> = (undefined extends L ? ReturningTypeForTable<T, C, E> : L extends SQLFragmentMap ? ReturningTypeForTable<T, C, E> & LateralResult<L> : L extends SQLFragment<any> ? RunResultForSQLFragment<L> : never);\nexport declare enum SelectResultMode {\n    Many = 0,\n    One = 1,\n    ExactlyOne = 2,\n    Count = 3\n}\nexport declare type FullSelectReturnTypeForTable<T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, M extends SelectResultMode> = {\n    [SelectResultMode.Many]: SelectReturnTypeForTable<T, C, L, E>[];\n    [SelectResultMode.ExactlyOne]: SelectReturnTypeForTable<T, C, L, E>;\n    [SelectResultMode.One]: SelectReturnTypeForTable<T, C, L, E> | undefined;\n    [SelectResultMode.Count]: number;\n}[M];\nexport interface SelectSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>, M extends SelectResultMode = SelectResultMode.Many>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>, mode?: M): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, M>>;\n}\nexport declare class NotExactlyOneError extends Error {\n    query: SQLFragment;\n    constructor(query: SQLFragment, ...params: any[]);\n}\n/**\n * Generate a `SELECT` query `SQLFragment`. This can be nested with other\n * `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. Keys (all optional) are:\n * * `columns`  an array of column names: only these columns will be returned\n * * `order`  an array of `OrderSpec` objects, such as\n * `{ by: 'column', direction: 'ASC' }`\n * * `limit` and `offset` numbers: apply this limit and offset to the query\n * * `lateral` either an object mapping keys to nested `select`/`selectOne`/\n * `count` queries to be `LATERAL JOIN`ed, or a single `select`/`selectOne`/\n * `count` query whose result will be passed through directly as the result of\n * the containing query\n * * `alias`  table alias (string): required if using `lateral` to join a table\n * to itself\n * * `extras` an object mapping key(s) to `SQLFragment`s, so that derived\n * quantities can be included in the JSON result\n * @param mode (Used internally by `selectOne` and `count`)\n */\nexport declare const select: SelectSignatures;\nexport interface SelectOneSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.One>>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns only a single result (or\n * undefined). A `LIMIT 1` clause is added automatically. This can be nested with\n * other `select`/`selectOne`/`count` queries using the `lateral` option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport declare const selectOne: SelectOneSignatures;\nexport interface SelectExactlyOneSignatures {\n    <T extends Table, C extends ColumnsOption<T>, L extends LateralOption<C, E>, E extends ExtrasOption<T>>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: SelectOptionsForTable<T, C, L, E>): SQLFragment<FullSelectReturnTypeForTable<T, C, L, E, SelectResultMode.ExactlyOne>>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a single result or\n * throws an error. A `LIMIT 1` clause is added automatically. This can be\n * nested with other `select`/`selectOne`/`count` queries using the `lateral`\n * option.\n * @param table The table to select from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be selected,\n * or `all`\n * @param options Options object. See documentation for `select` for details.\n */\nexport declare const selectExactlyOne: SelectExactlyOneSignatures;\nexport interface CountSignatures {\n    <T extends Table>(table: T, where: WhereableForTable<T> | SQLFragment | AllType, options?: {\n        columns?: ColumnsOption<T>;\n        alias?: string;\n    }): SQLFragment<number>;\n}\n/**\n * Generate a `SELECT` query `SQLFragment` that returns a count. This can be\n * nested in other `select`/`selectOne` queries using their `lateral` option.\n * @param table The table to count from\n * @param where A `Whereable` or `SQLFragment` defining the rows to be counted,\n * or `all`\n * @param options Options object. Keys are: `columns`, `alias`.\n */\nexport declare const count: CountSignatures;\nexport {};\n","node_modules/@types/zapatos/db/transaction.d.ts":"import * as pg from 'pg';\nexport declare enum IsolationLevel {\n    Serializable = \"SERIALIZABLE\",\n    RepeatableRead = \"REPEATABLE READ\",\n    ReadCommitted = \"READ COMMITTED\",\n    SerializableRO = \"SERIALIZABLE, READ ONLY\",\n    RepeatableReadRO = \"REPEATABLE READ, READ ONLY\",\n    ReadCommittedRO = \"READ COMMITTED, READ ONLY\",\n    SerializableRODeferrable = \"SERIALIZABLE, READ ONLY, DEFERRABLE\"\n}\nexport declare type IsolationSatisfying<T extends IsolationLevel> = {\n    [IsolationLevel.Serializable]: IsolationLevel.Serializable;\n    [IsolationLevel.RepeatableRead]: IsolationSatisfying<IsolationLevel.Serializable> | IsolationLevel.RepeatableRead;\n    [IsolationLevel.ReadCommitted]: IsolationSatisfying<IsolationLevel.RepeatableRead> | IsolationLevel.ReadCommitted;\n    [IsolationLevel.SerializableRO]: IsolationSatisfying<IsolationLevel.Serializable> | IsolationLevel.SerializableRO;\n    [IsolationLevel.RepeatableReadRO]: IsolationSatisfying<IsolationLevel.SerializableRO> | IsolationSatisfying<IsolationLevel.RepeatableRead> | IsolationLevel.RepeatableReadRO;\n    [IsolationLevel.ReadCommittedRO]: IsolationSatisfying<IsolationLevel.RepeatableReadRO> | IsolationSatisfying<IsolationLevel.ReadCommitted> | IsolationLevel.ReadCommittedRO;\n    [IsolationLevel.SerializableRODeferrable]: IsolationSatisfying<IsolationLevel.SerializableRO> | IsolationLevel.SerializableRODeferrable;\n}[T];\nexport interface TxnClient<T extends IsolationLevel> extends pg.PoolClient {\n    _zapatos?: {\n        isolationLevel: T;\n        txnId: number;\n    };\n}\nexport declare type TxnClientForSerializable = TxnClient<IsolationSatisfying<IsolationLevel.Serializable>>;\nexport declare type TxnClientForRepeatableRead = TxnClient<IsolationSatisfying<IsolationLevel.RepeatableRead>>;\nexport declare type TxnClientForReadCommitted = TxnClient<IsolationSatisfying<IsolationLevel.ReadCommitted>>;\nexport declare type TxnClientForSerializableRO = TxnClient<IsolationSatisfying<IsolationLevel.SerializableRO>>;\nexport declare type TxnClientForRepeatableReadRO = TxnClient<IsolationSatisfying<IsolationLevel.RepeatableReadRO>>;\nexport declare type TxnClientForReadCommittedRO = TxnClient<IsolationSatisfying<IsolationLevel.ReadCommittedRO>>;\nexport declare type TxnClientForSerializableRODeferrable = TxnClient<IsolationSatisfying<IsolationLevel.SerializableRODeferrable>>;\n/**\n * Provide a database client to the callback, whose queries are then wrapped in\n * a database transaction. The transaction is committed, retried, or rolled back\n * as appropriate.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate transaction client to be passed through\n * @param isolationLevel The desired isolation level (e.g.\n * `IsolationLevel.Serializable`)\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function transaction<T, M extends IsolationLevel>(txnClientOrPool: pg.Pool | TxnClient<IsolationSatisfying<M>>, isolationLevel: M, callback: (client: TxnClient<IsolationSatisfying<M>>) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `Serializable`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializable<T>(txnClientOrPool: pg.Pool | TxnClientForSerializable, callback: (client: TxnClientForSerializable) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `RepeatableRead`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function repeatableRead<T>(txnClientOrPool: pg.Pool | TxnClientForRepeatableRead, callback: (client: TxnClientForRepeatableRead) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `ReadCommitted`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function readCommitted<T>(txnClientOrPool: pg.Pool | TxnClientForReadCommitted, callback: (client: TxnClientForReadCommitted) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `SerializableRO`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializableRO<T>(txnClientOrPool: pg.Pool | TxnClientForSerializableRO, callback: (client: TxnClientForSerializableRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `RepeatableReadRO`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function repeatableReadRO<T>(txnClientOrPool: pg.Pool | TxnClientForRepeatableReadRO, callback: (client: TxnClientForRepeatableReadRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `ReadCommittedRO`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function readCommittedRO<T>(txnClientOrPool: pg.Pool | TxnClientForReadCommittedRO, callback: (client: TxnClientForReadCommittedRO) => Promise<T>): Promise<T>;\n/**\n * Shortcut for `transaction` with isolation level `SerializableRODeferrable`.\n * @param txnClientOrPool The `pg.Pool` from which to check out the database\n * client or an appropriate client to be passed through\n * @param callback A callback function that runs queries on the client provided\n * to it\n */\nexport declare function serializableRODeferrable<T>(txnClientOrPool: pg.Pool | TxnClientForSerializableRODeferrable, callback: (client: TxnClientForSerializableRODeferrable) => Promise<T>): Promise<T>;\n","node_modules/@types/zapatos/db/utils.d.ts":"export declare type NoInfer<T> = [T][T extends any ? 0 : never];\n/**\n * Basic zero-padding for small, positive integers\n * @param n The integer to pad\n * @param pad The minimum desired output string length: 2, 3 or 4\n */\nexport declare const pad: (n: number, pad?: 2 | 3 | 4) => string;\n/**\n * Simple promisification of setTimeout.\n * @param delayMs Time to wait, in milliseconds\n */\nexport declare const wait: (delayMs: number) => Promise<unknown>;\n/**\n * Map an input array to an output array, interspersing a constant separator value\n * between the mapped values.\n * @param arr Input array\n * @param separator Separator value\n * @param cb Mapping function\n */\nexport declare const mapWithSeparator: <TIn, TSep, TOut>(arr: TIn[], separator: TSep, cb: (x: TIn, i: number, a: TIn[]) => TOut) => (TSep | TOut)[];\n/**\n * Map an array of objects to an output array by taking the union of all objects' keys\n * and ensuring that any key not present on any object gets a default value.\n *\n * `e.g. [{ x: 1 }, { y: 2 }] => [{ x: 1, y: defaultValue }, { x: defaultValue, y: 2}]`\n * @param objs The array of objects\n * @param defaultValue The default value to assign to missing keys for each object\n */\nexport declare const completeKeysWithDefaultValue: <T extends object>(objs: T[], defaultValue: any) => T[];\n/**\n * Test that a value is a Plain Old JavaScript Object (such as one created by an object\n * literal, e.g. `{x: 1, y: 2}`)\n * @param x The value to test\n */\nexport declare const isPOJO: (x: any) => boolean;\n","node_modules/@types/zapatos/generate/cli.d.ts":"#!/usr/bin/env node\nexport {};\n","node_modules/@types/zapatos/generate/config.d.ts":"import type * as pg from 'pg';\nexport interface RequiredConfig {\n    db: pg.ClientConfig;\n}\nexport interface OptionalConfig {\n    outDir: string;\n    outExt: string;\n    schemas: SchemaRules;\n    progressListener: boolean | ((s: string) => void);\n    warningListener: boolean | ((s: string) => void);\n    customTypesTransform: 'PgMy_type' | 'my_type' | 'PgMyType' | ((s: string) => string);\n    columnOptions: ColumnOptions;\n    schemaJSDoc: boolean;\n}\ninterface SchemaRules {\n    [schema: string]: {\n        include: '*' | string[];\n        exclude: '*' | string[];\n    };\n}\ninterface ColumnOptions {\n    [k: string]: {\n        [k: string]: {\n            insert?: 'auto' | 'excluded' | 'optional';\n            update?: 'auto' | 'excluded';\n        };\n    };\n}\nexport declare type Config = RequiredConfig & Partial<OptionalConfig>;\nexport declare type CompleteConfig = RequiredConfig & OptionalConfig;\nexport declare const moduleRoot: () => string;\nexport declare const finaliseConfig: (config: Config) => CompleteConfig;\nexport {};\n","node_modules/@types/zapatos/generate/enums.d.ts":"import * as pg from 'pg';\nexport declare type EnumData = {\n    [k: string]: string[];\n};\nexport declare const enumDataForSchema: (schemaName: string, pool: pg.Pool) => Promise<EnumData>;\nexport declare const enumTypesForEnumData: (enums: EnumData) => string;\n","node_modules/@types/zapatos/generate/header.d.ts":"export declare const header: () => string;\n","node_modules/@types/zapatos/generate/index.d.ts":"export * from './config';\nexport * from './enums';\nexport * from './pgTypes';\nexport * from './tables';\nexport * from './tsOutput';\nexport * from './write';\n","node_modules/@types/zapatos/generate/legacy.d.ts":"import { CompleteConfig } from \"./config\";\nexport declare function srcWarning(config: CompleteConfig): void;\n","node_modules/@types/zapatos/generate/pgTypes.d.ts":"import type { EnumData } from './enums';\ndeclare type TypeContext = 'JSONSelectable' | 'Selectable' | 'Insertable' | 'Updatable' | 'Whereable';\nexport declare const tsTypeForPgType: (pgType: string, enums: EnumData, context: TypeContext) => string;\nexport {};\n","node_modules/@types/zapatos/generate/tables.d.ts":"import * as pg from 'pg';\nimport type { EnumData } from './enums';\nimport type { CustomTypes } from './tsOutput';\nimport { CompleteConfig } from './config';\nexport interface Relation {\n    name: string;\n    type: 'table' | 'mview';\n}\nexport declare const relationsInSchema: (schemaName: string, pool: pg.Pool) => Promise<Relation[]>;\nexport declare const definitionForRelationInSchema: (rel: Relation, schemaName: string, enums: EnumData, customTypes: CustomTypes, config: CompleteConfig, pool: pg.Pool) => Promise<string>;\nexport declare const crossTableTypesForTables: (relations: Relation[]) => string;\n","node_modules/@types/zapatos/generate/tsOutput.d.ts":"import type { CompleteConfig } from './config';\nexport interface CustomTypes {\n    [name: string]: string;\n}\nexport declare const tsForConfig: (config: CompleteConfig) => Promise<{\n    ts: string;\n    customTypeSourceFiles: {\n        [k: string]: string;\n    };\n}>;\n","node_modules/@types/zapatos/generate/write.d.ts":"import { Config } from './config';\n/**\n * Generate a schema and supporting files and folders given a configuration.\n * @param suppliedConfig An object approximately matching `zapatosconfig.json`.\n */\nexport declare const generate: (suppliedConfig: Config) => Promise<void>;\n","node_modules/@types/zapatos/typings/zapatos/schema.d.ts":"export interface Updatable {\n    [k: string]: any;\n}\nexport interface Whereable {\n    [k: string]: any;\n}\nexport interface Insertable {\n    [k: string]: any;\n}\nexport declare type Table = string;\nexport declare type Column = string;\nexport declare type JSONSelectableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type SelectableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type WhereableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type InsertableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type UpdatableForTable<T extends Table> = {\n    [k: string]: any;\n};\nexport declare type ColumnForTable<T extends Table> = string;\nexport declare type UniqueIndexForTable<T extends Table> = string;\nexport declare type SQLForTable<T extends Table> = any;\n","node_modules/@types/pg/index.d.ts":"// Type definitions for pg 8.6\n// Project: http://github.com/brianc/node-postgres\n// Definitions by: Phips Peter <https://github.com/pspeter3>, Ravi van Rooijen <https://github.com/HoldYourWaffle>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n/// <reference types=\"node\" />\n\nimport events = require('events');\nimport stream = require('stream');\nimport pgTypes = require('pg-types');\nimport { NoticeMessage } from 'pg-protocol/dist/messages';\n\nimport { ConnectionOptions } from 'tls';\n\nexport interface ClientConfig {\n    user?: string;\n    database?: string;\n    password?: string | (() => string | Promise<string>);\n    port?: number;\n    host?: string;\n    connectionString?: string;\n    keepAlive?: boolean;\n    stream?: stream.Duplex;\n    statement_timeout?: false | number;\n    parseInputDatesAsUTC?: boolean;\n    ssl?: boolean | ConnectionOptions;\n    query_timeout?: number;\n    keepAliveInitialDelayMillis?: number;\n    idle_in_transaction_session_timeout?: number;\n    application_name?: string;\n    connectionTimeoutMillis?: number;\n    types?: CustomTypesConfig;\n}\n\nexport type ConnectionConfig = ClientConfig;\n\nexport interface Defaults extends ClientConfig {\n    poolSize?: number;\n    poolIdleTimeout?: number;\n    reapIntervalMillis?: number;\n    binary?: boolean;\n    parseInt8?: boolean;\n}\n\nexport interface PoolConfig extends ClientConfig {\n    // properties from module 'node-pool'\n    max?: number;\n    min?: number;\n    idleTimeoutMillis?: number;\n    log?: (...messages: any[]) => void;\n    Promise?: PromiseConstructorLike;\n}\n\nexport interface QueryConfig<I extends any[] = any[]> {\n    name?: string;\n    text: string;\n    values?: I;\n    types?: CustomTypesConfig;\n}\n\nexport interface CustomTypesConfig {\n    getTypeParser: typeof pgTypes.getTypeParser;\n}\n\nexport interface Submittable {\n    submit: (connection: Connection) => void;\n}\n\nexport interface QueryArrayConfig<I extends any[] = any[]> extends QueryConfig<I> {\n    rowMode: 'array';\n}\n\nexport interface FieldDef {\n    name: string;\n    tableID: number;\n    columnID: number;\n    dataTypeID: number;\n    dataTypeSize: number;\n    dataTypeModifier: number;\n    format: string;\n}\n\nexport interface QueryResultBase {\n    command: string;\n    rowCount: number;\n    oid: number;\n    fields: FieldDef[];\n}\n\nexport interface QueryResultRow {\n    [column: string]: any;\n}\n\nexport interface QueryResult<R extends QueryResultRow = any> extends QueryResultBase {\n    rows: R[];\n}\n\nexport interface QueryArrayResult<R extends any[] = any[]> extends QueryResultBase {\n    rows: R[];\n}\n\nexport interface Notification {\n    processId: number;\n    channel: string;\n    payload?: string;\n}\n\nexport interface ResultBuilder<R extends QueryResultRow = any> extends QueryResult<R> {\n    addRow(row: R): void;\n}\n\nexport interface QueryParse {\n    name: string;\n    text: string;\n    types: string[];\n}\n\nexport interface BindConfig {\n    portal?: string;\n    statement?: string;\n    binary?: string;\n    values?: Array<Buffer | null | undefined | string>;\n}\n\nexport interface ExecuteConfig {\n    portal?: string;\n    rows?: string;\n}\n\nexport interface MessageConfig {\n    type: string;\n    name?: string;\n}\n\nexport class Connection extends events.EventEmitter {\n    readonly stream: stream.Duplex;\n\n    constructor(config?: ConnectionConfig);\n\n    bind(config: BindConfig | null, more: boolean): void;\n    execute(config: ExecuteConfig | null, more: boolean): void;\n    parse(query: QueryParse, more: boolean): void;\n\n    query(text: string): void;\n\n    describe(msg: MessageConfig, more: boolean): void;\n    close(msg: MessageConfig, more: boolean): void;\n\n    flush(): void;\n    sync(): void;\n    end(): void;\n}\n\n/**\n * {@link https://node-postgres.com/api/pool}\n */\nexport class Pool extends events.EventEmitter {\n    /**\n     * Every field of the config object is entirely optional.\n     * The config passed to the pool is also passed to every client\n     * instance within the pool when the pool creates that client.\n     */\n    constructor(config?: PoolConfig);\n\n    readonly totalCount: number;\n    readonly idleCount: number;\n    readonly waitingCount: number;\n\n    connect(): Promise<PoolClient>;\n    connect(callback: (err: Error, client: PoolClient, done: (release?: any) => void) => void): void;\n\n    end(): Promise<void>;\n    end(callback: () => void): void;\n\n    query<T extends Submittable>(queryStream: T): T;\n    // tslint:disable:no-unnecessary-generics\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        values?: I,\n    ): Promise<QueryArrayResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryConfig: QueryConfig<I>,\n    ): Promise<QueryResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: I,\n    ): Promise<QueryResult<R>>;\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        callback: (err: Error, result: QueryArrayResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryText: string,\n        values: I,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    // tslint:enable:no-unnecessary-generics\n\n    on(event: 'error', listener: (err: Error, client: PoolClient) => void): this;\n    on(event: 'connect' | 'acquire' | 'remove', listener: (client: PoolClient) => void): this;\n}\n\nexport class ClientBase extends events.EventEmitter {\n    constructor(config?: string | ClientConfig);\n\n    connect(): Promise<void>;\n    connect(callback: (err: Error) => void): void;\n\n    query<T extends Submittable>(queryStream: T): T;\n    // tslint:disable:no-unnecessary-generics\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        values?: I,\n    ): Promise<QueryArrayResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryConfig: QueryConfig<I>,\n    ): Promise<QueryResult<R>>;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        values?: I,\n    ): Promise<QueryResult<R>>;\n    query<R extends any[] = any[], I extends any[] = any[]>(\n        queryConfig: QueryArrayConfig<I>,\n        callback: (err: Error, result: QueryArrayResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryTextOrConfig: string | QueryConfig<I>,\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    query<R extends QueryResultRow = any, I extends any[] = any[]>(\n        queryText: string,\n        values: any[],\n        callback: (err: Error, result: QueryResult<R>) => void,\n    ): void;\n    // tslint:enable:no-unnecessary-generics\n\n    copyFrom(queryText: string): stream.Writable;\n    copyTo(queryText: string): stream.Readable;\n\n    pauseDrain(): void;\n    resumeDrain(): void;\n\n    escapeIdentifier(str: string): string;\n    escapeLiteral(str: string): string;\n\n    on(event: 'drain', listener: () => void): this;\n    on(event: 'error', listener: (err: Error) => void): this;\n    on(event: 'notice', listener: (notice: NoticeMessage) => void): this;\n    on(event: 'notification', listener: (message: Notification) => void): this;\n    // tslint:disable-next-line unified-signatures\n    on(event: 'end', listener: () => void): this;\n}\n\nexport class Client extends ClientBase {\n    user?: string;\n    database?: string;\n    port: number;\n    host: string;\n    password?: string;\n    ssl: boolean;\n\n    constructor(config?: string | ClientConfig);\n\n    end(): Promise<void>;\n    end(callback: (err: Error) => void): void;\n}\n\nexport interface PoolClient extends ClientBase {\n    release(err?: Error | boolean): void;\n}\n\nexport class Query<R extends QueryResultRow = any, I extends any[] = any> extends events.EventEmitter\n    implements Submittable {\n    constructor(queryTextOrConfig?: string | QueryConfig<I>, values?: I);\n    submit: (connection: Connection) => void;\n    on(event: 'row', listener: (row: R, result?: ResultBuilder<R>) => void): this;\n    on(event: 'error', listener: (err: Error) => void): this;\n    on(event: 'end', listener: (result: ResultBuilder<R>) => void): this;\n}\n\nexport class Events extends events.EventEmitter {\n    on(event: 'error', listener: (err: Error, client: Client) => void): this;\n}\n\nexport const types: typeof pgTypes;\n\nexport const defaults: Defaults & ClientConfig;\n\nimport * as Pg from '.';\n\nexport const native: typeof Pg | null;\n\nexport { DatabaseError } from 'pg-protocol';\n","node_modules/@types/pg/lib/type-overrides.d.ts":"import { CustomTypesConfig } from '..';\n\ntype TypeParser<TOid = number, TReturn = any> = (oid: TOid) => TReturn;\ntype TypeFormat = 'text' | 'binary';\n\nexport = TypeOverrides;\ndeclare class TypeOverrides implements CustomTypesConfig {\n    constructor(types?: CustomTypesConfig);\n    setTypeParser(oid: number, format: TypeFormat, fn: TypeParser): void;\n    setTypeParser(oid: number, fn: TypeParser): void;\n    getTypeParser(oid: number, format?: TypeFormat): TypeParser;\n}\n","node_modules/@types/luxon/index.d.ts":"// Type definitions for luxon 1.26\n// Project: https://github.com/moment/luxon#readme\n// Definitions by: Colby DeHart <https://github.com/colbydehart>\n//                 Hyeonseok Yang <https://github.com/FourwingsY>\n//                 Jonathan Siebern <https://github.com/jsiebern>\n//                 Matt R. Wilson <https://github.com/mastermatt>\n//                 Pietro Vismara <https://github.com/pietrovismara>\n//                 Janeene Beeforth <https://github.com/dawnmist>\n//                 Jason Yu <https://github.com/ycmjason>\n//                 Aitor Prez Rodal <https://github.com/Aitor1995>\n//                 Piotr Baejewicz <https://github.com/peterblazejewicz>\n//                 Carson Full <https://github.com/carsonf>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\nexport * from \"./src/luxon\";\n\nexport as namespace luxon;\n","node_modules/@types/luxon/src/datetime.d.ts":"import {\n    CalendarSystem,\n    DateTimeFormatOptions,\n    NumberingSystem,\n    StringUnitLength, ToISOFormat, ToISOTimeDurationOptions,\n    ZoneOptions,\n} from '../index';\nimport { Zone } from './zone';\nimport { Duration, DurationInput, DurationUnit, DurationUnits } from './duration';\nimport { Interval } from './interval';\n\nexport type ToRelativeUnit =\n    | 'years'\n    | 'quarters'\n    | 'months'\n    | 'weeks'\n    | 'days'\n    | 'hours'\n    | 'minutes'\n    | 'seconds';\n\nexport interface ToRelativeOptions extends ToRelativeCalendarOptions {\n    /**\n     * @default long\n     */\n    style?: StringUnitLength;\n    /** @default true */\n    round?: boolean;\n    /**\n     * Padding in milliseconds. This allows you to round up the result if it fits inside the threshold.\n     * Don't use in combination with {round: false} because the decimal output will include the padding.\n     * @default 0\n     */\n    padding?: number;\n}\n\nexport interface ToRelativeCalendarOptions {\n    /**\n     * The DateTime to use as the basis to which this time is compared\n     * @default now\n     */\n    base?: DateTime;\n    /**\n     * Override the locale of this DateTime\n     */\n    locale?: string;\n    /** If omitted, the method will pick the unit. */\n    unit?: ToRelativeUnit;\n    /**\n     * Override the numberingSystem of this DateTime.\n     * The Intl system may choose not to honor this.\n     */\n    numberingSystem?: NumberingSystem;\n}\n\nexport interface ToSQLOptions {\n    /**\n     * Include the offset, such as 'Z' or '-04:00'\n     * @default true\n     */\n    includeOffset?: boolean;\n    /**\n     * Include the zone, such as 'America/New_York'. Overrides includeOffset.\n     * @default false\n     */\n    includeZone?: boolean;\n}\n\nexport interface ToISODateOptions {\n    /**\n     * Choose between the basic and extended format\n     * @default 'extended'\n     */\n    format?: ToISOFormat;\n}\n\nexport interface ToISOTimeOptions extends ToISOTimeDurationOptions {\n    /**\n     * Include the offset, such as 'Z' or '-04:00'\n     * @default true\n     */\n    includeOffset?: boolean;\n}\n\n/** @deprecated alias for backwards compatibility */\nexport type ISOTimeOptions = ToISOTimeOptions;\n\nexport interface LocaleOptions {\n    /**\n     * @default system's locale\n     */\n    locale?: string;\n    outputCalendar?: CalendarSystem;\n    numberingSystem?: NumberingSystem;\n}\n\nexport interface DateTimeOptions extends LocaleOptions {\n    /**\n     * Use this zone if no offset is specified in the input string itself. Will also convert the time to this zone.\n     * @default local\n     */\n    zone?: string | Zone;\n    /**\n     * Override the zone with a fixed-offset zone specified in the string itself, if it specifies one.\n     * @default false\n     */\n    setZone?: boolean;\n}\n\nexport type DateTimeJSOptions = Omit<DateTimeOptions, 'setZone'>;\n\nexport interface DateObjectUnits {\n    // a year, such as 1987\n    year?: number;\n    // a month, 1-12\n    month?: number;\n    // a day of the month, 1-31, depending on the month\n    day?: number;\n    // day of the year, 1-365 or 366\n    ordinal?: number;\n    // an ISO week year\n    weekYear?: number;\n    // an ISO week number, between 1 and 52 or 53, depending on the year\n    weekNumber?: number;\n    // an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n    weekday?: number;\n    // hour of the day, 0-23\n    hour?: number;\n    // minute of the hour, 0-59\n    minute?: number;\n    // second of the minute, 0-59\n    second?: number;\n    // millisecond of the second, 0-999\n    millisecond?: number;\n}\n\nexport interface DateObject extends DateObjectUnits, LocaleOptions {\n    zone?: string | Zone;\n}\n\nexport type ConversionAccuracy = 'casual' | 'longterm';\n\nexport interface DiffOptions {\n    conversionAccuracy?: ConversionAccuracy;\n}\n\nexport interface ExplainedFormat {\n    input: string;\n    tokens: Array<{ literal: boolean; val: string }>;\n    regex?: RegExp;\n    rawMatches?: RegExpMatchArray | null;\n    matches?: { [k: string]: any };\n    result?: { [k: string]: any } | null;\n    zone?: Zone | null;\n    invalidReason?: string;\n}\n\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods.\n * It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link local}, {@link utc}, and (most flexibly) {@link fromObject}.\n *      To create one from a standard string format, use {@link fromISO}, {@link fromHTTP}, and {@link fromRFC2822}.\n *      To create one from a custom string format, use {@link fromFormat}. To create one from a native JS date, use {@link fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually\n *      (i.e as opposed to collectively through {@link toObject}), use the {@link year}, {@link month}, {@link day}, {@link hour}, {@link minute}, {@link second}, {@link millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link weekYear}, {@link weekNumber}, and {@link weekday} accessors.\n * * **Configuration** See the {@link locale} and {@link numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link set}, {@link reconfigure}, {@link setZone}, {@link setLocale},\n *      {@link plus}, {@link minus}, {@link endOf}, {@link startOf}, {@link toUTC}, and {@link toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link toRelative}, {@link toRelativeCalendar}, {@link toJSON}, {@link toISO},\n *      {@link toHTTP}, {@link toObject}, {@link toRFC2822}, {@link toString}, {@link toLocaleString}, {@link toFormat}, {@link toMillis} and {@link toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics\n * like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */\nexport class DateTime {\n    /**\n     * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_FULL: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_FULL_WITH_SECONDS: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_HUGE: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_HUGE_WITH_SECONDS: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_MED: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_MED_WITH_SECONDS: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_MED_WITH_WEEKDAY: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_SHORT: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.\n     */\n    static readonly DATETIME_SHORT_WITH_SECONDS: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'October 14, 1983'\n     */\n    static readonly DATE_FULL: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'Tuesday, October 14, 1983'\n     */\n    static readonly DATE_HUGE: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'Oct 14, 1983'\n     */\n    static readonly DATE_MED: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 'Fri, Oct 14, 1983'\n     */\n    static readonly DATE_MED_WITH_WEEKDAY: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like 10/14/1983\n     */\n    static readonly DATE_SHORT: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '09:30', always 24-hour.\n     */\n    static readonly TIME_24_SIMPLE: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.\n     */\n    static readonly TIME_24_WITH_LONG_OFFSET: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '09:30:23', always 24-hour.\n     */\n    static readonly TIME_24_WITH_SECONDS: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.\n     */\n    static readonly TIME_24_WITH_SHORT_OFFSET: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.\n     */\n    static readonly TIME_SIMPLE: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.\n     */\n    static readonly TIME_WITH_LONG_OFFSET: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.\n     */\n    static readonly TIME_WITH_SECONDS: DateTimeFormatOptions;\n    /**\n     * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.\n     */\n    static readonly TIME_WITH_SHORT_OFFSET: DateTimeFormatOptions;\n\n    /**\n     * Create a DateTime from an HTTP header date\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n     * @param text - the HTTP header date\n     * @param [options] - options to affect the creation\n     * @param [options.zone='local'] - convert the time to this zone.\n     * Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n     * @example\n     * DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n     * @example\n     * DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n     * @example\n     * DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n     */\n    static fromHTTP(text: string, options?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from an ISO 8601 string\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123')\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n     * @example\n     * DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n     * @example\n     * DateTime.fromISO('2016-W05-4')\n     */\n    static fromISO(text: string, options?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from a JavaScript Date object.\n     * Uses the default zone.\n     */\n    static fromJSDate(date: Date, options?: DateTimeJSOptions): DateTime;\n\n    /**\n     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC).\n     * Uses the default zone.\n     */\n    static fromMillis(ms: number, options?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n     * @example\n     * DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n     * @example\n     * DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'utc' }),\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'local' })\n     * @example\n     * DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'America/New_York' })\n     * @example\n     * DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n     */\n    static fromObject(obj: DateObject): DateTime;\n\n    /**\n     * Create a DateTime from an RFC 2822 string\n     * @example\n     * DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n     * @example\n     * DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n     * @example\n     * DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n     */\n    static fromRFC2822(text: string, options?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC).\n     * Uses the default zone.\n     */\n    static fromSeconds(seconds: number, options?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from a SQL date, time, or datetime\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale\n     * @example\n     * DateTime.fromSQL('2017-05-15')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n     * @example\n     * DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n     * @example\n     * DateTime.fromSQL('09:12:34.342')\n     */\n    static fromSQL(text: string, options?: DateTimeOptions): DateTime;\n\n    /**\n     * Create a DateTime from an input string and format string.\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n     * @see https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens\n     */\n    static fromFormat(text: string, format: string, opts?: DateTimeOptions): DateTime;\n\n    /**\n     * Explain how a string would be parsed by {@link fromFormat}\n     */\n    static fromFormatExplain(text: string, format: string, opts?: DateTimeOptions): ExplainedFormat;\n\n    /**\n     * @deprecated since 0.3.0. Use {@link fromFormat} instead\n     */\n    static fromString(text: string, format: string, options?: DateTimeOptions): DateTime;\n\n    /**\n     * @deprecated 0.3.0. Use {@link fromFormatExplain} instead\n     */\n    static fromStringExplain(\n        text: string,\n        format: string,\n        options?: DateTimeOptions,\n    ): ExplainedFormat;\n\n    /**\n     * Create an invalid DateTime.\n     * @param reason - simple string of why this DateTime is invalid.\n     *                 Should not contain parameters or anything else data-dependent\n     * @param [explanation] - longer explanation, may include parameters and other useful debugging information\n     */\n    static invalid(reason: string, explanation?: string): DateTime;\n\n    /**\n     * Check if an object is a DateTime. Works across context boundaries\n     */\n    static isDateTime(o: any): o is DateTime;\n\n    /**\n     * Create a local DateTime\n     * @param [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used\n     * @param [month=1] - The month, 1-indexed\n     * @param [day=1] - The day of the month, 1-indexed\n     * @param [hour=0] - The hour of the day, in 24-hour time\n     * @param [minute=0] - The minute of the hour, meaning a number between 0 and 59\n     * @param [second=0] - The second of the minute, meaning a number between 0 and 59\n     * @param [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n     * @example\n     * DateTime.local()                            //~> now\n     * @example\n     * DateTime.local(2017)                        //~> 2017-01-01T00:00:00\n     * @example\n     * DateTime.local(2017, 3)                     //~> 2017-03-01T00:00:00\n     * @example\n     * DateTime.local(2017, 3, 12)                 //~> 2017-03-12T00:00:00\n     * @example\n     * DateTime.local(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10\n     * @example\n     * DateTime.local(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765\n     */\n    static local(\n        year?: number,\n        month?: number,\n        day?: number,\n        hour?: number,\n        minute?: number,\n        second?: number,\n        millisecond?: number,\n    ): DateTime;\n\n    /** Return the maximum of several date times */\n    static max(): undefined;\n    /** Return the maximum of several date times */\n    static max(...dateTimes: DateTime[]): DateTime;\n\n    /** Return the minimum of several date times */\n    static min(): undefined;\n    /** Return the minimum of several date times */\n    static min(...dateTimes: DateTime[]): DateTime;\n\n    /**\n     * Create a DateTime for the current instant, in the system's time zone.\n     *\n     * Use Settings to override these default values if needed.\n     * @example\n     * DateTime.now().toISO() //~> now in the ISO format\n     */\n    static now(): DateTime;\n\n    /**\n     * Create a DateTime in UTC\n     * @param [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used\n     * @param [month=1] - The month, 1-indexed\n     * @param [day=1] - The day of the month\n     * @param [hour=0] - The hour of the day, in 24-hour time\n     * @param [minute=0] - The minute of the hour, meaning a number between 0 and 59\n     * @param [second=0] - The second of the minute, meaning a number between 0 and 59\n     * @param [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999\n     * @example\n     * DateTime.utc()                            //~> now\n     * @example\n     * DateTime.utc(2017)                        //~> 2017-01-01T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3)                     //~> 2017-03-01T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12)                 //~> 2017-03-12T00:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5)              //~> 2017-03-12T05:00:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45)          //~> 2017-03-12T05:45:00Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45, 10)      //~> 2017-03-12T05:45:10Z\n     * @example\n     * DateTime.utc(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765Z\n     */\n    static utc(\n        year?: number,\n        month?: number,\n        day?: number,\n        hour?: number,\n        minute?: number,\n        second?: number,\n        millisecond?: number,\n    ): DateTime;\n\n    /**\n     * Get the day of the month (1-30ish).\n     * @example\n     * DateTime.local(2017, 5, 25).day //=> 25\n     */\n    day: number;\n    /**\n     * Returns the number of days in this DateTime's month\n     * @example\n     * DateTime.local(2016, 2).daysInMonth //=> 29\n     * @example\n     * DateTime.local(2016, 3).daysInMonth //=> 31\n     */\n    daysInMonth: number;\n    /**\n     * Returns the number of days in this DateTime's year\n     * @example\n     * DateTime.local(2016).daysInYear //=> 366\n     * @example\n     * DateTime.local(2013).daysInYear //=> 365\n     */\n    daysInYear: number;\n    /**\n     * Get the hour of the day (0-23).\n     * @example\n     * DateTime.local(2017, 5, 25, 9).hour //=> 9\n     */\n    hour: number;\n    /**\n     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n     */\n    invalidReason: string | null;\n    /**\n     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n     */\n    invalidExplanation: string | null;\n    /**\n     * Get whether the DateTime is in a DST.\n     */\n    isInDST: boolean;\n    /**\n     * Returns true if this DateTime is in a leap year, false otherwise\n     * @example\n     * DateTime.local(2016).isInLeapYear //=> true\n     * @example\n     * DateTime.local(2013).isInLeapYear //=> false\n     */\n    isInLeapYear: boolean;\n    /**\n     * Get whether this zone's offset ever changes, as in a DST.\n     */\n    isOffsetFixed: boolean;\n    /**\n     * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n     * * The DateTime was created by an operation on another invalid date\n     */\n    isValid: boolean;\n    /**\n     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime\n     *\n     */\n    locale: string;\n    /**\n     * Get the millisecond of the second (0-999).\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n     */\n    millisecond: number;\n    /**\n     * Get the minute of the hour (0-59).\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n     */\n    minute: number;\n    /**\n     * Get the month (1-12).\n     * @example\n     * DateTime.local(2017, 5, 25).month //=> 5\n     */\n    month: number;\n    /**\n     * Get the human readable long month name, such as 'October'.\n     * Defaults to the system's locale if no locale has been specified\n     * @example\n     * DateTime.local(2017, 10, 30).monthLong //=> October\n     */\n    monthLong: string;\n    /**\n     * Get the human readable short month name, such as 'Oct'.\n     * Defaults to the system's locale if no locale has been specified\n     * @example\n     * DateTime.local(2017, 10, 30).monthShort //=> Oct\n     */\n    monthShort: string;\n    /**\n     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime\n     *\n     */\n    numberingSystem: string;\n    /**\n     * Get the UTC offset of this DateTime in minutes\n     * @example\n     * DateTime.now().offset //=> -240\n     * @example\n     * DateTime.utc().offset //=> 0\n     */\n    offset: number;\n    /**\n     * Get the long human name for the zone's current offset, for example \"Eastern Standard Time\" or \"Eastern Daylight Time\".\n     * Defaults to the system's locale if no locale has been specified\n     */\n    offsetNameLong: string;\n    /**\n     * Get the short human name for the zone's current offset, for example \"EST\" or \"EDT\".\n     * Defaults to the system's locale if no locale has been specified\n     */\n    offsetNameShort: string;\n    /**\n     * Get the ordinal (meaning the day of the year)\n     * @example\n     * DateTime.local(2017, 5, 25).ordinal //=> 145\n     */\n    ordinal: number;\n\n    /**\n     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime\n     */\n    outputCalendar: string;\n    /**\n     * Get the quarter\n     * @example\n     * DateTime.local(2017, 5, 25).quarter //=> 2\n     */\n    quarter: number;\n    /**\n     * Get the second of the minute (0-59).\n     * @example\n     * DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n     */\n    second: number;\n    /**\n     * Get the week number of the week year (1-52ish).\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     * @example\n     * DateTime.local(2017, 5, 25).weekNumber //=> 21\n     */\n    weekNumber: number;\n    /**\n     * Get the week year\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     * @example\n     * DateTime.local(2014, 11, 31).weekYear //=> 2015\n     */\n    weekYear: number;\n    /**\n     * Get the day of the week.\n     * 1 is Monday and 7 is Sunday\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     * @example\n     * DateTime.local(2014, 11, 31).weekday //=> 4\n     */\n    weekday: number;\n    /**\n     * Get the human readable long weekday, such as 'Monday'.\n     * Defaults to the system's locale if no locale has been specified\n     * @example\n     * DateTime.local(2017, 10, 30).weekdayLong //=> Monday\n     */\n    weekdayLong: string;\n    /**\n     * Get the human readable short weekday, such as 'Mon'.\n     * Defaults to the system's locale if no locale has been specified\n     * @example\n     * DateTime.local(2017, 10, 30).weekdayShort //=> Mon\n     */\n    weekdayShort: string;\n    /**\n     * Returns the number of weeks in this DateTime's year\n     * @see https://en.wikipedia.org/wiki/ISO_week_date\n     * @example\n     * DateTime.local(2004).weeksInWeekYear //=> 53\n     * @example\n     * DateTime.local(2013).weeksInWeekYear //=> 52\n     */\n    weeksInWeekYear: number;\n    /**\n     * Get the year\n     * @example\n     * DateTime.local(2017, 5, 25).year //=> 2017\n     */\n    year: number;\n    /**\n     * Get the name of the time zone.\n     */\n    zoneName: string;\n    /**\n     * Get the time zone associated with this DateTime.\n     */\n    zone: Zone;\n\n    /**\n     * Return the difference between two DateTimes as a Duration.\n     * @param other - the DateTime to compare this one to\n     * @param [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.\n     * @param [options] - options that affect the creation of the Duration\n     * @param [options.conversionAccuracy='casual'] - the conversion system to use\n     * @example\n     * let i1 = DateTime.fromISO('1982-05-25T09:45'),\n     *     i2 = DateTime.fromISO('1983-10-14T10:30');\n     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }\n     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }\n     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }\n     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }\n     */\n    diff(other: DateTime, unit?: DurationUnits, options?: DiffOptions): Duration;\n\n    /**\n     * Return the difference between this DateTime and right now.\n     * See {@link diff}\n     * @param [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration\n     * @param [options] - options that affect the creation of the Duration\n     * @param [options.conversionAccuracy='casual'] - the conversion system to use\n     */\n    diffNow(unit?: DurationUnits, options?: DiffOptions): Duration;\n\n    /**\n     * \"Set\" this DateTime to the end (meaning the last millisecond) of a unit of time\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'\n     */\n    endOf(unit: DurationUnit): DateTime;\n\n    /**\n     * Equality check\n     * Two DateTimes are equal if they represent the same millisecond, have the same zone and location, and are both valid.\n     * To compare just the millisecond values, use `+dt1 === +dt2`.\n     */\n    equals(other: DateTime): boolean;\n\n    /**\n     * Get the value of unit.\n     * @example\n     * DateTime.local(2017, 7, 4).get('month'); //=> 7\n     * @example\n     * DateTime.local(2017, 7, 4).get('day'); //=> 4\n     */\n    get(unit: keyof DateTime): number;\n\n    /**\n     * Return whether this DateTime is in the same unit of time as another DateTime.\n     * Higher-order units must also be identical for this function to return `true`.\n     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link setZone} to convert one of the dates if needed.\n     * @example\n     * DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day\n     */\n    hasSame(other: DateTime, unit: DurationUnit): boolean;\n\n    /**\n     * Subtract a period of time to this DateTime and return the resulting DateTime\n     * See {@link plus}\n     */\n    minus(duration: DurationInput): DateTime;\n\n    /**\n     * Add a period of time to this DateTime and return the resulting DateTime\n     *\n     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds.\n     * Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way.\n     * Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.\n     * @example\n     * DateTime.now().plus(123) //~> in 123 milliseconds\n     * @example\n     * DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes\n     * @example\n     * DateTime.now().plus({ days: 1 }) //~> this time tomorrow\n     * @example\n     * DateTime.now().plus({ days: -1 }) //~> this time yesterday\n     * @example\n     * DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min\n     * @example\n     * DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min\n     */\n    plus(duration: DurationInput): DateTime;\n\n    /**\n     * \"Set\" the locale options. Returns a newly-constructed DateTime.\n     */\n    reconfigure(properties: LocaleOptions): DateTime;\n\n    /**\n     * Returns the resolved Intl options for this DateTime.\n     * This is useful in understanding the behavior of formatting methods\n     */\n    resolvedLocaleOpts(options?: LocaleOptions & DateTimeFormatOptions): Intl.ResolvedDateTimeFormatOptions;\n\n    /**\n     * \"Set\" the values of specified units. Returns a newly-constructed DateTime.\n     * You can only set units with this method; for setting metadata, see {@link reconfigure} and {@link setZone}.\n     */\n    set(values: DateObjectUnits): DateTime;\n\n    /**\n     * \"Set\" the locale. Returns a newly-constructed DateTime.\n     * Just a convenient alias for reconfigure({ locale })\n     */\n    setLocale(locale: string): DateTime;\n\n    /**\n     * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n     *\n     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will\n     * report different local times and consider DSTs when making computations, as with {@link plus}.\n     * You may wish to use {@link toLocal} and {@link toUTC} which provide simple convenience wrappers for commonly used zones.\n     *\n     * @param zone - a zone identifier. As a string, that can be any IANA zone supported by the host environment,\n     * or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'.\n     * You may also supply an instance of a {@link Zone} class.\n     * @param [options] - options\n     */\n    setZone(zone: string | Zone, options?: ZoneOptions): DateTime;\n\n    /**\n     * \"Set\" this DateTime to the beginning of a unit of time.\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'\n     * @example\n     * DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'\n     * @example\n     * DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'\n     */\n    startOf(unit: DurationUnit): DateTime;\n\n    /**\n     * Returns a BSON serializable equivalent to this DateTime.\n     */\n    toBSON(): Date;\n\n    /**\n     * Returns a string representation of this DateTime formatted according to the specified format string.\n     *\n     * **You may not want this.** See {@link toLocaleString} for a more flexible formatting tool.\n     *\n     * For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens).\n     *\n     * Defaults to en-US if no locale has been specified, regardless of the system's locale.\n     *\n     * @see https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens\n     * @example\n     * DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'\n     * @example\n     * DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'\n     * @example\n     * DateTime.now().toFormat('yyyy LLL dd', { locale: \"fr\" }) //=> '2017 avr. 22'\n     * @example\n     * DateTime.now().toFormat(\"HH 'hours and' mm 'minutes'\") //=> '20 hours and 55 minutes'\n     */\n    toFormat(format: string, options?: LocaleOptions & DateTimeFormatOptions): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in HTTP headers.\n     * Specifically, the string conforms to RFC 1123.\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n     * @example\n     * DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'\n     * @example\n     * DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'\n     */\n    toHTTP(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime\n     * @example\n     * DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'\n     * @example\n     * DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'\n     * @example\n     * DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'\n     * @example\n     * DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'\n     */\n    toISO(options?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's date component\n     * @example\n     * DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'\n     * @example\n     * DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'\n     */\n    toISODate(options?: ToISODateOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's time component\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'\n     * @example\n     * DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'\n     */\n    toISOTime(options?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this DateTime's week date\n     * @example\n     * DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'\n     */\n    toISOWeekDate(): string;\n\n    /**\n     * Returns a JavaScript Date equivalent to this DateTime.\n     */\n    toJSDate(): Date;\n\n    /**\n     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.\n     * Called implicitly via {@link JSON.stringify}\n     */\n    toJSON(): string;\n\n    /**\n     * \"Set\" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.\n     *\n     * Equivalent to {@link setZone}('local')\n     */\n    toLocal(): DateTime;\n\n    /**\n     * Returns an array of format \"parts\", meaning individual tokens along with metadata.\n     * This is allows callers to post-process individual sections of the formatted output.\n     * Defaults to the system's locale if no locale has been specified\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts\n     * @example\n     * DateTime.now().toLocaleParts(); //=> [\n     *                                 //=>   { type: 'day', value: '25' },\n     *                                 //=>   { type: 'literal', value: '/' },\n     *                                 //=>   { type: 'month', value: '05' },\n     *                                 //=>   { type: 'literal', value: '/' },\n     *                                 //=>   { type: 'year', value: '1982' }\n     *                                 //=> ]\n     */\n    toLocaleParts(options?: LocaleOptions & DateTimeFormatOptions): any[];\n\n    /**\n     * Returns a localized string representing this date.\n     * Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}.\n     * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation\n     * of the DateTime in the assigned locale.\n     * Defaults to the system's locale if no locale has been specified\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     * @example\n     * DateTime.now().toLocaleString(); //=> 4/20/2017\n     * @example\n     * DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'\n     * @example\n     * DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'\n     * @example\n     * DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'\n     * @example\n     * DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'\n     * @example\n     * DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'\n     * @example\n     * DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hour12: false }); //=> '11:32'\n     */\n    toLocaleString(options?: LocaleOptions & DateTimeFormatOptions): string;\n\n    /**\n     * Returns the epoch milliseconds of this DateTime.\n     */\n    toMillis(): number;\n\n    /**\n     * Returns a JavaScript object with this DateTime's year, month, day, and so on.\n     * @example\n     * DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }\n     */\n    toObject(options?: {\n        /**\n         * Include configuration attributes in the output\n         * @default false\n         */\n        includeConfig?: boolean\n    }): DateObject;\n\n    /**\n     * Returns a string representation of a this time relative to now, such as \"in two days\".\n     * Can only internationalize if your platform supports Intl.RelativeTimeFormat. Rounds down by default.\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelative() //=> \"in 1 day\"\n     * @example\n     * DateTime.now().setLocale(\"es\").toRelative({ days: 1 }) //=> \"dentro de 1 da\"\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelative({ locale: \"fr\" }) //=> \"dans 23 heures\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelative() //=> \"2 days ago\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelative({ unit: \"hours\" }) //=> \"48 hours ago\"\n     * @example\n     * DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> \"1.5 days ago\"\n     */\n    toRelative(options?: ToRelativeOptions): string | null;\n\n    /**\n     * Returns a string representation of this date relative to today, such as \"yesterday\" or \"next month\".\n     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> \"tomorrow\"\n     * @example\n     * DateTime.now().setLocale(\"es\").plus({ days: 1 }).toRelative() //=> \"maana\"\n     * @example\n     * DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: \"fr\" }) //=> \"demain\"\n     * @example\n     * DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> \"2 days ago\"\n     */\n    toRelativeCalendar(options?: ToRelativeCalendarOptions): string | null;\n\n    /**\n     * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC\n     * @example\n     * DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'\n     * @example\n     * DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'\n     */\n    toRFC2822(): string;\n\n    /**\n     * Returns the epoch seconds of this DateTime.\n     */\n    toSeconds(): number;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL DateTime\n     * @example\n     * DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'\n     * @example\n     * DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'\n     */\n    toSQL(options?: ToSQLOptions): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL Date\n     * @example\n     * DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'\n     */\n    toSQLDate(): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for use in SQL Time\n     * @example\n     * DateTime.utc().toSQL() //=> '05:15:16.345'\n     * @example\n     * DateTime.now().toSQL() //=> '05:15:16.345 -04:00'\n     * @example\n     * DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'\n     * @example\n     * DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'\n     */\n    toSQLTime(options?: ToSQLOptions): string;\n\n    /**\n     * Returns a string representation of this DateTime appropriate for debugging\n     */\n    toString(): string;\n\n    /**\n     * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n     *\n     * Equivalent to {@link setZone}('utc')\n     * @param [offset=0] - optionally, an offset from UTC in minutes\n     * @param [options] - options to pass to `setZone()`\n     */\n    toUTC(offset?: number, options?: ZoneOptions): DateTime;\n\n    /**\n     * Return an Interval spanning between this DateTime and another DateTime\n     */\n    until(other: DateTime): Interval;\n\n    /**\n     * Returns the epoch milliseconds of this DateTime. Alias of {@link toMillis}\n     * Called implicitly when coercing types.\n     */\n    valueOf(): number;\n}\n","node_modules/@types/luxon/src/duration.d.ts":"import { DateTimeFormatOptions, NumberingSystem } from './misc';\nimport { ConversionAccuracy } from './datetime';\n\nexport interface DurationOptions {\n    locale?: string;\n    numberingSystem?: NumberingSystem;\n    conversionAccuracy?: ConversionAccuracy;\n}\n\nexport interface DurationObjectUnits {\n    year?: number;\n    years?: number;\n    quarter?: number;\n    quarters?: number;\n    month?: number;\n    months?: number;\n    week?: number;\n    weeks?: number;\n    day?: number;\n    days?: number;\n    hour?: number;\n    hours?: number;\n    minute?: number;\n    minutes?: number;\n    second?: number;\n    seconds?: number;\n    millisecond?: number;\n    milliseconds?: number;\n}\n\nexport interface DurationObject extends DurationObjectUnits, DurationOptions {}\n\nexport type DurationUnit = keyof DurationObjectUnits;\nexport type DurationUnits = DurationUnit | DurationUnit[];\n\nexport interface DurationToFormatOptions extends DateTimeFormatOptions {\n    floor?: boolean;\n    round?: boolean;\n}\n\nexport type ToISOFormat = 'basic' | 'extended';\n\nexport interface ToISOTimeDurationOptions {\n    /**\n     * Include the `T` prefix\n     * @default false\n     */\n    includePrefix?: boolean;\n    /**\n     * Exclude milliseconds from the format if they're 0\n     * @default false\n     */\n    suppressMilliseconds?: boolean;\n    /**\n     * Exclude seconds from the format if they're 0\n     * @default false\n     */\n    suppressSeconds?: boolean;\n    /**\n     * Choose between the basic and extended format\n     * @default 'extended'\n     */\n    format?: ToISOFormat;\n}\n\n/**\n * Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()\n */\nexport type DurationInput = Duration | number | DurationObject;\n\n/**\n * A Duration object represents a period of time, like \"2 months\" or \"1 day, 1 hour\".\n * Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods\n * for creating, parsing, interrogating, transforming, and formatting them.\n * They can be used on their own or in conjunction with other Luxon types;\n * for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.\n *\n * Here is a brief overview of commonly used methods and getters in Duration:\n *\n * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.\n * * **Unit values** See the {@link Duration.years}, {@link Duration.months}, {@link Duration.weeks}, {@link Duration.days},\n *                   {@link Duration.hours}, {@link Duration.minutes}, {@link Duration.seconds}, {@link Duration.milliseconds} accessors.\n * * **Configuration** See  {@link Duration.locale} and {@link Duration.numberingSystem} accessors.\n * * **Transformation** To create new Durations out of old ones use {@link Duration.plus}, {@link Duration.minus}, {@link Duration.normalize},\n *                      {@link Duration.set}, {@link Duration.reconfigure}, {@link Duration.shiftTo}, and {@link Duration.negate}.\n * * **Output** To convert the Duration into other representations, see {@link Duration.as}, {@link Duration.toISO}, {@link Duration.toFormat}, and {@link Duration.toJSON}\n *\n * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.\n */\nexport class Duration {\n    /**\n     * Create a Duration from an ISO 8601 duration string.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n     * @example\n     * Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }\n     * @example\n     * Duration.fromISO('PT23H').toObject() //=> { hours: 23 }\n     * @example\n     * Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }\n     */\n    static fromISO(text: string, options?: DurationOptions): Duration;\n\n    /**\n     * Create a Duration from an ISO 8601 time string.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n     * @example\n     * Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }\n     * @example\n     * Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     * @example\n     * Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }\n     */\n    static fromISOTime(text: string, options?: DurationOptions): Duration;\n\n    /**\n     * Create Duration from a number of milliseconds.\n     * @param count of milliseconds\n     * @param [options] - options for parsing\n     * @param [options.locale='en-US'] - the locale to use\n     * @param [options.numberingSystem] - the numbering system to use\n     * @param [options.conversionAccuracy='casual'] - the conversion system to use\n     */\n    static fromMillis(count: number, options?: DurationOptions): Duration;\n\n    /**\n     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.\n     * If this object is empty then a zero milliseconds duration is returned.\n     */\n    static fromObject(obj: DurationObject): Duration;\n\n    /**\n     * Create an invalid Duration.\n     * @param reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent\n     * @param [explanation] - longer explanation, may include parameters and other useful debugging information\n     */\n    static invalid(reason: string, explanation?: string): Duration;\n\n    /**\n     * Check if an object is a Duration. Works across context boundaries\n     */\n    static isDuration(o: any): o is Duration;\n\n    days: number;\n    hours: number;\n    /**\n     * Returns an error code if this Duration became invalid, or null if the Duration is valid\n     */\n    invalidReason: string | null;\n    /**\n     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid\n     */\n    invalidExplanation: string | null;\n\n    /**\n     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations\n     * on invalid DateTimes or Intervals.\n     */\n    isValid: boolean;\n\n    /**\n     * Get the locale of a Duration, such 'en-GB'\n     */\n    locale: string;\n    milliseconds: number;\n    minutes: number;\n    months: number;\n\n    /**\n     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration\n     */\n    numberingSystem: string;\n    quarters: number;\n    seconds: number;\n    weeks: number;\n    years: number;\n\n    /**\n     * Return the length of the duration in the specified unit.\n     * @example\n     * Duration.fromObject({years: 1}).as('days') //=> 365\n     * @example\n     * Duration.fromObject({years: 1}).as('months') //=> 12\n     * @example\n     * Duration.fromObject({hours: 60}).as('days') //=> 2.5\n     */\n    as(unit: DurationUnit): number;\n\n    /**\n     * Equality check\n     * Two Durations are equal if they have the same units and the same values for each unit.\n     */\n    equals(other: Duration): boolean;\n\n    /**\n     * Get the value of unit.\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).years //=> 2\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).months //=> 0\n     * @example\n     * Duration.fromObject({years: 2, days: 3}).days //=> 3\n     */\n    get(unit: DurationUnit): number;\n\n    /**\n     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.\n     */\n    minus(duration: DurationInput): Duration;\n\n    /**\n     * Return the negative of this Duration.\n     * @example\n     * Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }\n     */\n    negate(): Duration;\n\n    /**\n     * Reduce this Duration to its canonical representation in its current units.\n     * @example\n     * Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }\n     * @example\n     * Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }\n     */\n    normalize(): Duration;\n\n    /**\n     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.\n     */\n    plus(duration: DurationInput): Duration;\n\n    /**\n     * \"Set\" the Duration's options. Returns a newly-constructed Duration.\n     */\n    reconfigure(options: DurationOptions): Duration;\n\n    /**\n     * \"Set\" the values of specified units. Return a newly-constructed Duration.\n     */\n    set(values: DurationObjectUnits): Duration;\n\n    /**\n     * Convert this Duration into its representation in a different set of units.\n     * @example\n     * Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }\n     */\n    shiftTo(...units: DurationUnit[]): Duration;\n\n    /**\n     * Scale this Duration by the specified amount. Return a newly-constructed Duration.\n     * @example\n     * Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit(x => x * 2) //=> { hours: 2, minutes: 60 }\n     * @example\n     * Duration.fromObject({ hours: 1, minutes: 30 }).mapUnit((x, u) => u === \"hour\" ? x * 2 : x) //=> { hours: 2, minutes: 30 }\n     */\n    mapUnits(fn: (x: number, u: DurationUnit) => number): Duration;\n\n    /**\n     * Returns a string representation of this Duration formatted according to the specified format string.\n     *\n     * You may use these tokens:\n     * * `S` for milliseconds\n     * * `s` for seconds\n     * * `m` for minutes\n     * * `h` for hours\n     * * `d` for days\n     * * `M` for months\n     * * `y` for years\n     *\n     * Notes:\n     * * Add padding by repeating the token, e.g. `yy` pads the years to two digits, `hhhh` pads the hours out to four digits\n     * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Duration's conversion accuracy setting.\n     *\n     * @param format - the format string\n     * @param [options] - options\n     * @param [options.floor=true] - floor numerical values\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"y d s\") //=> \"1 6 2\"\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"yy dd sss\") //=> \"01 06 002\"\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat(\"M S\") //=> \"12 518402000\"\n     */\n    toFormat(format: string, options?: DurationToFormatOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Duration.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n     * @example\n     * Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'\n     * @example\n     * Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'\n     * @example\n     * Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'\n     * @example\n     * Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'\n     * @example\n     * Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'\n     */\n    toISO(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.\n     * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Times\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'\n     * @example\n     * Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'\n     */\n    toISOTime(options?: ToISOTimeDurationOptions): string; // | null\n\n    /**\n     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.\n     * Called implicitly via {@link JSON.stringify}\n     */\n    toJSON(): string;\n\n    /**\n     * Returns a milliseconds value of this Duration.\n     */\n    toMillis(): number;\n\n    /**\n     * Returns a JavaScript object with this Duration's values.\n     * @param [options] - options for generating the object\n     * @param [options.includeConfig=false] - include configuration attributes in the output\n     * @example\n     * Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }\n     */\n    toObject(options?: {\n        /**\n         * include configuration attributes in the output\n         */\n        includeConfig?: boolean\n    }): DurationObject;\n\n    /**\n     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.\n     */\n    toString(): string;\n\n    /**\n     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}\n     * Called implicitly when coercing types.\n     */\n    valueOf(): number;\n}\n","node_modules/@types/luxon/src/info.d.ts":"import { CalendarSystem, NumberingSystem, StringUnitLength, UnitLength } from './misc';\nimport { Zone } from './zone';\n\nexport interface InfoOptions {\n    locale?: string;\n}\n\nexport interface InfoUnitOptions extends InfoOptions {\n    numberingSystem?: NumberingSystem;\n}\n\n/** @deprecated */\nexport type UnitOptions = InfoUnitOptions;\n\nexport interface InfoCalendarOptions extends InfoUnitOptions {\n    outputCalendar?: CalendarSystem;\n}\n\nexport interface Features {\n    /**\n     * Whether this environment supports general internationalization\n     */\n    intl: boolean;\n    /**\n     * Whether this environment supports internationalized token-based formatting/parsing\n     */\n    intlTokens: boolean;\n    /**\n     * Whether this environment supports IANA timezones\n     */\n    zones: boolean;\n    /**\n     * Whether this environment supports relative time formatting\n     */\n    relative: boolean;\n}\n\n/**\n * The Info \"class\" contains static methods for retrieving general time and date related data.\n * For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale,\n * and for discovering which of Luxon features are available in the current environment.\n */\nexport namespace Info {\n    /**\n     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n     * @param [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n     * @param [options] - options\n     * @param [options.locale] - the locale code\n     * @example\n     * Info.eras() //=> [ 'BC', 'AD' ]\n     * @example\n     * Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n     * @example\n     * Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]\n     */\n    function eras(length?: StringUnitLength, options?: InfoOptions): string[];\n\n    /**\n     * Return the set of available features in this environment.\n     * Some features of Luxon are not available in all environments.\n     * For example, on older browsers, timezone support is not available.\n     * Use this function to figure out if that's the case.\n     * Keys:\n     * * `zones`: whether this environment supports IANA timezones\n     * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing\n     * * `intl`: whether this environment supports general internationalization\n     * * `relative`: whether this environment supports relative time formatting\n     */\n    function features(): Features;\n\n    /**\n     * Return whether the specified zone contains a DST.\n     * @param [zone='local'] - Zone to check. Defaults to the environment's local zone.\n     */\n    function hasDST(zone?: string | Zone): boolean;\n\n    /**\n     * Return whether the specified zone is a valid IANA specifier.\n     * @param zone - Zone to check\n     */\n    function isValidIANAZone(zone: string): boolean;\n\n    /**\n     * Converts the input into a {@link Zone} instance.\n     *\n     * * If `input` is already a Zone instance, it is returned unchanged.\n     * * If `input` is a string containing a valid time zone name, a Zone instance\n     *   with that name is returned.\n     * * If `input` is a string that doesn't refer to a known time zone, a Zone\n     *   instance with {@link Zone.isValid} == false is returned.\n     * * If `input is a number, a Zone instance with the specified fixed offset\n     *   in minutes is returned.\n     * * If `input` is `null` or `undefined`, the default zone is returned.\n     * @param [input] - the value to be converted\n     */\n    function normalizeZone(input?: number | string | Zone): Zone;\n\n    /**\n     * Return an array of meridiems.\n     * @param [options] - options\n     * @param [options.locale] - the locale code\n     * @example\n     * Info.meridiems() //=> [ 'AM', 'PM' ]\n     * @example\n     * Info.meridiems({ locale: 'my' }) //=> [ '', '' ]\n     */\n    function meridiems(options?: InfoOptions): string[];\n\n    /**\n     * Return an array of standalone month names.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     * @param [length='long'] - the length of the month representation\n     * @param [options] - options\n     * @param [options.locale] - the locale code\n     * @param [options.numberingSystem=null] - the numbering system\n     * @param [options.outputCalendar='gregory'] - the calendar\n     * @example\n     * Info.months()[0] //=> 'January'\n     * @example\n     * Info.months('short')[0] //=> 'Jan'\n     * @example\n     * Info.months('numeric')[0] //=> '1'\n     * @example\n     * Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n     * @example\n     * Info.months('numeric', { locale: 'ar' })[0] //=> ''\n     * @example\n     * Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'\n     */\n    function months(length?: UnitLength, options?: InfoCalendarOptions): string[];\n\n    /**\n     * Return an array of format month names.\n     * Format months differ from standalone months in that they're meant to appear next to the day of the month.\n     * In some languages, that changes the string.\n     * See {@link months}\n     * @param [length='long'] - the length of the month representation\n     * @param [options] - options\n     * @param [options.locale] - the locale code\n     * @param [options.numberingSystem=null] - the numbering system\n     * @param [options.outputCalendar='gregory'] - the calendar\n     */\n    function monthsFormat(length?: UnitLength, options?: InfoCalendarOptions): string[];\n\n    /**\n     * Return an array of standalone week names.\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n     * @param [length='long'] - the length of the weekday representation\n     * @param [options] - options\n     * @param [options.locale] - the locale code\n     * @param [options.numberingSystem=null] - the numbering system\n     * @example\n     * Info.weekdays()[0] //=> 'Monday'\n     * @example\n     * Info.weekdays('short')[0] //=> 'Mon'\n     * @example\n     * Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n     * @example\n     * Info.weekdays('short', { locale: 'ar' })[0] //=> ''\n     */\n    function weekdays(length?: StringUnitLength, options?: InfoUnitOptions): string[];\n\n    /**\n     * Return an array of format week names.\n     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information.\n     * In some languages, that changes the string.\n     * See {@link weekdays}\n     * @param [length='long'] - the length of the weekday representation\n     * @param [options] - options\n     * @param [options.locale=null] - the locale code\n     * @param [options.numberingSystem=null] - the numbering system\n     */\n    function weekdaysFormat(length?: StringUnitLength, options?: InfoUnitOptions): string[];\n}\n","node_modules/@types/luxon/src/interval.d.ts":"import { DateTime, DateObject, DateTimeOptions, DiffOptions, ToISOTimeOptions } from './datetime';\nimport { Duration, DurationInput, DurationUnit } from './duration';\n\nexport interface IntervalObject {\n    start?: DateTime;\n    end?: DateTime;\n}\n\nexport type DateInput = DateTime | DateObject | Date;\n\n/**\n * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}.\n * Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating,\n * comparing, transforming, and formatting them.\n *\n * Here is a brief overview of the most commonly used methods and getters in Interval:\n *\n * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.\n * * **Accessors** Use {@link start} and {@link end} to get the start and end.\n * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.\n * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge},\n *                      {@link xor}, {@link union}, {@link intersection}, or {@link difference}.\n * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}.\n * * **Output** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toISODate}, {@link toISOTime}, {@link toFormat}, and {@link toDuration}.\n */\nexport class Interval {\n    /**\n     * Create an Interval from a start DateTime and a Duration to extend to.\n     */\n    static after(start: DateInput, duration: DurationInput): Interval;\n\n    /**\n     * Create an Interval from an end DateTime and a Duration to extend backwards to.\n     */\n    static before(end: DateInput, duration: DurationInput): Interval;\n\n    /**\n     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.\n     */\n    static fromDateTimes(start: DateInput, end: DateInput): Interval;\n\n    /**\n     * Create an Interval from an ISO 8601 string.\n     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     */\n    static fromISO(text: string, options?: DateTimeOptions): Interval;\n\n    /**\n     * Create an invalid Interval.\n     * @param reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent\n     * @param [explanation] - longer explanation, may include parameters and other useful debugging information\n     */\n    static invalid(reason: string, explanation?: string): Interval;\n\n    /**\n     * Check if an object is an Interval. Works across context boundaries\n     */\n    static isInterval(o: any): o is Interval;\n\n    /**\n     * Merge an array of Intervals into a equivalent minimal set of Intervals.\n     * Combines overlapping and adjacent Intervals.\n     */\n    static merge(intervals: Interval[]): Interval[];\n\n    /**\n     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.\n     */\n    static xor(intervals: Interval[]): Interval[];\n\n    /**\n     * Returns the end of the Interval\n     */\n    end: DateTime;\n\n    /**\n     * Returns an error code if this Interval is invalid, or null if the Interval is valid\n     */\n    invalidReason: string | null;\n\n    /**\n     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid\n     */\n    invalidExplanation: string | null;\n\n    /**\n     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.\n     */\n    isValid: boolean;\n\n    /**\n     * Returns the start of the Interval\n     */\n    start: DateTime;\n\n    /**\n     * Return whether this Interval's start is adjacent to the specified Interval's end.\n     */\n    abutsEnd(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval's end is adjacent to the specified Interval's start.\n     */\n    abutsStart(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval contains the specified DateTime.\n     */\n    contains(dateTime: DateTime): boolean;\n\n    /**\n     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.\n     * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'\n     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'\n     * @param [unit='milliseconds'] - the unit of time to count.\n     */\n    count(unit?: DurationUnit): number;\n\n    /**\n     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.\n     */\n    difference(...intervals: Interval[]): Interval[];\n\n    /**\n     * Split this Interval into the specified number of smaller intervals.\n     * @param numberOfParts - The number of Intervals to divide the Interval into.\n     */\n    divideEqually(numberOfParts: number): Interval[];\n\n    /**\n     * Return whether this Interval engulfs the start and end of the specified Interval.\n     */\n    engulfs(other: Interval): boolean;\n\n    /**\n     * Return whether this Interval has the same start and end as the specified Interval.\n     * Two DateTimes are equal if they represent the same millisecond, have the same zone and location, and are both valid.\n     */\n    equals(other: Interval): boolean;\n\n    /**\n     * Returns whether this Interval's start and end are both in the same unit of time\n     * @param unit - the unit of time to check sameness on\n     */\n    hasSame(unit: DurationUnit): boolean;\n\n    /**\n     * Return an Interval representing the intersection of this Interval and the specified Interval.\n     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.\n     * Returns null if the intersection is empty, meaning, the intervals don't intersect.\n     */\n    intersection(other: Interval): Interval | null;\n\n    /**\n     * Return whether this Interval's start is after the specified DateTime.\n     */\n    isAfter(dateTime: DateTime): boolean;\n\n    /**\n     * Return whether this Interval's end is before the specified DateTime.\n     */\n    isBefore(dateTime: DateTime): boolean;\n\n    /**\n     * Return whether this Interval has the same start and end DateTimes.\n     */\n    isEmpty(): boolean;\n\n    /**\n     * Returns the length of the Interval in the specified unit.\n     * @param [unit='milliseconds'] - the unit to return the length in.\n     */\n    length(unit?: DurationUnit): number;\n\n    /**\n     * Return whether this Interval overlaps with the specified Interval\n     */\n    overlaps(other: Interval): boolean;\n\n    /**\n     * \"Sets\" the start and/or end dates. Returns a newly-constructed Interval.\n     */\n    set(values?: IntervalObject): Interval;\n\n    /**\n     * Split this Interval at each of the specified DateTimes\n     */\n    splitAt(...dateTimes: DateTime[]): Interval[];\n\n    /**\n     * Split this Interval into smaller Intervals, each of the specified length.\n     * Left over time is grouped into a smaller interval\n     * @param duration - The length of each resulting interval.\n     */\n    splitBy(duration: DurationInput): Interval[];\n\n    /**\n     * Return a Duration representing the time spanned by this interval.\n     * @param [unit=['milliseconds']] - the unit or units to include in the duration.\n     * @param [options] - options that affect the creation of the Duration\n     * @param [options.conversionAccuracy='casual'] - the conversion system to use\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }\n     */\n    toDuration(unit?: DurationUnit | DurationUnit[], options?: DiffOptions): Duration;\n\n    /**\n     * Returns a string representation of this Interval formatted according to the specified format string.\n     * @param dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.\n     * @param [options] - options\n     * @param [options.separator=' - '] - a separator to place between the start and end representations\n     */\n    toFormat(\n        dateFormat: string,\n        options?: {\n            separator?: string;\n        },\n    ): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of this Interval.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     */\n    toISO(options?: ToISOTimeOptions): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of date of this Interval.\n     * The time components are ignored.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     */\n    toISODate(): string;\n\n    /**\n     * Returns an ISO 8601-compliant string representation of time of this Interval.\n     * The date components are ignored.\n     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals\n     */\n    toISOTime(options?: ToISOTimeOptions): string;\n\n    /**\n     * Returns a string representation of this Interval appropriate for debugging.\n     */\n    toString(): string;\n\n    /**\n     * Return an Interval representing the union of this Interval and the specified Interval.\n     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.\n     */\n    union(other: Interval): Interval;\n\n    /**\n     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())\n     * @example\n     * Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))\n     */\n    mapEndpoints(mapFn: (d: DateTime) => DateTime): Interval;\n}\n","node_modules/@types/luxon/src/luxon.d.ts":"export const VERSION: string;\n\nexport * from './datetime';\nexport * from './duration';\nexport * from './info';\nexport * from './interval';\nexport * from './settings';\nexport * from './zone';\nexport * from './misc';\n","node_modules/@types/luxon/src/misc.d.ts":"export type DateTimeFormatOptions = Intl.DateTimeFormatOptions;\n\nexport interface ZoneOptions {\n    /**\n     * If true, adjust the underlying time so that the local time stays the same, but in the target zone.\n     * You should rarely need this.\n     * Defaults to false.\n     */\n    keepLocalTime?: boolean;\n    /**\n     * @deprecated since 0.2.12. Use keepLocalTime instead\n     */\n    keepCalendarTime?: boolean;\n}\n\n/** @deprecated */\nexport type EraLength = StringUnitLength;\n\nexport type NumberingSystem = Intl.DateTimeFormatOptions extends { numberingSystem?: infer T } ? T :\n    | 'arab'\n    | 'arabext'\n    | 'bali'\n    | 'beng'\n    | 'deva'\n    | 'fullwide'\n    | 'gujr'\n    | 'guru'\n    | 'hanidec'\n    | 'khmr'\n    | 'knda'\n    | 'laoo'\n    | 'latn'\n    | 'limb'\n    | 'mlym'\n    | 'mong'\n    | 'mymr'\n    | 'orya'\n    | 'tamldec'\n    | 'telu'\n    | 'thai'\n    | 'tibt';\n\nexport type CalendarSystem = Intl.DateTimeFormatOptions extends { calendar?: infer T } ? T :\n    | 'buddhist'\n    | 'chinese'\n    | 'coptic'\n    | 'ethioaa'\n    | 'ethiopic'\n    | 'gregory'\n    | 'hebrew'\n    | 'indian'\n    | 'islamic'\n    | 'islamicc'\n    | 'iso8601'\n    | 'japanese'\n    | 'persian'\n    | 'roc';\n\nexport type HourCycle = 'h11' | 'h12' | 'h23' | 'h24';\n\nexport type StringUnitLength = 'narrow' | 'short' | 'long';\nexport type NumberUnitLength = 'numeric' | '2-digit';\nexport type UnitLength = StringUnitLength | NumberUnitLength;\n","node_modules/@types/luxon/src/settings.d.ts":"import { Zone } from './zone';\n\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior.\n * Luxon is a simple library with few options, but the ones it does have live here.\n */\nexport namespace Settings {\n    /**\n     * The current function for returning the current timestamp.\n     * The function should return a number, which will be interpreted as an Epoch millisecond count\n     * @example\n     * Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n     * @example\n     * Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n     */\n    function now(): number;\n\n    /**\n     * The default time zone to create DateTimes in. Does not affect existing instances.\n     * Set this to change {@link defaultZone}\n     */\n    let defaultZoneName: string;\n\n    /**\n     * The default time zone object to create DateTimes in. Does not affect existing instances.\n     * Change by setting {@link defaultZoneName}\n     */\n    const defaultZone: Zone;\n\n    /**\n     * The default locale to create DateTimes with. Does not affect existing instances.\n     */\n    let defaultLocale: string;\n\n    /**\n     * The default numbering system to create DateTimes with. Does not affect existing instances.\n     */\n    let defaultNumberingSystem: string;\n\n    /**\n     * The default output calendar to create DateTimes with. Does not affect existing instances.\n     */\n    let defaultOutputCalendar: string;\n\n    /**\n     * Whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n     */\n    let throwOnInvalid: boolean;\n\n    /**\n     * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n     */\n    function resetCaches(): void;\n}\n","node_modules/@types/luxon/src/zone.d.ts":"export interface ZoneOffsetOptions {\n    /**\n     * What style of offset to return.\n     */\n    format?: 'short' | 'long';\n    /**\n     * What locale to return the offset name in.\n     */\n    locale?: string;\n}\n\n/**\n * What style of offset to return.\n * Returning '+6', '+06:00', or '+0600' respectively\n */\nexport type ZoneOffsetFormat = | 'narrow' | 'short' | 'techie';\n\nexport class Zone {\n    /**\n     * The type of zone\n     */\n    type: string;\n\n    /**\n     * The name of this zone.\n     */\n    name: string;\n\n    /**\n     * Returns whether the offset is known to be fixed for the whole year.\n     */\n    universal: boolean;\n\n    /**\n     * Returns the offset's common name (such as EST) at the specified timestamp\n     * @param ts - Epoch milliseconds for which to get the name\n     * @param options - Options to affect the format\n     * @param options.format - What style of offset to return.\n     * @param options.locale - What locale to return the offset name in.\n     */\n    offsetName(ts: number, options: ZoneOffsetOptions): string;\n\n    /**\n     * Returns the offset's value as a string\n     * @param ts - Epoch milliseconds for which to get the offset\n     * @param format - What style of offset to return.\n     *                 Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively\n     */\n    formatOffset(ts: number, format: ZoneOffsetFormat): string;\n\n    /**\n     * Return the offset in minutes for this zone at the specified timestamp.\n     * @param ts - Epoch milliseconds for which to compute the offset\n     */\n    offset(ts: number): number;\n\n    /**\n     * Return whether this Zone is equal to another zone\n     * @param other - the zone to compare\n     */\n    equals(other: Zone): boolean;\n\n    /**\n     * Return whether this Zone is valid.\n     */\n    isValid: boolean;\n}\n\n/**\n * A zone identified by an IANA identifier, like America/New_York\n */\nexport class IANAZone extends Zone {\n    constructor(ianaString: string);\n\n    /**\n     * Same as constructor but has caching.\n     */\n    static create(ianaString: string): IANAZone;\n\n    /**\n     * Returns whether the provided string is a valid specifier.\n     * This only checks the string's format, not that the specifier\n     * identifies a known zone; see {@link isValidZone} for that.\n     *\n     * @param s - The string to check validity on\n     * @example\n     * IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n     * @example\n     * IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\n     * @example\n     * IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n     */\n    static isValidSpecifier(s: string): boolean;\n\n    /**\n     * Returns whether the provided string identifies a real zone\n     * @param zone - The string to check\n     * @example\n     * IANAZone.isValidZone(\"America/New_York\") //=> true\n     * @example\n     * IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n     * @example\n     * IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n     */\n    static isValidZone(zone: string): boolean;\n\n    /**\n     * Reset local caches. Should only be necessary in testing scenarios.\n     */\n    static resetCache(): void;\n}\n\n/**\n * A zone with a fixed offset (meaning no DST)\n */\nexport class FixedOffsetZone extends Zone {\n    /**\n     * Get a singleton instance of UTC\n     */\n    static utcInstance: FixedOffsetZone;\n\n    /**\n     * Get an instance with a specified offset\n     * @param offset - The offset in minutes\n     */\n    static instance(offset: number): FixedOffsetZone;\n\n    /**\n     * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n     * @param s - The offset string to parse\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC+6\")\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC+06\")\n     * @example\n     * FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n     */\n    static parseSpecifier(s: string): FixedOffsetZone;\n}\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n */\nexport class InvalidZone extends Zone { }\n\n/**\n * Represents the local zone for this JavaScript environment.\n */\nexport class LocalZone extends Zone {\n    /**\n     * Get a singleton instance of the local zone\n     */\n    static instance: LocalZone;\n}\n","pgPool.ts":"\n      import * as pg from 'pg';\n      export default new pg.Pool();"};